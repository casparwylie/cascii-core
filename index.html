<html>
  <head>
    <style>
      #canvas {
        background: grey;
        user-select: none;
      }

      #menu {
        background: blue;
        height: 50px;
      }

      #menu button {
        background: green;
        padding: 10px;
        margin-left: 10px;
        float: left;
      }
    </style>
  </head>
  <body>
    <div id="menu"></div>
    <div id="canvas"></div>

  <script defer>

    const masterRowCount = 50;
    const masterColCount = 80;

    const pixelSize = 17;
    
    function reportError(message) {
      console.log(message);
    }

    //////////////////
    ////// MODES /////
    //////////////////

    class ModeMaster {
      constructor() {
        this._modes = []
      }

      change(beforeMode, afterMode) {
        let index = this._modes.indexOf(beforeMode);
        if (index == -1) {
          reportError(`Bad mode change ${this._modes}: ${beforeMode} -> ${afterMode}`);
          return;
        }
        this._modes[index] = afterMode;
      }

      remove(...modes) {
        modes.forEach((mode) => {
          let index = this._modes.indexOf(mode);
          if (index == -1) reportError(`Bad mode removal ${this._modes}: ${mode}`);
          this._modes.splice(index, 1);
        });
      }

      reset(...modes) {
        this._modes = modes;
      }

      add(...modes) {
        this._modes = this._modes.concat(modes);
      }

      has(...modes) {
        return modes.map((mode) => this._modes.includes(mode)).every(Boolean);
      }

      is(...modes) {
        return this._modes.toString() == modes.toString(); 
      }

      get(modes, insist=false) {
        let result = modes.filter((mode) => this._modes.includes(mode));
        if (insist && result.length == 0) reportError(`Bad mode get ${this._modes}: expected ${modes}`);
        return result
      }
    }

    ////////////////////
    ////// LAYERS //////
    ////////////////////

    class LayerManager {
      constructor() {
        this.layers = [];
        this.selectedPixel = null;
        this.textCursor = 0;
      }

      add(layer) {
        this.layers.unshift(layer);
      } 

      getLatestLayer() {
        return this.layers[0];
      }

      getLayerByPixelId(id) {
        for (var layer of this.layers) {
          if (layer.hasPixel(id)) return layer;
        }
      }

      getSelectedLayers() {
        return this.layers.filter((layer) => layer.isSelected());
      }

      deleteSelectedLayers() {
        this.getSelectedLayers().forEach((layer) => layer.empty());
        this.refreshAll();
      }

      unselectAll() {
        this.selectedLayers = [];
        this.layers.forEach((layer) => layer.unselect());
      }

      refreshAll() {
        canvas.clear();
        this.layers = this.layers.filter((layer) => layer.pixels.length);
        this.layers.forEach((layer) => layer.render());
      }
      
      setSelectPixel(selectedPixel) {
        this.selectedPixel = selectedPixel;
      }

      getSelectPixel() {
        return this.selectedPixel;
      }

      moveSelectedLayers(verticalDiff, lateralDiff) {
        this.getSelectedLayers().forEach((layer) => layer.move(verticalDiff, lateralDiff));
        layerManager.refreshAll();
      }
    }
    
    let layerManager = new LayerManager();

    class Layer {
      constructor(firstPixelId) {
        this.firstPixel = canvas.getPixelById(firstPixelId);
        this.pixels = [];
        this.values = [];
        this._isSelected = false;

        layerManager.setSelectPixel(this.firstPixel);
        layerManager.add(this);
      }

      draw(pixel, value) {
        pixel.setValue(value);
        this.pixels.push(pixel);
        this.values.push(value);
      }
      
      clear() {
        this.pixels.forEach((pixel) => pixel.clear());
      }

      render() {
        for (var i = 0; i < this.pixels.length; i++) {
          this.pixels[i].setValue(this.values[i]);
        }
        if (this.isSelected()) this.select();
      }
      
      move(verticalDiff, lateralDiff) {
        let newPixels = [];
        for (var oldPixel of this.pixels) {
          let newPixel = canvas.getPixelByRowCol(
            oldPixel.row + verticalDiff,
            oldPixel.col + lateralDiff
          );
          if (!newPixel) return;
          newPixels.push(newPixel);
        }
        this.pixels = newPixels;
      }

      getPreviousPixel() {
        return this.pixels[this.pixels.length - 1];
      }

      hasPixel(id) {
        for (var pixel of this.pixels) {
          if (pixel.id() == id) return true;
        }
        if (this.firstPixel.id() == id) return true;
        return false;
      }

      erasePixel(id) {
        for (var i = 0; i < this.pixels.length; i++) {
          if (this.pixels[i].id() == id) {
            this.deletePixelByPosition(i);
          }   
        }
      }

      deletePixelByPosition(index) {
        this.pixels.splice(index, 1);
        this.values.splice(index, 1);
      }
      
      isSelected() {
        return this._isSelected;
      }

      select(pixel) {
        this._isSelected = true;
        this.pixels.forEach((pixel) => {
          pixel.renderSelected();
        });
      }

      unselect() {
        this._isSelected = false;
        this.pixels.forEach((pixel) => {
          pixel.renderNormal();
        });
      }

      empty() {
        this.pixels = [];
        this.values = [];
      }
    }
    

    function deleteLayersEvent() {
      layerManager.deleteSelectedLayers();

    }
    /////////////////////////
    ////// TEXT LAYER ///////
    /////////////////////////

    class TextLayer extends Layer {
      constructor(firstPixelId) {
        super(firstPixelId);
        this.cursor = 0;
        this.contents = [];
        this.layer = null;
      }

      static mouseDown(event) {
        let layer = new TextLayer(event.target.id);
      }

      static keyDown(event) {
        let layer = layerManager.getLayerByPixelId(layerManager.getSelectPixel().id());
        layer.writeChar(event.keyCode);
      }

      getLength() {
        return this.contents.length;
      }
      
      renderChars() {
        this.clear();
        let pixels = [];
        for (var i = 0; i < this.getLength(); i++) {
          let pixel = canvas.getPixelByRowCol(this.firstPixel.row, this.firstPixel.col + i);
          if (this.cursor == i + 1) pixel.renderCursor();
          if (!pixel) continue;
          this.draw(pixel, this.contents[i]);
        }
      }

      writeChar(key) {
        let char = String.fromCharCode(key);
        let length = this.getLength();
        switch (key) {
          case 38: // UP
          break;
          case 39: // RIGHT
            this.cursor = (this.cursor >= length)? length: this.cursor + 1;
          break;
          case 40: // DOWN
          break;
          case 37: // LEFT
            this.cursor = (this.cursor <= 0)? 0: this.cursor - 1;
          break;
          case 13: // ENTER
          break;
          case 8: // BACKSPACE
            this.cursor = (this.cursor <= 0)? 0: this.cursor - 1;
            this.contents.splice(this.cursor, 1);
          break;
          default:
            this.contents.splice(this.cursor, 0, char);
            this.cursor++;
          break;
        }
        console.log(this.cursor);
        console.log(this.contents);
        this.renderChars();

      }
    }

    /////////////////////////
    ////// LINE LAYER ///////
    /////////////////////////

    class LineLayer extends Layer {

      static mouseDown(event) {
        let layer = new LineLayer(event.target.id);
      }

      static mouseOver(event) {
        let layer = layerManager.getLatestLayer();
        layer.drawLine(event.target.id);
      }

      drawLine(activePixelId) {
        this.empty();
        let activePixel = canvas.getPixelById(activePixelId);
        let verticalDiff = Math.abs(activePixel.row - this.firstPixel.row);
        let lateralDiff = Math.abs(activePixel.col - this.firstPixel.col);

        if (activePixel.isAbove(this.firstPixel) && verticalDiff > lateralDiff) {
            for(var row = this.firstPixel.row; row >= activePixel.row; row --) {
              this.draw(canvas.getPixelByRowCol(row, this.firstPixel.col), "|");
            }
        } else if (activePixel.isBelow(this.firstPixel) && verticalDiff > lateralDiff) {
            for(var row = this.firstPixel.row; row <= activePixel.row; row ++) {
              this.draw(canvas.getPixelByRowCol(row, this.firstPixel.col), "|");
            }
        } else if (activePixel.isLeft(this.firstPixel) && verticalDiff < lateralDiff) {
            for(var col = this.firstPixel.col; col >= activePixel.col; col --) {
              this.draw(canvas.getPixelByRowCol(this.firstPixel.row, col), "-");
            }
        } else if (activePixel.isRight(this.firstPixel) && verticalDiff < lateralDiff) {
            for(var col = this.firstPixel.col; col <= activePixel.col; col ++) {
              this.draw(canvas.getPixelByRowCol(this.firstPixel.row, col), "-");
            }
        }
        layerManager.refreshAll();
      } 

    }

    /////////////////////////
    ////// FREE LAYER ///////
    /////////////////////////

    class FreeLayer extends Layer {

      static mouseDown(event) {
        let layer = new FreeLayer(event.target.id);
      }

      static mouseOver(event) {
        let layer = layerManager.getLatestLayer();
        layer.drawFree(event.target.id);
      }

      drawFree(activePixelId) {
        let activePixel = canvas.getPixelById(activePixelId);
        this.draw(activePixel, "x");
      }
    }

    //////////////////////
    //// SQUARE LAYER ////
    //////////////////////

    class SquareLayer extends Layer {

    }

    
    ///////////////////
    ////// ERASE //////
    ///////////////////

    function erasingMouseUpEvent(event) {
    }

    function erasePixelEvent(event) {
      let activePixel = canvas.getPixelById(event.target.id);
      let layer = layerManager.getLayerByPixelId(activePixel.id());
      if (layer) layer.erasePixel(activePixel.id());
      activePixel.clear();
    }

    function eraseMouseDownEvent(event) {
      erasePixelEvent(event);
    }


    function erasingMouseOverEvent(event) {
      erasePixelEvent(event);
    }
    
    ////////////////
    //// SELECT ////
    ////////////////
    
    function selectMouseDownEvent(event) {
      let activePixel = canvas.getPixelById(event.target.id);
      let layer = layerManager.getLayerByPixelId(activePixel.id());
      let selectedLayers = layerManager.getSelectedLayers();

      // Unselect all if...
      // 1. clicked-off (no layer selected)
      // 2. Single select mode (not multi) and only one selected,
      //    (otherwise multi was used but not active, so we keep selection).
      // 3. Single select mode (not multi) and selected other layer
      if (!layer || (!modeMaster.has("multi") && (selectedLayers.length < 2 || !layer.isSelected()))) {
        layerManager.unselectAll();
        modeMaster.change("selected", "select");
      }

      if (layer) {
        layer.select();
        layerManager.setSelectPixel(activePixel);
        modeMaster.change("select", "selected");
        modeMaster.add("moving");
      }
    }

    function selectingMouseUpEvent(event) {
    }

    function selectingMouseOverEvent(event) {
      let activePixel = canvas.getPixelById(event.target.id);
      let lastPixelSelected = layerManager.getSelectPixel();
      let verticalDiff = activePixel.row - lastPixelSelected.row;
      let lateralDiff = activePixel.col - lastPixelSelected.col;
      layerManager.moveSelectedLayers(verticalDiff, lateralDiff);
      layerManager.setSelectPixel(activePixel);
    }

    function selectedArrowKeyDownEvent(event) {
      var verticalDiff = 0;
      var lateralDiff = 0;
      switch (event.keyCode) {
        case 38:
          verticalDiff = -1;
          break;
        case 39:
          lateralDiff = 1;
          break;
        case 40:
          verticalDiff = 1;
          break;
        case 37:
          lateralDiff = -1;
          break;
      }
      layerManager.moveSelectedLayers(verticalDiff, lateralDiff);
    }

    ////////////////
    //// EVENTS ////
    ////////////////

    const modeMaster = new ModeMaster();

    class EventInstruction {
      constructor(modeCondition, modeUpdate, callback=()=>{}) {
        this.callback = callback;
        this.condition = this.makeFunc(modeCondition);
        this.update = this.makeFunc(modeUpdate);
      }
      
      makeFunc(instruction) {
        return (instruction.length)? instruction[0].bind(modeMaster, ...instruction.slice(1)): () => {};
      }

      run(event) {
        if (this.condition()) {
          this.update();
          this.callback(event);
          console.log(modeMaster._modes);
          return true;
        }
      }
    }
    
    let documentEventKeyInstructions = {
      "keydown": {
        38: [ // UP
          new EventInstruction([modeMaster.has, "selected"], [], selectedArrowKeyDownEvent),
        ],                                                                        
        39: [ // RIGHT                                                            
          new EventInstruction([modeMaster.has, "selected"], [], selectedArrowKeyDownEvent),
        ],                                                                        
        40: [ // DOWN                                                             
          new EventInstruction([modeMaster.has, "selected"], [], selectedArrowKeyDownEvent),
        ],                                                                        
        37: [ // LEFT                                                             
          new EventInstruction([modeMaster.has, "selected"], [], selectedArrowKeyDownEvent),
        ],
        16: [ // SHIFT
          new EventInstruction([modeMaster.is, "select"], [modeMaster.add, "multi"]),
          new EventInstruction([modeMaster.is, "selected"], [modeMaster.add, "multi"])
        ],
        8: [ // BACKSPACE
          new EventInstruction([modeMaster.has, "selected"], [modeMaster.reset, "select"], deleteLayersEvent),
        ],
        46: [ // DELETE
          new EventInstruction([modeMaster.has, "selected"], [modeMaster.reset, "select"], deleteLayersEvent),
        ],
        "*": [
          new EventInstruction([modeMaster.is, "drawing", "text"], [], TextLayer.keyDown),
        ]
      },
      "keyup": {
        16: [
          new EventInstruction([modeMaster.has, "multi"], [modeMaster.remove, "multi"])
        ],
      }
    }
    let canvasEventInstructions = {
      "mousedown": [
        new EventInstruction([modeMaster.has, "draw", "text"],    [modeMaster.change, "draw", "drawing"], TextLayer.mouseDown),
        new EventInstruction([modeMaster.has, "draw", "line"],    [modeMaster.change, "draw", "drawing"], LineLayer.mouseDown),
        new EventInstruction([modeMaster.has, "draw", "free"],    [modeMaster.change, "draw", "drawing"], FreeLayer.mouseDown),
        new EventInstruction([modeMaster.is, "drawing", "text"], [modeMaster.reset, "select"]),
        new EventInstruction([modeMaster.is, "erase"],   [modeMaster.change, "erase", "erasing"], eraseMouseDownEvent),
        new EventInstruction([modeMaster.has, "select"],   [], selectMouseDownEvent),
        new EventInstruction([modeMaster.has, "selected"],   [], selectMouseDownEvent),
      ],
      "mouseup": [
        new EventInstruction([modeMaster.is, "drawing", "line"], [modeMaster.change, "drawing", "draw"]), 
        new EventInstruction([modeMaster.is, "drawing", "square"], [modeMaster.change, "drawing", "draw"]), 
        new EventInstruction([modeMaster.is, "drawing", "free"], [modeMaster.change, "drawing", "draw"]), 
        new EventInstruction([modeMaster.is, "erasing"],  [modeMaster.change, "erasing", "erase"], erasingMouseUpEvent),
        new EventInstruction([modeMaster.has, "moving"],   [modeMaster.remove, "moving"], selectingMouseUpEvent),
      ],
      "mouseover": [
        new EventInstruction([modeMaster.has, "drawing", "free"], [], FreeLayer.mouseOver),
        new EventInstruction([modeMaster.has, "drawing", "line"], [], LineLayer.mouseOver),
        new EventInstruction([modeMaster.is, "erasing"],  [], erasingMouseOverEvent),
        new EventInstruction([modeMaster.has, "moving"],  [], selectingMouseOverEvent),
      ],
    }


    ////////////////
    //// PIXEL /////
    ////////////////

    class Pixel {
      constructor(size, row, col) {
        this.row = row;
        this.col = col;
        this.size = size;
        this.defaultColor = "#000000";
        this.defaultBgColor = "transparent";
        this.defaultBorder = "none";
      }
      
      id() {
        return Pixel.makeId(this.row, this.col);
      }

      static makeId(row, col) {
        return `pixel-${row},${col}`
      }

      setValue(value) {
        this.element.innerHTML = value;
      }

      renderSelected() {
        this.setColor("blue");
      }

      renderCursor() {
        this.element.style.borderRight = "1px solid orange";
      }

      renderNormal() {
        this.setColor(this.defaultColor);
        this.setBgColor(this.defaultBgColor);
        this.element.style.border = "none";
      }

      setColor(color) {
        this.element.style.color = color;
      }

      setBgColor(color) {
        this.element.style.backgroundColor = color;
      }


      clear() {
        this.setValue(" ");
        this.renderNormal();
      }

      isAbove(pixel) {
        return this.row < pixel.row;
      }

      isBelow(pixel) {
        return this.row > pixel.row;
      }

      isLeft(pixel) {
        return this.col < pixel.col;
      }

      isRight(pixel) {
        return this.col > pixel.col;
      }

      render(parent) {
        this.element = document.createElement("div");
        this.element.className = "pixel";
        this.element.id = this.id();
        this.element.style.position = "absolute";
        this.renderNormal();
        //this.setBorder("1px solid black");
        this.element.style.marginLeft = `${this.col * this.size}px`;
        this.element.style.marginTop = `${this.row * this.size}px`;
        this.element.style.height = `${this.size}px`;
        this.element.style.width = `${this.size}px`;
        parent.appendChild(this.element);
      }
    }

    ////////////////
    //// CANVAS ////
    ////////////////

    class Canvas {
      constructor(rowCount, colCount, pixelSize) {
        this.rowCount = rowCount;
        this.colCount = colCount;
        this.pixelSize = pixelSize;
        this.pixels = {};
      }

      getPixelById(id) {
        return this.pixels[id];
      }

      getPixelByRowCol(row, col) {
        return this.getPixelById(Pixel.makeId(row, col));
      }
      
      clearPixels(pixels) {
        pixels.forEach((pixel) => pixel.clear());
      }

      clear() {
        for(var pixel in this.pixels) this.pixels[pixel].clear();
      }

      render() {
        this.element = document.getElementById("canvas");
        this.element.style.width  = `${this.colCount * this.pixelSize}px`;
        this.element.style.height = `${this.rowCount * this.pixelSize}px`;
        this.element.style.fontSize = `${this.pixelSize}px`;
        this.element.style.fontFamily = `monospace`;
        for (var row = 0; row < this.rowCount; row++) {
          for (var col = 0; col < this.colCount; col++) {
            let pixel = new Pixel(this.pixelSize, row, col);
            pixel.render(this.element);
            this.pixels[pixel.id()] = pixel;
          }
        }
        assignMouseEventInstructions(this.element, canvasEventInstructions);
      }
    }

    function assignMouseEventInstructions(element, instructions) {
      for (const [eventType, story] of Object.entries(instructions)) {
        element.addEventListener(eventType, (event) => {
          for (var eventInstruction of story) {
            if (eventInstruction.run(event)) return;
          }
        })
      }
    }
    function assignKeyEventInstructions(element, instructions) {
      ["keyup", "keydown"].forEach((eventType) => {
        element.addEventListener(eventType, (event) => {
          for (const [key, story] of Object.entries(instructions[eventType])) {
            if (key == event.keyCode || key == "*") {
              for (var eventInstruction of story) {
                if (eventInstruction.run(event)) return;
              }
            }
          }
        });
      });
    }
    
    function modeButtonPress(modes) {
      return (event) => {
        modeMaster.reset(...modes);
        layerManager.unselectAll();
        document.querySelectorAll("#menu button").forEach((button) => {
          button.style.backgroundColor = "green";
        })
        event.target.style.backgroundColor = "blue";
      }
    }
    function renderMenuModeButton(name, modes) {
      let button = document.createElement("button");
      button.innerHTML = name;
      button.addEventListener('mouseup', modeButtonPress(modes));
      menu.appendChild(button);
    }

    function renderMasterMenu() {
      renderMenuModeButton("Draw Square", ["draw", "square"]);
      renderMenuModeButton("Text", ["draw", "text"]);
      renderMenuModeButton("Draw Line", ["draw", "line"]);
      renderMenuModeButton("Draw Free", ["draw", "free"]);
      renderMenuModeButton("Erase Free", ["erase"]);
      renderMenuModeButton("Select", ["select"]);
    }

    renderMasterMenu();
    canvas = new Canvas(masterRowCount, masterColCount, pixelSize);
    canvas.render();
    assignKeyEventInstructions(document, documentEventKeyInstructions);
    </script>
  </body>
</html>
