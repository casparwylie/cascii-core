<script>
/*

*** TODO ***

FE  -
  - joints for tables shifted off a little
  - various todos
  - table rollback / happy doesn;t work with textlayers. override.
  - consider defaulting to select mode after draw
    - resize pixels should switch to select
  - mini success messages
  - resize improvements: resize by % to avoid reverse
  - file break up?
  - import - focus on DL base64 import/export
  - proper UI / config
    - dotted/lined/dashed
    - menu splitting
    - free layer options
    - themes
    - settings: unicode v ascii
  - export
  - intro / why ascii
  - manual page. shortcuts, etc.

BE -
  - save, share, manage, user, login google + github,  CRUD
  - guest auto save (refresh keeps)
  - plain text request / curl

BIG IDEAS:
   - ML for auto parsing imported diagrams
   - Testing - full web driver / record intergration testing

IMPROVEMENTS (arguably features):
  - deleting layers in groups, group doesn't recover on undo.
  - diamond resize bit odd with other layers.
  - joiner layer with arrow heads won't always show - zindex.
  - captures on every change instead of mouseup
  - improve diagonal lines
  - clever resize: text in boxes main issue
*/

var layerManager;
var eventManager;
var areaSelectManager;
var modeMaster;
var charManager;
var themeManager;
var bodyComponent;

var canvas;

const ArrowKeyGroup = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];

//////////////////
////// UTILS /////
//////////////////

function reportError(message) {
  console.log(message);
}

function debugError(message) {
  console.log(`[DEBUG]: ${message}`);
}

function roundHalf(value) {
  return parseInt(Math.round(value));
}

function roundUp(value) {
  return parseInt(Math.ceil(value));
}

function roundDown(value) {
  return parseInt(Math.floor(value));
}

function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function sum(arr) {
  return arr.reduce((a, b) => a + b, 0);
}

function keyGroup(...names) {
  return names.join(",");
}

///////////////////
////// THEMES /////
///////////////////

class Theme {

  static Color = {
    blue         : "#0394fc",
    darkBlue     : "#0069b5",
    darkestBlue  : "#1a3540",
    lightestBlue : "#baebff",
    red          : "#f52f2c",
    darkRed      : "#9e1910",
    black        : "black",
    white        : "white",
    none         : "transparent",
    pink         : "#ff78db",
    green        : "#49d65c",
    lightGreen   : "#bdffdb",
    orange       : "orange",
  }

  config = {
    bodyFgColor: Theme.Color.none,
    bodyBgColor: Theme.Color.none,
    bodyFont: "monospace",

    menuButtonBgColor: Theme.Color.black,
    menuButtonFgColor: Theme.Color.white,
    menuButtonSelectedBgColor: Theme.Color.blue,
    menuButtonClickBgColor: Theme.Color.blue,

    canvasBgColor: Theme.Color.none,

    pixelNormalBgColor: Theme.Color.none,
    pixelNormalFgColor: Theme.Color.white,
    pixelSelectedBgColor: Theme.Color.none,
    pixelSelectedFgColor: Theme.Color.darkBlue,
    pixelResizeBgColor: Theme.Color.red,
    pixelJointBgColor: Theme.Color.pink,
    pixelJointNearBgColor: Theme.Color.green,
    pixelCursorColor: Theme.Color.orange,

    areaSelectionBgColor: Theme.Color.blue,

    canvasFont: "monospace",
  }

  constructor(config) {
    for (let key in config) {
      this.config[key] = config[key];
    }
  }
}

class ThemeManager {

  defaultTheme = "darkTheme";

  themes = {
    darkTheme: new Theme(
      {
        bodyBgColor: Theme.Color.black,
        bodyFgColor: Theme.Color.white,
        menuButtonBgColor: Theme.Color.black,
        menuButtonFgColor: Theme.Color.white,

        pixelCursorColor: Theme.Color.white,
        pixelNormalFgColor: Theme.Color.white,
        pixelResizeBgColor: Theme.Color.blue,
        pixelJointNearBgColor: Theme.Color.pink,
        pixelJointBgColor: Theme.Color.green,
        areaSelectionBgColor: Theme.Color.darkestBlue,
      }
    ),
    lightTheme: new Theme(
      {
        bodyBgColor: Theme.Color.white,
        bodyFgColor: Theme.Color.black,
        menuButtonBgColor: Theme.Color.white,
        menuButtonFgColor: Theme.Color.black,

        pixelCursorColor: Theme.Color.black,
        pixelNormalFgColor: Theme.Color.black,
        pixelResizeBgColor: Theme.Color.blue,
        pixelJointNearBgColor: Theme.Color.pink,
        pixelJointBgColor: Theme.Color.green,

        areaSelectionBgColor: Theme.Color.lightestBlue,
      }
    ),
    consoleTheme: new Theme(
      {
        bodyBgColor: Theme.Color.black,
        bodyFgColor: Theme.Color.green,
        menuButtonBgColor: Theme.Color.black,
        menuButtonFgColor: Theme.Color.green,
        menuButtonSelectedBgColor: Theme.Color.darkRed,

        pixelSelectedFgColor: Theme.Color.lightGreen,
        pixelResizeBgColor: Theme.Color.lightGreen,
        pixelCursorColor: Theme.Color.green,
        pixelNormalFgColor: Theme.Color.green,
        pixelJointNearBgColor: Theme.Color.lightGreen,
        pixelJointBgColor: Theme.Color.red,

        areaSelectionBgColor: Theme.Color.darkRed,
      }
    ),
  }

  constructor() {
    this.setTheme(this.defaultTheme);
  }

  getTheme() {
    return this.currentTheme.config;
  }

  setTheme(theme) {
    this.currentTheme = this.themes[theme];
  }

  renderTheme() {
    layerManager.refresh(() => bodyComponent.renderTheme());
  }
}

//////////////////
////// MODES /////
//////////////////

class ModeMaster {

  layerModes = [
    // Primitive
    "square",
    "free",
    "free-line",
    "step-line",
    "switch-line",
    "text",
    "table",
    "diamond",

    // Dynamic
    "line",
    "line-based",
  ];

  lineBasedModes = [
    "table", //TODO: Table not working here (why but unwanted.)
    "square",
    "free-line",
    "step-line",
    "switch-line",
    "diamond",
  ];

  constructor() {
    this._modes = [];
    this.callbacks = [];
  }

  registerCallback(func) {
    this.callbacks.push(func);
  }

  modeChangedCallback() {
    for (var func of this.callbacks) func();
  }

  makeFunc(instruction) {
    // This just gives dispatchers a prettier notation...
    // e.g () => modeMaster.has("x", "y") becomes [modeMaster.has, "x", "y"]
    return (instruction.length)? instruction[0].bind(this, ...instruction.slice(1)): () => true;
  }

  change(beforeMode, afterMode) {
    let index = this._modes.indexOf(beforeMode);
    if (index == -1) return;
    this._modes[index] = afterMode;
    this.modeChangedCallback();
  }

  toggle(mode) {
    if (this.has(mode)) {
      this.remove(mode);
    } else {
      this.add(mode);
    }
  }

  remove(...modes) {
    modes.forEach((mode) => {
      let index = this._modes.indexOf(mode);
      if (index == -1) return;
      this._modes.splice(index, 1);
    });
    this.modeChangedCallback();
  }

  reset(...modes) {
    this._modes = modes;
    this.modeChangedCallback();
  }

  add(...modes) {
    modes = modes.filter(mode => !this.has(mode));
    this._modes = this._modes.concat(modes);
    this.modeChangedCallback();
  }

  has(...modes) {
    return modes.map((mode) => this._modes.includes(mode)).every(Boolean);
  }

  hasOr(...modes) {
    return modes.map((mode) => this._modes.includes(mode)).some(Boolean);
  }

  is(...modes) {
    return this._modes.toString() == modes.toString();
  }

  removeLayerModes() {
    this.layerModes.forEach(mode => this.remove(mode));
  }

  setSelectedLayerMode(name) {
    this.removeLayerModes();
    this.add(name);

    // Rules for dynamic layer modes
    if (name.includes("line")) this.add("line");
    if (this.lineBasedModes.includes(name)) this.add("line-based");
  }
}

////////////////
//// EVENTS ////
////////////////



class EventDef {
  constructor(modeCondition, modeUpdate, callback=()=>{}) {
    this.callback = callback;
    this.condition = modeMaster.makeFunc(modeCondition);
    this.update = modeMaster.makeFunc(modeUpdate);
  }

  run(event) {
    if (this.condition()) {
      this.update();
      this.callback(event);
      console.log(modeMaster._modes);
      return true;
    }
  }
}

class EventManager {
  MAP = {
    document: {
      keyEvents: {
        keypress: {
          "*": [
            new EventDef([modeMaster.has, "writing", "text"], [], TextLayer.keyDownEvent),
          ],
        },
        keydown: {
          [keyGroup(...ArrowKeyGroup)]: [
            new EventDef([modeMaster.has, "selected"],
                [], (event) => layerManager.selectedArrowKeyDownEvent(event.key)),
          ],
          [["Shift"]]: [
            new EventDef([],
                [modeMaster.add, "shift"])
          ],
          [keyGroup("Backspace", "Delete")]: [
            new EventDef([modeMaster.has, "selected"],
                [modeMaster.reset, "select"], () => layerManager.deleteLayersEvent()),
          ],
          [keyGroup("Escape")]: [
            new EventDef([modeMaster.hasOr, "writing", "selected"],
                [modeMaster.reset, "select"], () => layerManager.unselectAll()),
          ],
          [keyGroup("Backspace", "Delete", ...ArrowKeyGroup)]: [
            new EventDef([modeMaster.has, "writing", "text"],
                [], TextLayer.keyDownEvent),
          ],
          [keyGroup("Control")]: [
            new EventDef([],
                [modeMaster.add, "ctrl"]),
          ],
          [keyGroup("Z", "z")]: [
            new EventDef([modeMaster.has, "shift", "ctrl"],
                [], (event) => layerManager.redoEvent(event)),
          ],
          [keyGroup("z")]: [
            new EventDef([modeMaster.has, "ctrl"],
                [], (event) => layerManager.undoEvent(event)),
          ],
          [keyGroup("c")]: [
            new EventDef([modeMaster.has, "ctrl", "selected"],
                [], () => layerManager.copySelectedLayersEvent()),
          ],
          [keyGroup("a")]: [
            new EventDef([modeMaster.has, "ctrl"],
                [modeMaster.reset, "selected"], (event) => layerManager.selectAllEvent(event)),
          ],
          [keyGroup("g")]: [
            new EventDef([modeMaster.has, "selected"],
                [], () => layerManager.groupSelectedLayersEvent()),
          ],
        },
        keyup: {
          [keyGroup("Shift")]: [
            new EventDef([modeMaster.has, "shift"],
                [modeMaster.remove, "shift"]),
          ],
          [keyGroup("Control")]: [
            new EventDef([modeMaster.has, "ctrl"],
                [modeMaster.remove, "ctrl"]),
          ],
        }
      }
    },
    window: {
      mouseEvents: {
        mouseup: [
          new EventDef([modeMaster.has, "drawing"],
              [modeMaster.change, "drawing", "draw"], (event) => layerManager.tidyLayersEvent(event)),
          new EventDef([modeMaster.has, "erasing"],
              [modeMaster.change, "erasing", "erase"]),
          new EventDef([modeMaster.has, "moving"],
              [modeMaster.remove, "moving"], (event) => layerManager.tidyLayersEvent(event)),
          new EventDef([modeMaster.has, "area-selecting"],
              [modeMaster.remove, "area-selecting"], (event) => areaSelectManager.areaSelectingMouseUpEvent(event)),
          new EventDef([modeMaster.has, "resizing"],
              [modeMaster.remove, "resizing"], (event) => layerManager.tidyLayersEvent(event)),
        ],
      }
    },
    canvas: {
      mouseEvents: {
        mousedown: [
          new EventDef([modeMaster.has, "draw", "text"],
              [modeMaster.change, "draw", "writing"], TextLayer.drawMouseDownEvent),
          new EventDef([modeMaster.has, "draw", "free-line"],
              [modeMaster.change, "draw", "drawing"], FreeLineLayer.drawMouseDownEvent),
          new EventDef([modeMaster.has, "draw", "step-line"],
              [modeMaster.change, "draw", "drawing"], StepLineLayer.drawMouseDownEvent),
          new EventDef([modeMaster.has, "draw", "switch-line"],
              [modeMaster.change, "draw", "drawing"], SwitchLineLayer.drawMouseDownEvent),
          new EventDef([modeMaster.has, "draw", "free"],
              [modeMaster.change, "draw", "drawing"], FreeLayer.drawMouseDownEvent),
          new EventDef([modeMaster.has, "draw", "square"],
              [modeMaster.change, "draw", "drawing"], SquareLayer.drawMouseDownEvent),
          new EventDef([modeMaster.has, "draw", "diamond"],
              [modeMaster.change, "draw", "drawing"], DiamondLayer.drawMouseDownEvent),
          new EventDef([modeMaster.has, "draw", "table"],
              [modeMaster.change, "draw", "drawing"], TableLayer.drawMouseDownEvent),
          new EventDef([modeMaster.has, "writing", "text"],
              [], TextLayer.writingMouseDownEvent),
          new EventDef([modeMaster.has, "erase"],
              [modeMaster.change, "erase", "erasing"], (event) => layerManager.erasePixelEvent(event)),
          new EventDef([modeMaster.hasOr, "selected", "select"],
              [], Layer.selectMouseDownEvent),
        ],
        mouseover: [
          new EventDef([modeMaster.has, "draw", "line"], // Technically this should be for any joiner layer...
              [], BaseLineLayer.drawMouseOver),
          new EventDef([modeMaster.has, "drawing"],
              [], Layer.drawingMouseOverEvent),
          new EventDef([modeMaster.has, "erasing"],
              [], (event) => layerManager.erasePixelEvent(event)),
          new EventDef([modeMaster.has, "area-selecting"],
              [], (event) => areaSelectManager.areaSelectingMouseOverEvent(event)),
          new EventDef([modeMaster.has, "moving"],
              [], (event) => layerManager.movingMouseOverEvent(event)),
          new EventDef([modeMaster.has, "resizing"],
              [], (event) => layerManager.resizingMouseOverEvent(event)),
          new EventDef([modeMaster.hasOr, "selected", "select"],
              [], (event) => layerManager.selectMouseOverEvent(event)),
        ],
        dblclick: [
          new EventDef([modeMaster.has, "selected", "text"],
              [modeMaster.change, "selected", "writing"], TextLayer.selectedDoubleClickEvent),
          new EventDef([modeMaster.has, "writing"],
              [], TextLayer.selectedDoubleClickEvent),
        ]
      }
    }
  }

  assignMouseEventDefs(element, allDefs) {
    for (const [eventType, defs] of Object.entries(allDefs)) {
      element.addEventListener(eventType, (event) => {
        for (var def of defs) if (def.run(event)) return;
      })
    }
  }

  assignKeyEventDefs(element, defs) {
    Object.keys(defs).forEach((eventType) => {
      element.addEventListener(eventType, (event) => {
        // This maps apple Command key to Ctrl.
        var eventKey = event.key == "Meta"? "Control": event.key;
        for (var keys in defs[eventType]) {
          for (let key of keys.split(",")) {
            if (key == eventKey || key == "*") {
              for (var def of defs[eventType][keys]) {
                if (def.run(event)) return;
              }
            }
          };
        }
      });
    });
  }

  assignAll(namedElements) {
    for (const [elementName, eventGroups] of Object.entries(this.MAP)) {
      for (const [eventGroup, eventDefs] of Object.entries(eventGroups)) {
        switch (eventGroup) {
          case "mouseEvents":
            this.assignMouseEventDefs(namedElements[elementName], eventDefs);
          break;
          case "keyEvents":
            this.assignKeyEventDefs(namedElements[elementName], eventDefs);
          break;
        }
      }
    }
  }
}


class CharManager {

    // Useful: https://www.w3.org/TR/xml-entity-names/025.html
    charset = {

      // Dotted lines
      "•": ["dotted", "line", "vertical", "lateral", "corner", "unicode"],
      ".": ["dotted", "line", "vertical", "lateral", "corner", "ascii"],

      // Solid lines
      "━": ["solid-bold", "line", "lateral", "unicode"],
      "┃": ["solid-bold", "line", "vertical", "unicode"],
      "─": ["solid-thin", "line", "lateral", "unicode"],
      "│": ["solid-thin", "line", "vertical", "unicode"],
      "|": ["solid-thin", "solid-bold", "line", "vertical", "ascii"],
      "\\": ["solid-thin", "solid-bold", "diag-back", "line", "unicode", "ascii"],
      "/": ["solid-thin", "solid-bold", "diag-forward", "line", "unicode", "ascii"],

      // Dashed lines
      "¦": ["dashed", "line", "vertical", "unicode"],
      "'": ["dashed", "line", "vertical", "ascii"],
      "-": ["dashed", "solid-bold", "solid-thin", "line", "lateral", "ascii", "unicode"],

      // Arrows
      "^": ["arrow", "up", "ascii"],
      ">": ["arrow", "right", "ascii"],
      "<": ["arrow", "left", "ascii"],
      "v": ["arrow", "down", "ascii"],
      "▲": ["arrow", "up", "unicode"],
      "▶": ["arrow", "right", "unicode"],
      "◀": ["arrow", "left", "unicode"],
      "▼": ["arrow", "down", "unicode"],

      // Corners
      "┏": ["corner", "solid-bold", "top-left", "unicode"],
      "┓": ["corner", "solid-bold", "top-right", "unicode"],
      "┗": ["corner", "solid-bold", "bottom-left", "unicode"],
      "┛": ["corner", "solid-bold", "bottom-right", "unicode"],

      "┌": ["corner", "solid-thin", "top-left", "unicode"],
      "┐": ["corner", "solid-thin", "top-right", "unicode"],
      "└": ["corner", "solid-thin", "bottom-left", "unicode"],
      "┘": ["corner", "solid-thin", "bottom-right", "unicode"],

      "+": [
        "corner", "solid-bold", "solid-thin", "dashed",
        "ascii", "unicode", "top-left", "top-right",
        "bottom-left", "bottom-right", "generic"
      ],

      // Misc
      "x": ["free"],
    }

    constructor() {
      this.charsetForm = "unicode"; // Default to unicode
    }

    getBestChar(...description) {
      var lastMatches = -1;
      var lastChar = null;
      for (let character in this.charset) {
        let tags = this.charset[character];
        let matches = tags.filter(tag => description.includes(tag)).length;
        if (matches > lastMatches) {
          lastMatches = matches;
          lastChar = character;
        }
      }
      return lastChar;
    }

    getCharset() {
      return this.charsetForm;
    }

    setCharset(form) {
      this.charsetForm = form;
    }

    getDiagBackLine(lineForm) {
      return this.getBestChar("diag-back", "line", lineForm, this.getCharset());
    }

    getDiagForwardLine(lineForm) {
      return this.getBestChar("diag-forward", "line", lineForm, this.getCharset());
    }

    getVerticalLine(lineForm) {
      return this.getBestChar("vertical", "line", lineForm, this.getCharset());
    }

    getLateralLine(lineForm) {
      return this.getBestChar("lateral", "line", lineForm, this.getCharset());
    }

    getCorner(lineForm, position) {
      return this.getBestChar("corner", position, lineForm, this.getCharset());
    }

    getArrow (direction) {
      return this.getBestChar("arrow", direction, this.getCharset());
    }

    getFree() {
      return this.getBestChar("free");
    }
}


////////////////////
////// LAYERS //////
////////////////////


class GroupManager {
  constructor() {
    this.layerGroups = [];
    this.layerGroupHistory = [];
  }

  capture() {
    this.layerGroupHistory.unshift(structuredClone(this.layerGroups));
  }

  jumpHistory(cursor) {
    this.layerGroups = this.layerGroupHistory[cursor];
  }

  findGroupsFromLayers(layers) {
    /*
      Find groups which are fully included in the provided layers.
      E.g
      Groups = [[1, 2, 3], [5, 6], [4, 5], [1, 2]]
      layers = [1, 2, 3, 4]
        => [[1, 2, 3], [1, 2]]
    */

    // This means, somehow, we are looking for groups with layers
    // that have been removed.
    if (!layers.every(Boolean)) return [];

    var foundGroups = [];
    let layerIds = layers.map(layer => layer.id);
    for (var groupLayerIds of this.layerGroups) {
      if (groupLayerIds.map(layerId => layerIds.includes(layerId)).every(Boolean)) {
        foundGroups.push(groupLayerIds);
      }
    }
    return foundGroups;
  }

  ungroupLayers(layers) {
    let groups = this.findGroupsFromLayers(layers).map(group => group.toString());
    this.layerGroups = this.layerGroups.filter(group => !groups.includes(group.toString()));
  }

  groupLayers(layers) {
    this.layerGroups.push(layers.map(layer => layer.id));
  }

  getSiblingLayerIds(memberLayer) {
    var layerIds = [];
    for (var group of this.layerGroups) {
      if (group.includes(memberLayer.id)) layerIds = layerIds.concat(group);
    }
    return layerIds;
  }

  tidy(layers) {
    var index = 0;
    for (var layerGroup of this.layerGroups) {
      this.layerGroups[index] = layerGroup.filter(layerId => !layers.includes(layerId));
      index ++;
    }
    // Tidy empty / one layer groups
    this.layerGroups = this.layerGroups.filter(group => group.length > 1);
  }
}


class AreaSelectManager {
  constructor() {
    this.areaSelectionPixels = [];
  }

  clearAreaSelection() {
    this.areaSelectionPixels.forEach(pixel => pixel.renderNormal());
    this.areaSelectionPixels = [];
  }

  areaSelectingMouseUpEvent(event) {
    this.clearAreaSelection();
    // Re-render selected layers having just cleared pixels.
    layerManager.getSelectedLayers().forEach(layer => layer.renderSelected());
  }

  areaSelectingMouseOverEvent(event) {
    this.clearAreaSelection();
    let firstPixel = layerManager.getSelectPixel();

    let activePixel = canvas.getPixelById(event.target.id);
    let lateralDiff = activePixel.col - firstPixel.col;
    let verticalDiff = activePixel.row - firstPixel.row;
    let total = Math.abs(lateralDiff * verticalDiff)

    var drawRow = firstPixel.row;
    var drawCol = firstPixel.col;
    for (var row = 0; row <= Math.abs(verticalDiff); row ++) {
      for (var col = 0; col <= Math.abs(lateralDiff); col ++) {
        let pixel = canvas.getPixelByRowCol(parseInt(drawRow), parseInt(drawCol));
        this.areaSelectionPixels.push(pixel);
        drawCol += lateralDiff / Math.abs(lateralDiff);
      }
      drawRow += verticalDiff / Math.abs(verticalDiff);
      drawCol = firstPixel.col;
    }

    this.selectLayersInAreaSelection();
    this.areaSelectionPixels.forEach(pixel => pixel.renderAreaSelected());
  }

  selectLayersInAreaSelection() {
    let layersToSelect = [];
    for (var layer of layerManager.layers) {
      let layerPixelIds = layer.pixels.map(pixel => pixel.id());
      let selectedPixelIds = this.areaSelectionPixels.map(pixel => pixel.id());
      if (layerPixelIds.filter(pixel => !selectedPixelIds.includes(pixel)).length) {
        if (layer.isSelected()) {
          layer.unselect();
        }
      } else {
        layersToSelect.push(layer);
      }
    }

    if (layersToSelect.length) modeMaster.change("select", "selected");
    for (let layer of layersToSelect) {
      layer.select();
      layerManager.selectGroupsByMemberLayer(layer);
    }
  }
}

class LayerManager {
  constructor() {
    this.layers = [];
    this.selectedPixel = null;
    this.layerHistory = [[]];
    this.historyCursor = 0;
    this.editingTextLayer = null;
    this.groupManager = new GroupManager();
  }

  add(layer) {
    this.layers.unshift(layer);
  }

  addSecond(layer) {
    this.layers.splice(1, 0, layer);
  }

  getLatestLayer() {
    return this.layers[0];
  }

  hasLayer(layerId) {
    return this.layers.map(layer => layer.id).includes(layerId);
  }

  getLayerById(layerId) {
    for (var layer of this.layers) {
      if (layer.id == layerId) return layer;
    }
  }

  getLayerByPixelId(id) {
    // Descending (reversed)
    for (var layer of this.getLayersOrderedByZindex().reverse()) {
      if (layer.hasPixel(id)) return layer;
    }
  }

  getSelectedLayers() {
    return this.layers.filter((layer) => layer.isSelected());
  }

  deleteSelectedLayers() {
    this.getSelectedLayers().forEach((layer) => layer.empty());
    this.tidyLayers();
  }

  selectGroupsByMemberLayer(memberLayer) {
    let siblingLayerIds = this.groupManager.getSiblingLayerIds(memberLayer);
    siblingLayerIds.forEach(layerId => this.getLayerById(layerId).select());
  }


  undo() {
    let limit = this.layerHistory.length - 1;
    this.historyCursor = (this.historyCursor < limit)? this.historyCursor + 1: limit;
    // Copy historic layers to avoid mutating them now that they're current.
    // Past will otherwise show as present...
    this.layers = this.copyReplaceLayers(this.layerHistory[this.historyCursor]);
    this.groupManager.jumpHistory(this.historyCursor);
  }

  redo() {
    this.historyCursor = (this.historyCursor > 0)? this.historyCursor - 1: 0;
    // Copy historic layers to avoid mutating them now that they're current.
    // Past will otherwise show as present...
    this.layers = this.copyReplaceLayers(this.layerHistory[this.historyCursor]);
    this.groupManager.jumpHistory(this.historyCursor);
  }

  copyReplaceLayers(layers) {
    return layers.map(layer => layer.copy(true));
  }

  copyAndRenderSelectedLayers() {
    // Copy layers and create a lookup for old to new. This can be used
    // by various functions to update new layers with appropriate relationships
    // and states (given those of old layers).
    let layerLookup = {};
    let layersToCopy = this.getSelectedLayers();
    for (var layer of layersToCopy) layerLookup[layer.id] = {old: layer, new: layer.copyAndRender()};
    this.moveLayersToAvailableSpace(Object.values(layerLookup).map(oldNewLayer => oldNewLayer.new));

    this.repointJointsForCopiedLayers(layerLookup);
    this.regroupForCopiedLayers(layerLookup);
    this.repointTableTextLayers(layerLookup);
  }

  repointTableTextLayers(layerLookup) {
    // For tables, we must point text layer references to the newly copied text layers.
    // We also ensure new TextLayers point to their new table.
    for (let oldLayerId in layerLookup) {
      let oldLayer = layerLookup[oldLayerId].old;
      let newLayer = layerLookup[oldLayerId].new;
      if (oldLayer.name == "table") {
        for (let cellId in oldLayer.textLayers) {
          let oldTextLayerId = oldLayer.textLayers[cellId];

          // Find the new version of the TextLayer given the old TextLayer ID.
          let newTextLayer = layerLookup[oldTextLayerId].new;

          // Give the new TextLayer it's new table reference.
          newTextLayer.tableId = newLayer.id;

          // Give the TableLayer at the corresponding cell it's new TextLayer reference.
          newLayer.textLayers[cellId] = newTextLayer.id;
        }
      }
    }
  }

  regroupForCopiedLayers(layerLookup) {
    // This groups the newly copied layers which were grouped before being copied.
    let layersToCopy = Object.values(layerLookup).map(oldNewLayer => oldNewLayer.old);
    let groupsToCopy = this.groupManager.findGroupsFromLayers(layersToCopy);
    for (var group of groupsToCopy) {
      var newGroup = group.map(layerId => layerLookup[layerId].new);
      this.groupManager.groupLayers(newGroup);
    }
    this.capture();
  }

  repointJointsForCopiedLayers(layerLookup) {
    // This goes through joints of old layers and updates
    // the joint layers to the newly copied joints if they
    // were included in the copied selection / are in the lookup.
    for (var oldLayerId in layerLookup) {
      let oldNewLayer = layerLookup[oldLayerId];
      for (var joint of oldNewLayer.old.joints) {

        // Find the new version of the joint layer given the old layer ID.
        let jointOldNewLayer = layerLookup[joint.layerId];

        if (jointOldNewLayer) {
          let newJoint = structuredClone(joint);
          newJoint.layerId = jointOldNewLayer.new.id;
          oldNewLayer.new.joints.push(newJoint);
        }
      }
    }
  }

  getNearOverlappingCount(subjectLayer, withNames) {
    /*
    This counts how many pixels from other layers are near
    or overlapping the subjectLayer. withNames can also
    be provided to only worry about specific layer types
    being near/overlapping. This is mainly used to make decisions
    based on how busy a space is.
    */
    var count = 0;
    for (let layer of this.layers) {
      if (withNames && withNames.includes(layer.name)) {
        count += layer.getNearOverlappingCount(subjectLayer);
      }
    }
    return count;
  }

  unselectAll() {
    this.layers.forEach(layer => layer.unselect());
    if (this.editingTextLayer) this.editingTextLayer.clearLastCursor();
    modeMaster.removeLayerModes();
  }

  switchModeCallback() {
    this.unselectAll();
    this.capture();
  }

  refresh(updateFunc) {
    /*
    var oldPixels = new Set();
    for (let layer of this.layers) {
      layer.pixels.forEach(pixel => oldPixels.add(pixel.id()));
    }
    updateFunc();
    var newPixels = new Set();
    for (let layer of this.layers) {
      layer.pixels.forEach(pixel => newPixels.add(pixel.id()));
    }
    this.renderAll();
    for(var pixel of oldPixels.difference(newPixels)) canvas.getPixelById(pixel).clear();
    */
    this.clearAll();
    updateFunc();
    this.renderAll();
  }

  tidyAllJoints(layersToDelete) {
    for (var layer of this.layers) {
      layer.joints = layer.joints.filter(joint => !layersToDelete.includes(joint.layerId));
      layer.tidyJoints();
    }
  }

  deleteLayers() {
    // Find layer IDs for dereferencing
    let layersToDelete = this.layers.filter(layer => !layer.pixels.length).map(layer => layer.id);

    // Delete empty layers
    this.layers = this.layers.filter(layer => !layersToDelete.includes(layer.id));

    // Delete references to empty layers in groups
    this.groupManager.tidy(layersToDelete);

    // Delete references to empty layers in layer joints
    this.tidyAllJoints(layersToDelete);
  }

  tidyLayers() {
    this.deleteLayers();
    this.capture();
  }

  clearAll() {
    this.layers.forEach((layer) => layer.clear());
  }

  getLayersOrderedByZindex() {
    // Ascending
    return this.layers.slice().sort((a, b) => a.zindex - b.zindex);
  }

  renderAll() {
    this.getLayersOrderedByZindex().forEach((layer) => layer.render());
  }

  layerPixelIsVisible(targetLayer, pixel, potentialJoinerLayers=[]) {
    // This checks if the value of a layer at a specific pixel is actually showing.
    // Otherwise, another layer using the same pixel is showing it's value in front.

    // For each layer, we also check it isn't a joiner to the targetLayer,
    // as that means it's probably only covering the joint pixel, which
    // we still want to show for other joiners. The edge case that it's a
    // joiner and doesn't properly hide other overlapped pixels is fine.

    // We also consider potential joiners, as they'd never actually join
    // if when attempting to connected (pixels match), the joiner layer was
    //  hiding the joint layer.
    let joinerLayers = this.getJoinersFromLayers([targetLayer]).concat(potentialJoinerLayers);

    // Descending
    for (let layer of this.getLayersOrderedByZindex().reverse()) {
      if (layer.hasPixel(pixel.id()) && !joinerLayers.includes(layer.id)) return layer.id == targetLayer.id;
    }
    return false;
  }

  empty() {
    this.layers = [];
    this.layerHistory = [];
  }

  capture() {
    this.historyCursor = 0;
    this.layerHistory.unshift(this.copyReplaceLayers(this.layers));
    this.groupManager.capture();
  }

  setSelectPixel(selectedPixel) {
    this.selectedPixel = selectedPixel;
  }

  getSelectPixel() {
    return this.selectedPixel;
  }

  atomicCommit(...jobs) {
    let committedLayers = [];
    for (let [layer, func] of jobs) {
      let committed = layer.commit(() => func(layer));
      if (!committed) {
        // If a the layer failed to move, then rollback the others that did move.
        committedLayers.forEach(layer => layer.rollback());
        return;
      }
      committedLayers.push(layer);
    }
    return true;
  }

  moveLayersAtomically(layers, verticalDiff, lateralDiff) {
    // If multiple layers are selected, they should all move
    // together to avoid breaking joints. If one layer hits
    // the canvas boundary, none should move. Hence, here
    // we ensure all moves are doable before keeping them.
    let success = this.atomicCommit(
      ...layers.map(layer => [layer, () => layer.move(verticalDiff, lateralDiff)])
    );
    if (!success) return;

    // If we are here, all layers have moved, so we can now resize
    // their joiner layers.

    // resizeSelectedJoinerLayers is false here because moving
    // them takes priority, and doing both is error prone. They will move
    // with their joint layer anyway, meaning the joint is persisted.
    // Otherwise, the joiner layer could unjoin because it's moved
    // twice, from the main move routine and the resize joiner layer routine.
    for (let layer of layers) layer.resizeJoinerLayers(false);
    return true;
  }


  moveSelectedLayers(verticalDiff, lateralDiff) {
    let selectedLayers = this.getSelectedLayers();
    this.refresh(() => this.moveLayersAtomically(selectedLayers, verticalDiff, lateralDiff));
    this.findJoints(selectedLayers);
  }

  moveLayersToAvailableSpace(layers) {
    let directions = [[1, 1], [-1, 1], [1, -1], [-1, -1]];
    for (let direction of directions) {
      if(this.moveLayersAtomically(layers, ...direction)) return true;
    }
    return false;
  }

  findJoints(changedLayers) {
    for (var layer of this.layers) {
      if (layer.isSelected()) continue;
      // Only joinable layers will return joint pixels here and therefore get probed.
      let keyedJoints = layer.getKeyedJointPixels();
      for (let jointKey in keyedJoints) {
        let jointPixel = keyedJoints[jointKey];
        var renderState = -1;
        for (var probingLayer of changedLayers) {
          if (probingLayer.id == layer.id) continue;
          // Only prober layers will look for joins (e.g lines).
          let state = probingLayer.probeJoint(layer, jointKey, jointPixel);
          if (state > renderState) renderState = state;
        }
        switch (renderState) {
          case 0:
            jointPixel.renderWasSelected();
          break;
          case 1:
            jointPixel.renderJointNear();
          break;
          case 2:
            jointPixel.renderJoint();
          break;
        }
      }
    }
  }

  getJoinersFromLayers(layers) {
    var layerIds = [];
    for (var layer of layers) {
      for (var joint of layer.joints) {
        layerIds.push(joint.layerId);
      }
    }
    return layerIds;
  }

  prepareLayerResizing(activePixel, leadLayer) {
    let resizePixelIndex = leadLayer.getResizePixelIndex(activePixel);
    if (resizePixelIndex == -1) return false;
    for (var resizeLayer of this.getSelectedLayers()) {
      if (!resizeLayer.isResizable()) continue;
      var resizePixel;
      if (resizeLayer.id == leadLayer.id) {
        // If the selected layer is the lead / currently selected layer
        // Then we already know the activePixel is the resize pixel.
        resizePixel = activePixel;
      } else if (resizeLayer.name == leadLayer.name && !leadLayer.name.includes("line")) {
        // If the lead layer is the same type as a selected layer,
        // we can use the same resize pixel position and resize the layer
        // in the same way for the best experience.

        // Lines are excluded because resize positions are subjective to the line
        // depending on where it was drawn from. Using the "nearest" logic is better.
        resizePixel = resizeLayer.getResizePixels()[resizePixelIndex];
      } else {
        // Otherwise, we find the layer's nearest resize pixel and
        // resize from there.
        resizePixel = resizeLayer.getNearestResizePixel(activePixel);
      }

      // The "to" pixel has been determined above depending on various rules.
      resizeLayer.setToPixel(resizePixel);

      // The resize "from" pixel is the opposite to the active "to" resize pixel
      // determined above. We set it here as the from pixel to mimic
      // the act of drawing it from the first pixel selected.
      let fromResizePixel = resizeLayer.getResizeOppositePixel(resizePixel);
      resizeLayer.setFromPixel(fromResizePixel);
    }
    return true;
  }

  renderCharset() {
    for (let layer of this.layers) layer.setAllChars(layer.lineForm);
  }

  // Generic multi-layer based events...

  resizingMouseOverEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    let layers = this.getSelectedLayers();
    this.refresh(() => this.resizeLayers(layers, activePixel));
    this.findJoints(layers);
  }

  resizeLayers(layers, activePixel) {
    let selectPixel = this.getSelectPixel();
    let verticalDiff = activePixel.row - selectPixel.row;
    let lateralDiff = activePixel.col - selectPixel.col;
    let joinerLayers = this.getJoinersFromLayers(layers);

    for (var layer of layers) {
      // Selected layers that are joiners to another selected layer should not
      // get resized, as the joint will handle moving it correctly.
      // Otherwise, the resize is at risk of unexpectly unjoining the layers
      // in question.
      if (joinerLayers.includes(layer.id)) continue;

      // If the layer belongs to a table, resizing should never happen
      // as resizing tables is used to add/remove columns, not move child
      // layers around.
      if (layer.hasTable()) continue;

      if (!layer.isResizable()) {
        // If the layer is not resizable, the best thing we can do is move it.
        if (layer.commit(() => layer.move(verticalDiff, lateralDiff))) layer.resizeJoinerLayers(true);
        continue;
      }
      /*
      layer.fromPixel: The "from" pixel for a specific layer (where it should be drawn from)
      layer.toPixel: The pixel the layer should draw to
      selectPixel: The previous activePixel to determine the diff with current activePixel.
                   This pixel starts as wherever the user first pressed.
      activePixel: The actual current pixel of the mouse.

      layer.fromPixel
          ._________
          *        |
          |        |
          |        |       *.. selectedPixel
          |        |        \
          |        |         \ .. vertical/lateralDiff
          |________*          \
                   .\           * .. activePixel
                   . \
                   .  \
                   .   * .. layer.toPixel + vertical/lateralDiff
                   .
                layer.toPixel

      With both of these determined, the layer can be resized.
      */

      // For this layer, the resize pixel is out of bounds.

      let toPixel = canvas.getPixelByRowCol(
        layer.toPixel.row + verticalDiff, layer.toPixel.col + lateralDiff
      );
      if (!toPixel) continue;

      // resizeSelectedJoinerLayers is true because layers are changing
      // and selected joiner layers should favour maintaining joints and resizing
      // that way, instead of resizing independently.
      layer.draw(toPixel.id(), true);
    }
    // Note we set selectPixel to activePixel so that the next iteration
    // can diff the new activePixel to this one.
    this.setSelectPixel(activePixel);
  }

  movingMouseOverEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    let lastPixelSelected = this.getSelectPixel();
    let verticalDiff = activePixel.row - lastPixelSelected.row;
    let lateralDiff = activePixel.col - lastPixelSelected.col;
    this.moveSelectedLayers(verticalDiff, lateralDiff);
    this.setSelectPixel(activePixel);
  }

  selectedArrowKeyDownEvent(key) {
    var verticalDiff = 0;
    var lateralDiff = 0;
    switch (key) {
      case "ArrowUp":
        verticalDiff = -1;
        break;
      case "ArrowRight":
        lateralDiff = 1;
        break;
      case "ArrowDown":
        verticalDiff = 1;
        break;
      case "ArrowLeft":
        lateralDiff = -1;
        break;
    }
    this.moveSelectedLayers(verticalDiff, lateralDiff);
    this.capture();
  }

  deleteLayersEvent(event) {
    this.refresh(() => this.deleteSelectedLayers());
  }

  copySelectedLayersEvent(event) {
    this.refresh(() => this.copyAndRenderSelectedLayers());
  }

  tidyLayersEvent(event) {
    this.tidyLayers();
  }

  selectMouseOverEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    for (var layer of this.layers) {
      // Avoid showing / unshowing resize pixels as they're
      // already permanently on for selected layers.
      if (layer.isSelected()) continue;
      for (var resizePixel of layer.getResizePixels()) {
        if (activePixel.isNear(resizePixel) && this.layerPixelIsVisible(layer, resizePixel)) {
          resizePixel.renderResizable();
        } else {
          resizePixel.renderWasSelected();
        }
      }
    }
  }

  undoEvent(event) {
    console.log("undo");
    this.refresh(() => this.undo());
  }

  redoEvent(event) {
    console.log("REDO!!");
    this.refresh(() => this.redo());
  }

  groupSelectedLayersEvent(event) {
    this.groupManager.groupLayers(this.getSelectedLayers());
  }

  ungroupSelectedLayersEvent(event) {
    this.groupManager.ungroupLayers(this.getSelectedLayers());
    layerManager.unselectAll();
  }

  redrawLinesEvent(direction) {
    for (var layer of this.getSelectedLayers()) {
      if (layer.name.includes("line")) {
        this.refresh(() => layer.toggleArrows(direction));
      }
    }
  }

  redrawLineBasedEvent(lineForm) {
    for (var layer of this.getSelectedLayers()) {
      if (modeMaster.lineBasedModes.includes(layer.name)) {
        this.refresh(() => layer.setAllChars(lineForm));
      }
    }
  }

  selectAllEvent(event) {
    event.preventDefault();
    this.layers.forEach(layer => layer.select());
  }

  erasePixelEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    let layer = this.getLayerByPixelId(activePixel.id());
    if (layer && layer.name != "free") return; // TODO show warning message
    if (layer) layer.erasePixel(activePixel.id());
    activePixel.clear();
  }

  getHighestZindex() {
    // This ensures the first ever layer is set to 0 given that
    // layers use this method during initialization to determine
    // the next zindex needed.
    if (this.layers.length == 0) return 0;

    return Math.max(...this.getZindexes());
  }

  getZindexes() {
    return this.layers.map(layer => layer.zindex);
  }

  getLowestZindex() {
    return Math.min(...this.layers.map(layer => layer.zindex));
  }

  bringForwardEvent(event) {
    let highestZindex = this.getHighestZindex();
    this.refresh(() => this.getSelectedLayers().forEach(layer =>  layer.zindex ++));
    this.tidyLayers();
  }

  sendBackwardsEvent(event) {
    let lowestZindex = this.getLowestZindex();
    this.refresh(() => this.getSelectedLayers().forEach(layer => layer.zindex --));
    this.tidyLayers();
  }

  bringToFrontEvent(event) {
    let highestZindex = this.getHighestZindex();
    this.refresh(() => this.getSelectedLayers().forEach(layer => layer.zindex = highestZindex + 1));
    this.tidyLayers();
  }

  sendToBackEvent(event) {
    let lowestZindex = this.getLowestZindex();
    this.refresh(() => this.getSelectedLayers().forEach(layer => layer.zindex = lowestZindex - 1));
    this.tidyLayers();
  }
}


class Layer {

  // TODO move these

  lineForm = "solid-thin";
  lateralChar = charManager.getLateralLine(this.lineForm);
  verticalChar = charManager.getVerticalLine(this.lineForm);
  diagBackChar = charManager.getDiagBackLine(this.lineForm);
  diagForwardChar = charManager.getDiagForwardLine(this.lineForm);
  cornerTopLeftChar = charManager.getCorner(this.lineForm, "top-left");
  cornerTopRightChar = charManager.getCorner(this.lineForm, "top-right");
  cornerBottomLeftChar = charManager.getCorner(this.lineForm, "bottom-left");
  cornerBottomRightChar = charManager.getCorner(this.lineForm, "bottom-right");
  cornerGenericChar = charManager.getCorner("generic");
  arrowUpChar    = charManager.getArrow("up");
  arrowDownChar  = charManager.getArrow("down");
  arrowLeftChar  = charManager.getArrow("left");
  arrowRightChar = charManager.getArrow("right");

  setAllChars(lineForm) {
    this.lineForm = lineForm;
    this.lateralChar = charManager.getLateralLine(this.lineForm);
    this.verticalChar = charManager.getVerticalLine(this.lineForm);
    this.diagBackChar = charManager.getDiagBackLine(this.lineForm);
    this.diagForwardChar = charManager.getDiagForwardLine(this.lineForm);
    this.cornerTopLeftChar = charManager.getCorner(this.lineForm, "top-left");
    this.cornerTopRightChar = charManager.getCorner(this.lineForm, "top-right");
    this.cornerBottomLeftChar = charManager.getCorner(this.lineForm, "bottom-left");
    this.cornerBottomRightChar = charManager.getCorner(this.lineForm, "bottom-right");
    this.arrowUpChar    = charManager.getArrow("up");
    this.arrowDownChar  = charManager.getArrow("down");
    this.arrowLeftChar  = charManager.getArrow("left");
    this.arrowRightChar = charManager.getArrow("right");

    this.redraw();
  }

  constructor(firstPixelId) {
    this.id = this.makeId();
    this.pixels = [];
    this.values = [];
    this.joints = [];
    this.stash();
    this.zindex = layerManager.getHighestZindex() + 1;
    this._isSelected = false;
    this.commitCount = 0;

    this.setToPixel(null) // This gets set when drawing begins;
    this.setFromPixel(canvas.getPixelById(firstPixelId));
  }

  makeId() {
    return randomInt(1, 100000).toString() + Date.now().toString();
  }

  static drawingMouseOverEvent(event) {
    let layer = layerManager.getLatestLayer();
    layerManager.refresh(() => layer.draw(event.target.id));
    layerManager.findJoints([layer]);
  }

  static selectMouseDownEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    let layer = layerManager.getLayerByPixelId(activePixel.id());
    let selectedLayers = layerManager.getSelectedLayers();

    layerManager.setSelectPixel(activePixel);
    // Unselect all if...
    // 1. clicked-off (no layer selected)
    // 2. Single select mode (not multi) and alternative layer picked.
    if (!layer || (!modeMaster.has("shift") && !layer.isSelected())) {
      layerManager.unselectAll();
      modeMaster.change("selected", "select");
    }
    if (!layer) {
      modeMaster.add("area-selecting");
      return;
    }
    layerManager.refresh(() => layer.select());
    modeMaster.change("select", "selected");
    modeMaster.setSelectedLayerMode(layer.name);
    modeMaster.add(
      layerManager.prepareLayerResizing(activePixel, layer)? "resizing": "moving"
    );
    if (!modeMaster.has("ctrl") || layer.name == "table" || layer.hasTable()) {
      // Select all members of a group if not bypassed by ctrl to select a grouped
      // layer.
      // This bypass shouldn't work for tables / table children to avoid undefined behaviour.
      layerManager.refresh(() => layerManager.selectGroupsByMemberLayer(layer));
    }
  }

  draw(activePixelId) {
    let committed = this.commit(() => this.drawLayer(activePixelId));
    if (committed && this.isJoinable()) this.resizeJoinerLayers(true);
  }

  isHappy() {
    // Anything that doesn't satisfy this condition will cause a rollback.
    // Currently, it just ensures pixels are valid, but it could be anything,
    // and extending this in specific layers is welcomed.
    return Boolean(
      this.pixels.every(Boolean)
      && this.getJointPixels().every(Boolean)
      && this.fromPixel
      && this.toPixel
    );
  }

  commit(...updateFuncs) {
    // Committing is used to trial ANY state changes of a layer.
    // The draw/move functions might recommend pixels that are out of bounds,
    // or in whatever way invalid. If the committed change (updateFuncs)
    // results in an 'unhappy' state, we rollback to the stashed state.

    // If a commit hasn't already started, we start one
    // by stashing the layer's current state.
    // Multiple commits can be applied, but only the first
    // between renders should be stashed.
    if (!this.isCommitting()) this.stash();

    this.beginCommit();

    // TODO move this to state bucket
    this.lastKeyedJointPixels = this.getKeyedJointPixels();

    // Attempted  the requested changes
    updateFuncs.forEach(func => func());

    let isHappy = this.isHappy();

    // If the changes have caused an upset, rollback to previous state.
    if (!isHappy) this.rollback();

    // Inform the requester of the success of the change.
    return isHappy;
  }

  isCommitting() {
    return this.commitMutex;
  }

  beginCommit() {
    this.commitMutex = true;
  }

  releaseCommit() {
    this.commitMutex = false;
  }

  stash() {
    // This is used to store / remember a layer's state
    // in case a layer becomes unhappy.
    this.stashed = [this.fromPixel, this.toPixel, this.pixels.map(p => p), this.values.map(v => v)];
  }

  rollback() {
    this.releaseCommit();
    [this.fromPixel, this.toPixel, this.pixels, this.values] = this.stashed;
  }

  redraw() {
    this.drawLayer(this.toPixel.id());
    layerManager.capture();
  }

  select() {
    this._isSelected = true;
    this.renderSelected();
    if (layerManager.getSelectedLayers().length > 1) modeMaster.add("multi-select");
  }

  unselect() {
    this._isSelected = false;
    this.renderUnselected();
    if (layerManager.getSelectedLayers().length <= 1) modeMaster.remove("multi-select");
  }

  setToPixel(pixel) {
    this.toPixel = pixel;
  }

  setFromPixel(pixel) {
    this.fromPixel = pixel;
  }

  getLastPixel() {
    return (this.pixels.length)? this.pixels[this.pixels.length - 1]: this.fromPixel;
  }

  getMiddlePixel() {
    return (this.pixels.length)? this.pixels[roundHalf(this.pixels.length / 2)]: this.fromPixel;
  }

  getFirstPixel() {
    return (this.pixels.length)? this.pixels[0]: this.fromPixel;
  }

  add(pixel, value) {
    if (!pixel) return;
    this.pixels.push(pixel);
    this.values.push(value);
    if (this.pixels.length != this.values.length) {
      debugError(`layer pixel/value mismatch: ${this.pixels} != ${this.values}`)
    }
  }

  getJointPixels() {
    return Object.values(this.getKeyedJointPixels());
  }

  // Implement if the shape can be joined to - a "joint" layer.
  // The keys should meaningful reflect the same part of a layer.
  // E.g the key "tl" should always represent the top left
  // corner pixel of a square.
  getKeyedJointPixels() {
    return {};
  }

  // Implement if the layer can join to another (e.g a line - a "joiner" layer)
  getJoinerPixels() {
    return [];
  }

  // Implement if the layer can be resized.
  // This will determine which pixels can be used to
  // resize a layer.
  getResizePixels() {
    return [];
  }

  // Implement if the layer can be resized.
  // This will determine which pixel to resize from,
  // given a resize point.
  getResizeOppositePixel() {
    return false;
  }

  hasTable() {
    return Boolean(this.tableId);
  }

  getTable() {
    return layerManager.getLayerById(this.tableId);
  }

  isResizable() {
    return Boolean(this.getResizePixels().length);
  }

  isJoinable() {
    return Boolean(this.getJointPixels().length);
  }

  getNearestResizePixel(pixel) {
    return pixel.isNearestTo(this.getResizePixels());
  }

  getResizePixelIndex(targetPixel) {
    return this.getResizePixels().map(pixel => pixel.id()).indexOf(targetPixel.id());
  }

  clear() {
    this.pixels.forEach((pixel) => pixel.clear());
  }

  tidyJoints() {
    // TODO consider requirement here
    let keyedJoints = this.getKeyedJointPixels();
    for (let joint of this.joints) {
      let layer = layerManager.getLayerById(joint.layerId);
      if (layer) {
        let jointPixel = keyedJoints[joint.jointKey];
        if (jointPixel) {
          let state = layer.probeJoint(this, joint.jointKey, jointPixel);
          if (state == 2) {
            continue;
          } else {
            // This should not happen.
            alert("had to unjoin dangling join: somehow disconnected");
          }
        } else {
          // This should not happen
          // - originally for tables only but they get unjoined now (when rows/cols are removed).
          alert("had to unjoin dangling join: joint pixel gone");
        }
      } else {
        // This should not happen because joints get deleted when layers do.
        alert("had to unjoin dangling join: join layer gone");
      }
      this.unjoin(joint.layerId, joint.jointKey);
    }
  }

  copy(replace=false) {
    let layerCopy = new this.constructor(this.fromPixel.id());
    if (replace) {
      // This is an exact copy, mainly used for capturing snapshots,
      // reverting history.
      // We only copy joints here, as other use cases need to manually
      // repoint joints to new layers.
      layerCopy.joints = this.joints.map(joint => structuredClone(joint));
      layerCopy.id = this.id;

      layerCopy.zindex = this.zindex;
    }
    layerCopy.setFromPixel(this.fromPixel);
    layerCopy.setToPixel(this.toPixel);
    layerCopy.pixels = this.pixels.map(pixel => pixel);
    layerCopy.values = this.values.map(value => value);
    return layerCopy;
  }

  copyAndRender() {
    let layerCopy = this.copy();
    layerManager.add(layerCopy);
    this.unselect();
    layerCopy.select();
    return layerCopy;
  }

  getNearOverlappingCount(targetLayer) {
    // Gets the amount of pixels which are common / the same (the amount of overlap).
    // Or, nearly the same by 1 pixel in any direction.
    var total = 0;
    if (targetLayer.id == this.id) return 0;
    let layerPixelIds = this.pixels.map(pixel => pixel.id());
    let directions = [[0, 0], [1, 1], [-1, 1], [1, -1], [-1, -1]];
    for (let direction of directions) {
      total += targetLayer.getMove(...direction).filter(
        pixel => pixel && layerPixelIds.includes(pixel.id())
      ).length
    }
    return total;
  }

  renderUnselected() {
    this.getJointPixels().forEach(pixel => pixel.renderWasSelected());
    this.pixels.forEach((pixel) => pixel.renderUnselected());
  }

  renderSelected() {
    this.getJointPixels().forEach(pixel => pixel.renderWasSelected());
    this.pixels.forEach(pixel => pixel.renderSelected());
    this.getResizePixels().forEach(pixel => pixel.renderResizable());
  }

  render() {
    this.releaseCommit();
    (this.isSelected()) ? this.renderSelected(): this.renderUnselected();
    for (var i = 0; i < this.pixels.length; i++) this.pixels[i].setValue(this.values[i]);
  }

  getMove(verticalDiff, lateralDiff) {
    return this.pixels.map(
      pixel => canvas.getPixelByRowCol(pixel.row + verticalDiff, pixel.col + lateralDiff)
    );
  }

  move(verticalDiff, lateralDiff) {
    this.pixels = this.getMove(verticalDiff, lateralDiff);
    // We must update the to/from pixels so that redraws happen at the new position.
    this.setFromPixel(
      canvas.getPixelByRowCol(this.fromPixel.row + verticalDiff, this.fromPixel.col + lateralDiff)
    );
    this.setToPixel(
      canvas.getPixelByRowCol(this.toPixel.row + verticalDiff, this.toPixel.col + lateralDiff)
    );
  }

  resizeJoinerLayers(resizeSelectedJoinerLayers=false) {
    // resizeSelectedJoinerLayers is used to determine what to do with a probe
    // joint layer if it's selected (as well as the main layer it's joint to).
    // Generally, it should resize as normal. However, if both layers are being
    // moved, moving should take precedence.

    // Only joint layers will have joints.
    for (let joint of this.joints) {
      let layer = layerManager.getLayerById(joint.layerId);

      // Depending on multi-select and the action being taken,
      // it effects if a selected probe join layer should be redrawn.
      // Moved layers don't need to, where as resized layers do.
      if (!layer || (!resizeSelectedJoinerLayers && layer.isSelected())) continue;

      let beforeJointPixel = this.lastKeyedJointPixels[joint.jointKey];
      let currentJointPixel = this.getKeyedJointPixels()[joint.jointKey];

      if (!currentJointPixel) {
        // This means the layer has changed in such a way that the joint pixel
        // is no longer available. It will get unjoined. This only should happen
        // with tables.
        debugError("joint pixel not found");
        this.unjoin(joint.layerId, joint.jointKey);
        return;
      }

      // Get the "from" pixel given the joint pixel before the main layer was moved.
      // We have to use the before JointPixel as the joint layer hasn't moved yet,
      // so that's where it's joining pixel still is.
      let fromPixel = layer.getResizeOppositePixel(beforeJointPixel);

      // The resize pixel may not get found if the main layer has
      // somehow moved without the jointed layer.
      if (!fromPixel) {
        alert("resize pixel not found");
        return;
      }
      layer.setFromPixel(fromPixel);
      layer.draw(currentJointPixel.id());
    }
  }

  probeJoint(layer, jointKey, jointPixel) {
      var state = 0;
      for (var probePixel of this.getJoinerPixels()) {
        if(!layerManager.layerPixelIsVisible(layer, jointPixel, [this.id])) continue;
        if (probePixel.isNear(jointPixel)) {
          state = 1;
          if (probePixel.is(jointPixel)) {
            state = 2;
            layer.join(this.id, jointKey);
            // Break to avoid unjoining in the following iteration.
            // Only one joiner/probe pixel of the same layer can join to the same jointPixel.
            break;
          }
        }
      layer.unjoin(this.id, jointKey);
    }
    return state
  }


  join(layerId, jointKey) {
    for (var joint of this.joints) {
      if (layerId == joint.layerId && jointKey == joint.jointKey) {
        return;
      }
    }
    this.joints.push({layerId: layerId, jointKey: jointKey});
  }

  unjoin(layerId, jointKey) {
    var index = 0;
    for (var joint of this.joints) {
      if (layerId == joint.layerId && jointKey == joint.jointKey) {
        this.joints.splice(index, 1);
        return;
      }
      index ++;
    }
  }

  hasPixel(id) {
    // We include joint pixels so that z-index visibility works nicely.
    // There is yet to be a reason not to do this.
    return (
      this.getPixelIndex(id) > -1 ||
      this.getJointPixels().map(pixel => pixel.id()).includes(id)
    );
  }

  getPixelIndex(id) {
    for (var i = 0; i < this.pixels.length; i++) {
      let pixel = this.pixels[i];
      if (pixel.id() == id) return i;
    }
    return -1;
  }

  erasePixel(id) {
    for (var i = 0; i < this.pixels.length; i++) {
      if (this.pixels[i].id() == id) this.deletePixelByPosition(i);
    }
  }

  deletePixelByPosition(index) {
    this.pixels.splice(index, 1);
    this.values.splice(index, 1);
  }

  isSelected() {
    return this._isSelected;
  }

  empty() {
    this.pixels = [];
    this.values = [];
  }

  getMinMaxRowsCols() {
    var [maxCol, minCol, maxRow, minRow] = [-1, -1, -1, -1];
    for (var pixel of this.pixels) {
      if (pixel.col > maxCol) maxCol = pixel.col;
      if (pixel.col < minCol || minCol == -1) minCol = pixel.col;
      if (pixel.row > maxRow) maxRow = pixel.row;
      if (pixel.row < minRow || minRow == -1) minRow = pixel.row;
    }
    return [maxCol, minCol, maxRow, minRow];
  }
}


/////////////////////////
////// TEXT LAYER ///////
/////////////////////////

class TextLayer extends Layer {

  name = "text";

  starterChar = ">";

  constructor(firstPixelId, tableId=null) {
    super(firstPixelId);
    this.contents = [];
    this.cursor = 0;
    this.tableId = tableId;
    if (tableId) this.zindex = layerManager.getLayerById(tableId).zindex;
    this.setToPixel(this.fromPixel);

    // TextLayer's don't use toPixels, but it's easier to just set it.
  }

  static selectedDoubleClickEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    let layer = layerManager.getLayerByPixelId(activePixel.id());
    layerManager.editingTextLayer = layer;
    layer.moveCursorToPixel(activePixel);
  }

  static drawMouseDownEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    if (!TextLayer.focusedOtherTextLayer(activePixel)) {
      let layer = new TextLayer(event.target.id);
      layerManager.add(layer);
      layerManager.editingTextLayer = layer;
      layer.setStarterChar();
      layerManager.refresh(() => layer.drawLayer());
      // Give an instant cursor position so it can be cleared
      // even if no writing was done.
      layer.lastCursorPixel = layer.fromPixel;
    }
  }

  static writingMouseDownEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    if (!TextLayer.focusedOtherTextLayer(activePixel)) {
      modeMaster.reset("select");
      layerManager.unselectAll();
    }
  }

  static keyDownEvent(event) {
    var layer = layerManager.editingTextLayer;
    if (layer && layer.name == "text") layerManager.refresh(() => layer.draw(event.key));
  }

  static focusedOtherTextLayer(activePixel) {
    layerManager.tidyLayers(); // Incase an empty text layer was left behind.
    let layer = layerManager.getLayerByPixelId(activePixel.id());

    // Unselect / remove cursor from any previous editing text layer.
    if (layerManager.editingTextLayer) {
      layerManager.editingTextLayer.clearLastCursor();
      layerManager.editingTextLayer.unselect();
    }

    // Setup the newly selected layer (might be the same).
    if (layer && layer.name == "text") {
      layer.moveCursorToPixel(activePixel);
      layerManager.editingTextLayer = layer;
      return true;
    }
    return false;
  }

  isHappy() {
    if (this.hasTable()) {
      // If the textLayer has a parent table, it's happiness
      // should also depend on the parent (it should rollback if the parent has
      // become unhappy)
      return layerManager.getLayerById(this.tableId).isHappy() && super.isHappy();
    }
    return super.isHappy();
  }

  clearLastCursor() {
    if (this.lastCursorPixel) this.lastCursorPixel.stopCursor();
  }

  copy(replace=false) {
    let layerCopy = super.copy(replace);
    layerCopy.contents = structuredClone(this.contents);
    if (replace) layerCopy.tableId = this.tableId;
    return layerCopy;
  }


  stash() {
    super.stash();
    this.moreStash = [this.cursor, this.contents? this.contents.map(c => c): []];
  }

  rollback() {
    // A little more is needed for TextLayer rollbacks,
    // to ensure the cursor is removed if the rollback
    // caused the layer to get deleted (0 pixels).
    super.rollback();
    [this.cursor, this.contents] = this.moreStash;
  }

  getKeyedJointPixels() {
    if (this.hasTable()) return {}; // The table itself will be joinable instead.
    let [maxCol, minCol, maxRow, minRow] = this.getMinMaxRowsCols();
    let halfwayRow = minRow + roundHalf((maxRow - minRow) / 2);
    let halfwayCol = minCol + roundHalf((maxCol - minCol) / 2);
    return {
      l: canvas.getPixelByRowCol(halfwayRow, minCol - 1), // Left
      r: canvas.getPixelByRowCol(halfwayRow, maxCol + 1), // Right
      t: canvas.getPixelByRowCol(minRow - 1, halfwayCol), // Top
      b: canvas.getPixelByRowCol(maxRow + 1, halfwayCol), // Bottom
    }
  }

  getLength() {
    return this.contents.length;
  }

  moveCursorToPixel(pixel) {
    this.clearLastCursor();
    let pixIndex = this.getPixelIndex(pixel.id());
    // Work out selected line using row diff from start.
    let line = pixel.row - this.fromPixel.row;
    // For each line, add a cursor position to make up for \n's.
    var cursor = pixIndex + line + 1;
    // If the user has selected the end, decrement the cursor once so that it
    // doesn't flip to the beginning.
    this.cursor = this.pixIndex == this.pixels.length - 1? cursor - 1: cursor;
    this.lastCursorPixel = pixel;
    pixel.startCursor();
  }

  getCursorLineOffset() {
    for (var i = this.cursor; i >= 0; i --) {
      if (i == 0) {
        return this.cursor - i;
      } else if (this.contents[i] == "\n") {
        if ((this.cursor - i) == 0) {
          continue;
        }
        return this.cursor - i - 1;
      }
    }
  }

  getCurrentLine() {
    var line = 0;
    for (var i = 0; i < this.getLength(); i++) {
      if (i == this.cursor || i + 1 == this.getLength()) return line;
      if (this.contents[i] == "\n") line ++;
    }
    return 0;
  }

  getLineStart(lineNum) {
    var line = 0;
    for (var i = 0; i < this.getLength(); i++) {
      if (line == lineNum) return i;
      if (this.contents[i] == "\n") line ++;
    }
    return i;
  }

  getLineLengths() {
    var lengths = [0];
    for (var i = 0; i < this.getLength(); i++) {
      if (this.contents[i] == "\n") {
        lengths.push(0);
      } else {
        lengths[lengths.length - 1] ++;
      }
    }
    return lengths;
  }

  getVerticalCursor(direction) {
    let currentLine = this.getCurrentLine();
    let lineLengths = this.getLineLengths();
    let cursorLineOffset = this.getCursorLineOffset();
    var nextLine;
    if (direction == "up") {
        nextLine = (currentLine > 0)? currentLine - 1: currentLine;
    } else {
        nextLine = (lineLengths.length - 1 > currentLine)? currentLine + 1: currentLine;
    }
    let col = (lineLengths[nextLine] > cursorLineOffset)? cursorLineOffset: lineLengths[nextLine];
    return this.getLineStart(nextLine) + col;
  }

  draw(key) {
    let committed = this.commit(() => this.writeChar(key), () => this.drawLayer());
    if (!committed) return;
    this.resizeJoinerLayers(true);
    this.updateParentTable();
  }

  updateParentTable() {
    if (this.hasTable()) this.getTable().drawRefreshSpacing(this.id);
  }

  writeChar(key) {
    let length = this.getLength();
    let currentLine = this.getCurrentLine();
    let lineLengths = this.getLineLengths();
    let cursorLineOffset = this.getCursorLineOffset();
    switch (key) {
      case "ArrowDown":
        this.cursor = this.getVerticalCursor("down");
      break;
      case "ArrowUp":
        this.cursor = this.getVerticalCursor("up");
      break;
      case "ArrowRight":
        this.cursor = (this.cursor >= length)? length: this.cursor + 1;
      break;
      case "ArrowLeft":
        this.cursor = (this.cursor <= 0)? 0: this.cursor - 1;
      break;
      case "Enter":
        if (this.contents.length == 0) return;
        this.contents.splice(this.cursor, 0, "\n");
        this.cursor++;
      break;
      case "Backspace":
      case "Delete":
        this.cursor = (this.cursor <= 0)? 0: this.cursor - 1;
        this.contents.splice(this.cursor, 1);
      break;
      default:
        this.contents.splice(this.cursor, 0, key);
        this.cursor++;
      break;
    }
    this.checkNoWrites();
  }

  drawLayer() {
    // Ensure the cursor is cleared incase pre-render clearing
    // didn't (if the cursor isn't on the layer's pixel).
    this.clearLastCursor();
    this.empty();
    let pixels = [];
    var [line, col] = [0, 0];
    for (var i = 0; i < this.getLength(); i++) {
      if (this.contents[i] == "\n") {
        line ++;
        col = 0;
      }
      let pixel = canvas.getPixelByRowCol(
        this.fromPixel.row + line,
        this.fromPixel.col + col
      );
      // Writing out of bounds. Stop the writing! Let a rollback take care of it.
      if (!pixel) return;
      if (this.cursor == i + 1) {
        this.lastCursorPixel = pixel;
        pixel.startCursor();
      }
      if (!pixel || this.contents[i] == "\n") continue;
      this.add(pixel, this.contents[i]);
      col ++;
    }
  }


  checkNoWrites() {
    // This is a quick way of not loosing a layer just because
    // a user backspaced all characters.
    let starterCharIndex = this.contents.indexOf(this.starterChar);
    if (this.noWrites && (starterCharIndex == 0)) {
      this.contents.splice(starterCharIndex, 1);
      this.cursor = 1;
      this.noWrites = false;
    }
    this.setStarterChar();
  }

  setStarterChar() {
    if (this.contents.length == 0) {
      this.contents = [this.starterChar];
      this.cursor = 1;
      this.noWrites = true;
    }
  }
}

/////////////////////////
////// LINE LAYER ///////
/////////////////////////

class BaseLineLayer extends Layer {

  constructor(firstPixelId) {
    super(firstPixelId);
    this.hasArrowLeft = false;
    this.hasArrowRight = false;
  }

  static drawMouseOver(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    for (var layer of layerManager.layers) {
      for (var jointPixel of layer.getJointPixels()) {
        if (activePixel.isNear(jointPixel) && layerManager.layerPixelIsVisible(layer, jointPixel)) {
          jointPixel.renderJointNear();
        } else {
          jointPixel.renderWasSelected();
        }
      }
    }
  }

  copy(replace=false) {
    let layerCopy = super.copy(replace);
    layerCopy.hasArrowLeft = this.hasArrowLeft;
    layerCopy.hasArrowRight = this.hasArrowRight;
    return layerCopy;
  }

  toggleArrows(direction) {
    if (direction == "left") this.hasArrowLeft = !this.hasArrowLeft;
    if (direction == "right") this.hasArrowRight = !this.hasArrowRight;
    this.redraw();
  }

  getEndPixels() {
    if (this.pixels.length > 0) {
      return [this.getFirstPixel(), this.getLastPixel()];
    }
    return [];
  }

  getResizePixels() {
    return this.getEndPixels();
  }

  getJoinerPixels() {
    return this.getEndPixels();
  }

  getResizeOppositePixel(pixel) {
    let resizePixels = this.getResizePixels();
    if (!resizePixels.length) return;
    if (pixel.is(resizePixels[0])) return resizePixels[1];
    if (pixel.is(resizePixels[1])) return resizePixels[0];
  }
}

class FreeLineLayer extends BaseLineLayer {

  name = "free-line"

  static drawMouseDownEvent(event) {
    let layer = new FreeLineLayer(event.target.id);
    layerManager.add(layer);
  }

  drawLayer(activePixelId) {
    this.setToPixel(canvas.getPixelById(activePixelId));
    let fromPixel = this.fromPixel;
    let toPixel = this.toPixel;
    let verticalDiff  = toPixel.row - fromPixel.row;
    let lateralDiff   = toPixel.col - fromPixel.col;

    var totalSteps   = Math.max(Math.abs(verticalDiff), Math.abs(lateralDiff));
    var verticalStep = verticalDiff / totalSteps;
    var lateralStep  = lateralDiff / totalSteps;

    var colDraw = fromPixel.col;
    var rowDraw = fromPixel.row;

    var value = "x";

    if (Math.abs(verticalStep) < 0.3){
      value = this.lateralChar;
    } else if (Math.abs(lateralStep) < 0.5) {
      value = this.verticalChar;
    } else if (toPixel.isLeft(fromPixel) && toPixel.isBelow(fromPixel)) {
      value = this.diagForwardChar;
    } else if (toPixel.isRight(fromPixel) && toPixel.isBelow(fromPixel)) {
      value = this.diagBackChar;
    } else if (toPixel.isLeft(fromPixel) && toPixel.isAbove(fromPixel)) {
      value = this.diagBackChar;
    } else if (toPixel.isRight(fromPixel) && toPixel.isAbove(fromPixel)) {
      value = this.diagForwardChar;
    }

    var startValue = value;
    var endValue = value;
    if (Math.abs(verticalDiff) > Math.abs(lateralDiff)) {
      if (toPixel.isAbove(fromPixel)) {
        endValue = (this.hasArrowLeft) ? this.arrowUpChar : value;
        startValue = (this.hasArrowRight) ? this.arrowDownChar : value;
      } else {
        endValue = (this.hasArrowLeft) ? this.arrowDownChar : value;
        startValue = (this.hasArrowRight) ? this.arrowUpChar : value;
      }
    } else{
      if (fromPixel.isLeft(toPixel)) {
        endValue = (this.hasArrowRight) ? this.arrowRightChar : value;
        startValue = (this.hasArrowLeft) ? this.arrowLeftChar : value;
      } else {
        endValue = (this.hasArrowLeft) ? this.arrowLeftChar : value;
        startValue = (this.hasArrowRight) ? this.arrowRightChar : value;
     }
    }

    this.empty();
    for (var i = 0; i <= totalSteps; i ++) {
      this.add(
        canvas.getPixelByRowCol(roundHalf(rowDraw), roundHalf(colDraw)),
        (i == 0)? startValue: value
      );
      rowDraw += verticalStep;
      colDraw += lateralStep;
    }
    this.add(this.getLastPixel(), endValue);
  }
}

class StepLineLayer extends BaseLineLayer {

  name = "step-line";

  static drawMouseDownEvent(event) {
    let layer = new StepLineLayer(event.target.id);
    layerManager.add(layer);
  }

  getKeyedJointPixels() {
    var lastRow = this.getFirstPixel().row;
    var index = 0;
    for (var pixel of this.pixels) {
      if (pixel.row != lastRow) {
        return {m: this.pixels[index - 1]}; // Middle
      }
      index ++;
    }
    return {m: this.getLastPixel()}; // Middle
  }

  drawLayer(activePixelId) {
    this.setToPixel(canvas.getPixelById(activePixelId));

    /* Try and draw the step line both ways e.g
        _____
        |                |
        |       Vs.   ___|

    and choose which ever is more visible depending on other layers overlapping.
    */
    let layersToAvoid = ["square", "table", "diamond"];
    this.drawFromTo(this.fromPixel, this.toPixel);
    let resultNorm = layerManager.getNearOverlappingCount(this, layersToAvoid);
    this.drawFromTo(this.toPixel, this.fromPixel);
    let resultFlip = layerManager.getNearOverlappingCount(this, layersToAvoid);
    if (resultNorm > resultFlip) {
      this.drawFromTo(this.toPixel, this.fromPixel);
    } else {
      this.drawFromTo(this.fromPixel, this.toPixel);
    }
  }

  drawFromTo(fromPixel, toPixel) {
    this.empty();
    let verticalDiff  = toPixel.row - fromPixel.row;
    let lateralDiff   = toPixel.col - fromPixel.col;
    let absVerticalDiff = Math.abs(verticalDiff);
    let absLateralDiff = Math.abs(lateralDiff);

    let [lateralArrowValue, verticalArrowValue] = this.getArrowChars(fromPixel, toPixel);
    var cornerChar = this.getCornerChar(fromPixel, toPixel);

    var drawCol = fromPixel.col;
    var drawRow = fromPixel.row;

    for (var i = 0; i < absLateralDiff; i ++) {
      this.add(
        canvas.getPixelByRowCol(fromPixel.row, drawCol),
        (i == 0)? lateralArrowValue: this.lateralChar
      );
      drawCol += lateralDiff / absLateralDiff;
    }

    if (verticalDiff && !lateralDiff) {
      cornerChar = this.verticalChar;
    } else if (!verticalDiff && lateralDiff) {
      cornerChar = this.lateralChar;
    }
    this.add(canvas.getPixelByRowCol(drawRow, drawCol), cornerChar);

    for (var i = 1; i <= absVerticalDiff; i ++) {
      drawRow += verticalDiff / absVerticalDiff;
      let value = (verticalDiff && lateralDiff)? cornerChar: this.verticalChar;
      this.add(
        canvas.getPixelByRowCol(drawRow, toPixel.col),
        (i == absVerticalDiff)? verticalArrowValue: this.verticalChar
      );
    }
  }

  getCornerChar(fromPixel, toPixel) {
    if (fromPixel.col < toPixel.col) {
      return fromPixel.row < toPixel.row? this.cornerTopRightChar:  this.cornerBottomRightChar;
    } else {
      return fromPixel.row < toPixel.row? this.cornerTopLeftChar:  this.cornerBottomLeftChar;
    }
    return "";
  }

  getArrowChars(fromPixel, toPixel) {
    var lateralArrowValue = this.lateralChar;
    var verticalArrowValue = this.verticalChar;
    if (fromPixel.col > toPixel.col) {
      // Vertical line is on left
      //    |
      //    |
      //    |____
      if (this.hasArrowRight) lateralArrowValue = this.arrowRightChar;
      if (this.hasArrowLeft) {
        verticalArrowValue = fromPixel.row > toPixel.row? this.arrowUpChar: this.arrowDownChar;
      }
    } else {
      // Vertical line is on left
      //       |
      //       |
      //    ___|
      if (this.hasArrowLeft) lateralArrowValue = this.arrowLeftChar;
      if (this.hasArrowRight) {
       verticalArrowValue = fromPixel.row > toPixel.row? this.arrowUpChar: this.arrowDownChar;
      }
    }
    return [lateralArrowValue, verticalArrowValue];
  }
}


class SwitchLineLayer extends BaseLineLayer {

  name = "switch-line";

  static drawMouseDownEvent(event) {
    let layer = new SwitchLineLayer(event.target.id);
    layerManager.add(layer);
  }

  getKeyedJointPixels() {
    // This finds the two corners of a switch line.
    let firstPixel = this.getFirstPixel();
    if(this.pixels.length < 2) return {0: firstPixel, 1: firstPixel};
    let joints = [];
    for (var index = 1; index < this.pixels.length - 1; index ++) {
      let pixel = this.pixels[index];
      let lastPixel = this.pixels[index - 1];
      let nextPixel = this.pixels[index + 1];
      if (
        (lastPixel.row == pixel.row && pixel.row != nextPixel.row) ||
        (lastPixel.col == pixel.col && pixel.col != nextPixel.col)
      ) {
        joints.push(pixel);
      }
    }

    // This means the line is straight, so we just join to the middle.
    if (joints.length != 2) {
      let middlePixel = this.getMiddlePixel();
      return {0: middlePixel, 1: middlePixel};
    }

    // This ensures the keys are the same for the meaningful locations,
    // regardless of a flip.
    let keyedJoints = {};
    if (joints[0].row > joints[1].row || joints[0].col > joints[1].col) {
      keyedJoints[0] = joints[0];
      keyedJoints[1] = joints[1];
    } else {
      keyedJoints[0] = joints[1];
      keyedJoints[1] = joints[0];
    }
    return keyedJoints;
  }

  drawLayer(activePixelId) {
    this.setToPixel(canvas.getPixelById(activePixelId));
    let fromPixel = this.fromPixel;
    let toPixel = this.toPixel;
    let verticalDiff  = toPixel.row - fromPixel.row;
    let lateralDiff   = toPixel.col - fromPixel.col;
    let absVerticalDiff = Math.abs(verticalDiff);
    let absLateralDiff = Math.abs(lateralDiff);

    /*
    Try and draw the switch line both ways e.g
        _____
        |                 |
        |             ____|
     ___|       Vs.   |



    and choose which ever is more visible depending on other layers overlapping.
    If there aren't notable overlaps, choose based on which direction is favoured.
    */
    let layersToAvoid = ["square", "table", "diamond"];
    this.drawVertical(fromPixel, toPixel);
    let verticalOverlap = layerManager.getNearOverlappingCount(this, layersToAvoid);
    this.drawLateral(fromPixel, toPixel);
    let lateralOverlap = layerManager.getNearOverlappingCount(this, layersToAvoid);
    if (verticalOverlap > lateralOverlap) {
      this.drawLateral(fromPixel, toPixel);
    } else if (lateralOverlap > verticalOverlap) {
      this.drawVertical(fromPixel, toPixel);
    } else if (absVerticalDiff > absLateralDiff) {
      this.drawVertical(fromPixel, toPixel);
    } else {
      this.drawLateral(fromPixel, toPixel);
    }
  }

  drawVertical(fromPixel, toPixel) {
    let [firstChar, lastChar] = this.getArrowCharsVertical(fromPixel, toPixel);
    let [firstCornerChar, lastCornerChar] = this.getCornerCharsVertical(fromPixel, toPixel);
    this.drawFromTo(
      fromPixel.col,
      fromPixel.row,
      toPixel.col,
      toPixel.row,
      [this.verticalChar, this.lateralChar, firstChar, lastChar, firstCornerChar, lastCornerChar],
      (a, b) => canvas.getPixelByRowCol(a, b),
    );
  }

  drawLateral(fromPixel, toPixel) {
    let [firstChar, lastChar] = this.getArrowCharsLateral(fromPixel, toPixel);
    let [firstCornerChar, lastCornerChar] = this.getCornerCharsLateral(fromPixel, toPixel);
    this.drawFromTo(
      fromPixel.row,
      fromPixel.col,
      toPixel.row,
      toPixel.col,
      [this.lateralChar, this.verticalChar, firstChar, lastChar, firstCornerChar, lastCornerChar],
      (a, b) => canvas.getPixelByRowCol(b, a),
    );
  }

  drawFromTo(fromPixelCol, fromPixelRow, toPixelCol, toPixelRow, chars, pixelFunc) {
    this.empty();
    let [mainChar, midChar, firstChar, lastChar, firstCornerChar, lastCornerChar] = chars;
    let diffA = toPixelRow - fromPixelRow;
    let diffB = toPixelCol - fromPixelCol;
    let absDiffA = Math.abs(diffA);
    let absDiffB = Math.abs(diffB);
    var drawCol = fromPixelCol;
    var drawRow = fromPixelRow;
    /*
     The following three loops represent each part of a
     switch layer in order.

     E.g

    "Lateral"
                           __________
                           |     3
                 __________| 2
                     1

    "Vertical"

                      | 1
                      |
                      |____
                        2  |
                           | 3
                           |

    Note, the logic is the same both ways, but to draw laterally,
    this method is called with cols and rows swapped.
    It's quite confusing but I've found it works wonderfully.
    */

    let halfwayA = roundHalf(absDiffA / 2);
    // First line
    for (var i = 0; i < halfwayA; i ++) {
      this.add(pixelFunc(drawRow, drawCol), (i == 0)? firstChar: mainChar);
      drawRow += diffA / absDiffA;
    }

    // If there is no middle line (no diff in a direction),
    // fill with a continuation pixel using mainChar.
    if (absDiffB == 0) {
      this.add(pixelFunc(drawRow, drawCol), mainChar);
    } else {
      // First corner
      this.add(pixelFunc(drawRow, drawCol), firstCornerChar);
      // Second line (middle)
      for (var i = 0; i < absDiffB - 1; i ++) {
        drawCol += diffB / absDiffB;
        this.add(pixelFunc(drawRow, drawCol), midChar);
      }
      drawCol += diffB / absDiffB;
      // Second corner
      this.add(pixelFunc(drawRow, drawCol), lastCornerChar);
    }
    // Third line. We use a while to ensure the line is drawn all the way.
    // Otherwise, using, using another "halfwayA" might be uneven due to rounding.
    while(drawRow != toPixelRow) {
      drawRow += diffA / absDiffA;
      this.add(pixelFunc(drawRow, toPixelCol), mainChar);
    }

    // This will replace the last char with arrows if needed.
    this.add(pixelFunc(drawRow, toPixelCol), lastChar);
  }

  getArrowCharsVertical(fromPixel, toPixel) {
    var firstChar = this.verticalChar;
    var lastChar = this.verticalChar;
    if (fromPixel.row < toPixel.row) {
      // Going down
      if (fromPixel.col < toPixel.col) {
        // Going right
        if (this.hasArrowRight) lastChar = this.arrowDownChar;
        if (this.hasArrowLeft) firstChar = this.arrowUpChar;
      } else {
        // Going left
        if (this.hasArrowLeft) lastChar = this.arrowDownChar;
        if (this.hasArrowRight) firstChar = this.arrowUpChar;
      }
    } else {
      // Going up
      if (fromPixel.col < toPixel.col) {
        // Going right
        if (this.hasArrowRight) lastChar = this.arrowUpChar;
        if (this.hasArrowLeft) firstChar = this.arrowDownChar;
      } else {
        // Going left
        if (this.hasArrowLeft) lastChar = this.arrowUpChar;
        if (this.hasArrowRight) firstChar = this.arrowDownChar;
      }
    }
    return [firstChar, lastChar];
  }

  getArrowCharsLateral(fromPixel, toPixel) {
    var firstChar = this.lateralChar;
    var lastChar = this.lateralChar;
    if (fromPixel.col < toPixel.col) {
      // Going right
      if (this.hasArrowLeft) firstChar = this.arrowLeftChar;
      if (this.hasArrowRight) lastChar = this.arrowRightChar;
    } else {
      // Going left
      if (this.hasArrowLeft) lastChar = this.arrowLeftChar;
      if (this.hasArrowRight) firstChar = this.arrowRightChar;
    }
    return [firstChar, lastChar];
  }

  getCornerCharsVertical(fromPixel, toPixel) {
    var firstChar = "";
    var lastChar = "";
    if (fromPixel.row < toPixel.row) {
      // Going down
      if (fromPixel.col < toPixel.col) {
        // Going right
        firstChar = this.cornerBottomLeftChar;
        lastChar = this.cornerTopRightChar;
      } else {
        // Going left
        firstChar = this.cornerBottomRightChar;
        lastChar = this.cornerTopLeftChar;
      }
    } else {
      // Going up
      if (fromPixel.col < toPixel.col) {
        // Going right
        firstChar = this.cornerTopLeftChar;
        lastChar = this.cornerBottomRightChar;
      } else {
        // Going left
        firstChar = this.cornerTopRightChar;
        lastChar = this.cornerBottomLeftChar;
      }
    }
    return [firstChar, lastChar];
  }

  getCornerCharsLateral(fromPixel, toPixel) {
    var firstChar = "";
    var lastChar = "";
    if (fromPixel.row < toPixel.row) {
      // Going down
      if (fromPixel.col < toPixel.col) {
        // Going right
        firstChar = this.cornerTopRightChar;
        lastChar = this.cornerBottomLeftChar;
      } else {
        // Going left
        firstChar = this.cornerTopLeftChar;
        lastChar = this.cornerBottomRightChar;
      }
    } else {
      // Going up
      if (fromPixel.col < toPixel.col) {
        // Going right
        firstChar = this.cornerBottomRightChar;
        lastChar = this.cornerTopLeftChar;
      } else {
        // Going left
        firstChar = this.cornerBottomLeftChar;
        lastChar = this.cornerTopRightChar;
      }
    }
    return [firstChar, lastChar];
  }

}

/////////////////////////
////// FREE LAYER ///////
/////////////////////////

class FreeLayer extends Layer {

  name = "free";


  freeChar = charManager.getFree();

  static drawMouseDownEvent(event) {
    let layer = new FreeLayer(event.target.id);
    layerManager.add(layer);
    layerManager.refresh(() => layer.draw(event.target.id));
  }

  drawLayer(activePixelId) {
    this.setToPixel(canvas.getPixelById(activePixelId));

    let verticalDiff = Math.abs(this.toPixel.row - this.fromPixel.row);
    let lateralDiff = Math.abs(this.toPixel.col - this.fromPixel.col);

    var value = "";
    if (verticalDiff > lateralDiff) {
      value = this.verticalChar;
    } else if (lateralDiff > verticalDiff) {
      value = this.lateralChar;
    }

    this.add(this.toPixel, value);
    this.setFromPixel(this.toPixel);
  }
}


//////////////////////
//// SQUARE LAYER ////
//////////////////////

class SquareBoundLayer extends Layer {

  getCornerPixels() {
    if (this.pixels.length == 0) {
      return [];
    }
    let [maxCol, minCol, maxRow, minRow] = this.getMinMaxRowsCols();
    return [
      canvas.getPixelByRowCol(minRow, minCol), // Top left
      canvas.getPixelByRowCol(minRow, maxCol), // Top right
      canvas.getPixelByRowCol(maxRow, maxCol), // Bottom right
      canvas.getPixelByRowCol(maxRow, minCol), // Bottom left
    ]
  }

  getResizePixels() {
    return this.getCornerPixels();
  }

  getResizeOppositePixel(targetPixel) {
    let corners = this.getResizePixels();
    let cornerMatchPixel = this.getResizePixelIndex(targetPixel);
    if (cornerMatchPixel == -1) return;
    let firstPixelIndex = cornerMatchPixel + 2;
    if (firstPixelIndex > 3) firstPixelIndex = firstPixelIndex - 4;
    return corners[firstPixelIndex];
  }
}

class DiamondLayer extends Layer {

  name = "diamond"

  static drawMouseDownEvent(event) {
    let layer = new DiamondLayer(event.target.id);
    layerManager.add(layer);
  }

  getKeyedJointPixels() {
    let firstPixel = this.getFirstPixel();
    if (this.pixels.length < 4) return {t: firstPixel, r: firstPixel, b: firstPixel, l: firstPixel};
    let [leftPixel, rightPixel, topPixel, bottomPixel] = this.getCornerPixels();
    return {
      t: canvas.getPixelByRowCol(topPixel.row - 1, topPixel.col),
      r: canvas.getPixelByRowCol(rightPixel.row, rightPixel.col + 1),
      b: canvas.getPixelByRowCol(bottomPixel.row + 1, topPixel.col),
      l: canvas.getPixelByRowCol(leftPixel.row, leftPixel.col - 1),
    };
  }

  getCornerPixels() {
    var minCol;
    var maxCol;
    var minRow;
    var maxRow;
    for (let pixel of this.pixels) {
      if (!minCol || pixel.col < minCol.col) minCol = pixel;
      if (!maxCol || pixel.col > maxCol.col) maxCol = pixel;
      if (!minRow || pixel.row < minRow.row) minRow = pixel;
      if (!maxRow || pixel.row > maxRow.row) maxRow = pixel;
    }
    return [minCol, maxCol, minRow, maxRow];
  }

  getResizePixels() {
    return this.getCornerPixels();
  }

  getResizeOppositePixel(targetPixel) {
    let [minCol, maxCol, minRow, maxRow] = this.getCornerPixels();
    return canvas.getPixelByRowCol(
      minRow.row + roundHalf((maxRow.row - minRow.row) / 2),
      minCol.col + roundHalf((maxCol.col - minCol.col) / 2),
    )
  }

  drawLayer(activePixelId) {
    this.setToPixel(canvas.getPixelById(activePixelId));
    let verticalDiff = Math.abs(this.toPixel.row - this.fromPixel.row);
    let lateralDiff = Math.abs(this.toPixel.col - this.fromPixel.col);
    var diff = verticalDiff > lateralDiff? verticalDiff: roundHalf(lateralDiff / 2);

    var middlePixel = this.fromPixel;

    let topPixel = canvas.getPixelByRowCol(middlePixel.row - diff, middlePixel.col);
    let leftPixel = canvas.getPixelByRowCol(middlePixel.row, middlePixel.col - (diff * 2));
    let rightPixel = canvas.getPixelByRowCol(middlePixel.row, middlePixel.col + (diff * 2));
    let bottomPixel = canvas.getPixelByRowCol(middlePixel.row + diff, middlePixel.col);

    let corners = [topPixel, leftPixel, rightPixel, bottomPixel];
    if (!corners.every(Boolean)) return;

    this.empty();
    corners.forEach(pixel => this.add(pixel, this.cornerGenericChar));
    for (var backCount = 1; backCount < diff; backCount ++) {
      this.add(
        canvas.getPixelByRowCol(rightPixel.row - backCount, rightPixel.col - (backCount * 2)),
        this.diagBackChar,
      );
      this.add(
        canvas.getPixelByRowCol(bottomPixel.row - backCount, bottomPixel.col - (backCount * 2)),
        this.diagBackChar,
      );
    }
    for (var fCount = 1; fCount < diff; fCount ++) {
      this.add(
        canvas.getPixelByRowCol(leftPixel.row - fCount, leftPixel.col + (fCount * 2)),
        this.diagForwardChar,
      );
      this.add(
        canvas.getPixelByRowCol(bottomPixel.row - fCount, bottomPixel.col + (fCount * 2)),
        this.diagForwardChar,
      );
    }
  }
}

class SquareLayer extends SquareBoundLayer {

  name = "square"

  static drawMouseDownEvent(event) {
    let layer = new SquareLayer(event.target.id);
    layerManager.add(layer);
  }

  getKeyedJointPixels() {
    let fp = this.getFirstPixel();
    if (this.pixels.length < 2) {
      return {tl: fp, tr: fp, br: fp, bl: fp, l: fp, r: fp, b: fp, t: fp};
    }
    let corners = this.getCornerPixels();
    let minRow = corners[0].row;
    let maxRow = corners[2].row;
    let minCol = corners[0].col;
    let maxCol = corners[2].col;
    let halfwayRow = parseInt((maxRow - minRow) / 2);
    let halfwayCol = parseInt((maxCol - minCol) / 2);
    return {
      tl: corners[0], // Top left
      tr: corners[1], // Top right
      br: corners[2], // Bottom right
      bl: corners[3], // Bottom left
      l: canvas.getPixelByRowCol(minRow + halfwayRow, minCol - 1), // Left
      r: canvas.getPixelByRowCol(minRow + halfwayRow, maxCol + 1), // Right
      b: canvas.getPixelByRowCol(maxRow + 1, minCol + halfwayCol), // Bottom
      t: canvas.getPixelByRowCol(minRow - 1, minCol + halfwayCol), // Top
    };
  }

  drawLayer(activePixelId) {
    this.setToPixel(canvas.getPixelById(activePixelId));
    let topLeftPixel = canvas.getPixelByRowCol(
      Math.min(this.toPixel.row, this.fromPixel.row),
      Math.min(this.toPixel.col, this.fromPixel.col),
    )
    let bottomRightPixel = canvas.getPixelByRowCol(
      Math.max(this.toPixel.row, this.fromPixel.row),
      Math.max(this.toPixel.col, this.fromPixel.col),
    )

    let verticalDiff = bottomRightPixel.row - topLeftPixel.row;
    let lateralDiff = bottomRightPixel.col - topLeftPixel.col;

    if (!verticalDiff || !lateralDiff) return;

    let absVerticalDiff = Math.abs(verticalDiff);
    let absLateralDiff = Math.abs(lateralDiff);
    var rowPos = topLeftPixel.row;
    var colPos = topLeftPixel.col;

    this.empty();

    // Draw corners
    this.add(canvas.getPixelByRowCol(rowPos, colPos), this.cornerTopLeftChar);
    console.log(this.cornerTopLeftChar);
    this.add(canvas.getPixelByRowCol(rowPos, bottomRightPixel.col), this.cornerTopRightChar);
    this.add(canvas.getPixelByRowCol(bottomRightPixel.row, colPos), this.cornerBottomLeftChar);
    this.add(canvas.getPixelByRowCol(bottomRightPixel.row, bottomRightPixel.col), this.cornerBottomRightChar);

    // Draw lines
    for(var row = 0; row < absVerticalDiff - 1; row ++) {
      rowPos += verticalDiff / absVerticalDiff;
      this.add(canvas.getPixelByRowCol(rowPos, topLeftPixel.col), this.verticalChar);
      this.add(canvas.getPixelByRowCol(rowPos, bottomRightPixel.col), this.verticalChar);
    }
    for(var col = 0; col < absLateralDiff - 1; col ++) {
      colPos += lateralDiff / absLateralDiff;
      this.add(canvas.getPixelByRowCol(topLeftPixel.row, colPos), this.lateralChar);
      this.add(canvas.getPixelByRowCol(bottomRightPixel.row, colPos), this.lateralChar);
    }
  }
}

/////////////////////
//// TABLE LAYER ////
/////////////////////


class TableLayer extends SquareBoundLayer {
  name = "table"

  constructor(firstPixelId) {
    super(firstPixelId);
    this.tblSizeLimit = 20; // TODO show warning message when hit limit
    this.textLayers = {};
    this.cellTextArchive = {};
    this.tblRows = 0;
    this.tblCols = 0;
    this.defaultCellContents = "text...";
    this.tblColDefaultWidth = this.defaultCellContents.length + 1; // 1 is added to account for the col line
    this.tblColWidths = {};
    this.tblRowHeights = {};
    this.tblRowDefaultHeight = 2;
  }

  static drawMouseDownEvent(event) {
    let layer = new TableLayer(event.target.id);
    layerManager.add(layer);
    layerManager.refresh(() => layer.draw(event.target.id));
  }
  stash() {
    super.stash(); // TODO STATE BUCKETS for export, copy, and stash.
    // TODO think mutation (though safe here). Also, special reason to stash widths/cols
    // as used by keyed joints pixels.
    this.moreStash = [
      structuredClone(this.textLayers),
      this.tblRows,
      this.tblCols,
      structuredClone(this.tblColWidths), structuredClone(this.tblRowHeights)
    ];
  }

  rollback() {
    super.rollback();
    [this.textLayers, this.tblRows, this.tblCols, this.tblColWidths, this.tblRowHeights] = this.moreStash;
  }

  copy(replace=false) {
    // Please read base implementation. This extension ensures
    // we also copy textLayers if it's a full replace copy.
    let layerCopy = super.copy(replace);
    if (replace) layerCopy.textLayers = structuredClone(this.textLayers);

    // Copy row and col counts so that refresh() works immediately for copied tables.
    layerCopy.tblRows = this.tblRows;
    layerCopy.tblCols = this.tblCols;
    layerCopy.tblRowHeights = this.tblRowHeights;
    layerCopy.tblColWidths = this.tblColWidths;
    return layerCopy;
  }

  getKeyedJointPixels() {
    let pixels = {};
    var corners = this.getCornerPixels();
    if (!corners.length) return {};
    let [topLeftPixel, topRightPixel, bottomRightPixel, bottomLeftPixel] = corners;
    var rowPos = topLeftPixel.row + 1;
    var index = 0;
    for (let row = 0; row < this.tblRows; row ++) {
      let height = this.getRowHeight(row);
      rowPos += height;
      pixels[`l-${index}`] = canvas.getPixelByRowCol(
        rowPos - roundHalf(height / 2), topLeftPixel.col - 1
      ); // Left
      pixels[`r-${index}`] = canvas.getPixelByRowCol(
        rowPos - roundHalf(height / 2), topRightPixel.col + 1
      ); // Right
      index ++;
    }
    var colPos = topLeftPixel.col + 1;
    var index = 0;
    for (let col = 0; col < this.tblCols; col ++) {
      let width = this.getColWidth(col);
      colPos += width;
      pixels[`t-${index}`] = canvas.getPixelByRowCol(
        topLeftPixel.row - 1, colPos - roundHalf(width / 2)
      ); // Top
      pixels[`b-${index}`] = canvas.getPixelByRowCol(
        bottomLeftPixel.row + 1, colPos - roundHalf(width / 2)
      ); // Bottom
      index ++;
    }
    return pixels;
  }

  getNewTblRows(verticalDiff) {
    // Showing/hiding a row depends on it's height, the direction of the mouse,
    // and the mouse travelling enough to justify show/hiding based on the row's height.
    // E.g, to hide a row, the mouse moves back by half it's height (or forward to show).
    let relVerticalDiff = verticalDiff - this.getTablePixelHeight();
    let belowRowHeight = this.getRowHeight(this.tblRows);
    let aboveRowHeight = this.getRowHeight(this.tblRows - 1);
    let nextRowHeight = relVerticalDiff > 0? belowRowHeight: aboveRowHeight;
    return Math.abs(this.tblRows + roundHalf(relVerticalDiff / nextRowHeight));
  }

  getNewTblCols(lateralDiff) {
    // Showing/hiding a column depends on it's height, the direction of the mouse,
    // and the mouse travelling enough to justify show/hiding based on the col's width.
    // E.g, to hide a column, the mouse moves back by half it's width (or forward to show).
    let relLateralDiff = lateralDiff - this.getTablePixelWidth();
    let belowColWidth = this.getColWidth(this.tblCols);
    let aboveColWidth = this.getColWidth(this.tblCols - 1);
    let nextColWidth = relLateralDiff > 0? belowColWidth: aboveColWidth;
    return Math.abs(this.tblCols + roundHalf(relLateralDiff / nextColWidth));
  }

  drawLayer(activePixelId) {
    this.setToPixel(canvas.getPixelById(activePixelId));
    let topLeftPixel = this.getTopLeftPixel();
    let bottomRightPixel = this.getBottomRightPixel();
    let newTblRows = this.getNewTblRows(bottomRightPixel.row - topLeftPixel.row);
    let newTblCols = this.getNewTblCols(bottomRightPixel.col - topLeftPixel.col);

    // Don't bother updating the table if no proper changes have been calculated.
    if (newTblRows == this.tblRows && newTblCols == this.tblCols) return;
    if (newTblCols == 0 || newTblRows == 0) return;
    // ...or if the size limit is hit...
    if (newTblRows >= this.tblSizeLimit || newTblCols >= this.tblSizeLimit) return;

    // This sequence does one draw of the whole table.
    // We start by setting new row/col properties,
    // which represent how many rows/cols are visible.
    this.tblRows = newTblRows;
    this.tblCols = newTblCols;

    // We ungroup the existing layers as a new group will be
    // needed since layers might get removed/added.
    this.ungroup();

    // The table layer itself get's drawn.
    this.drawFrame(topLeftPixel);

    // All layers that should no longer be visible are removed,
    // though their contents preserved.
    this.emptyTextLayers();

    // New rows/cols get their new layers added.
    this.addTextLayers(topLeftPixel);

    // Depending on the new location of rows/cols, we must
    // shuffle around layers so they stick to the correct cell.
    this.moveTextLayers(topLeftPixel);

    // Finally, group the updated set of layers.
    this.group();
  }

  redraw() {
    let topLeftPixel = this.getTopLeftPixel();
    this.drawFrame(topLeftPixel);
  }

  drawFrame(topLeftPixel) {
    this.empty();
    let tblHeight = this.getTablePixelHeight();
    let tblWidth = this.getTablePixelWidth();
    let fromRow = topLeftPixel.row;
    let fromCol = topLeftPixel.col;
    let toRow = fromRow + tblHeight;
    let toCol = fromCol + tblWidth;
    // Draw corners...
    this.add(canvas.getPixelByRowCol(fromRow, fromCol), this.cornerTopLeftChar);
    this.add(canvas.getPixelByRowCol(fromRow, toCol), this.cornerTopRightChar);
    this.add(canvas.getPixelByRowCol(toRow, fromCol), this.cornerBottomLeftChar);
    this.add(canvas.getPixelByRowCol(toRow, toCol), this.cornerBottomRightChar);

    // Draw row lines with spacing based on text..
    // -----------------
    //
    // -----------------
    // -----------------
    var row = fromRow;
    for (var tblRow = 0; tblRow <= this.tblRows; tblRow ++) {
      for (var col = fromCol + 1; col < toCol; col++) {
        this.add(canvas.getPixelByRowCol(row,  col), this.lateralChar);
      }
      row += this.getRowHeight(tblRow);
    }
    // Draw col lines with spacing based on text..
    // |      |   |    |
    // |      |   |    |
    // |      |   |    |
    var col = fromCol;
    for (var tblCol = 0; tblCol <= this.tblCols; tblCol ++) {
      for (var row = fromRow + 1; row < toRow; row ++) {
        this.add(canvas.getPixelByRowCol(row,  col), this.verticalChar);
      }
      col += this.getColWidth(tblCol);
    }
  }

  refreshSpacing(textLayerId) {
    let topLeftPixel = this.getTopLeftPixel();
    this.setNewTextSpacing(textLayerId);
    this.drawFrame(topLeftPixel);
    this.moveTextLayers(topLeftPixel);

    // The textLayer that has changed needs another chance to rollback
    // in case it's parent table has since become unhappy. Hence,
    // we carry out an empty commit.
    let textLayer = layerManager.getLayerById(textLayerId);
    textLayer.commit(() => {});
  }

  drawRefreshSpacing(textLayerId) {
    let committed = this.commit(() => this.refreshSpacing(textLayerId));
    if (committed) this.resizeJoinerLayers(true);
  }

  makeCellId(row, col) {
    return `${row},${col}`;
  }

  parseCellId(cellId) {
    return cellId.split(",")
  }

  ungroup() {
    // Ungroup all layers.
    let layers = this.getTextLayers().concat(this);
    // TODO explain how a table could loose a layer.
    // In fact, handle this case:
    // E.g ungroup table -> delete tlayers -> redraw
    if (!layers.every(Boolean)) return;
    layerManager.groupManager.ungroupLayers(layers);
  }

  group() {
    // Group all existing visible layers, and ensure the table is always selected together.
    let textLayers = this.getTextLayers();
    if (this.isSelected()) textLayers.forEach(layer => layer.select());
    layerManager.groupManager.groupLayers(textLayers.concat(this));
  }

  getBottomRightPixel() {
    return canvas.getPixelByRowCol(
      Math.max(this.toPixel.row, this.fromPixel.row),
      Math.max(this.toPixel.col, this.fromPixel.col),
    );
  }

  getTopLeftPixel() {
    return canvas.getPixelByRowCol(
      Math.min(this.toPixel.row, this.fromPixel.row),
      Math.min(this.toPixel.col, this.fromPixel.col),
    );
  }

  getTextLayers() {
    return Object.values(this.textLayers).map(layerId => layerManager.getLayerById(layerId));
  }


  getCellFromTextLayerId(textLayerId) {
    for (let cellId in this.textLayers) {
      if (this.textLayers[cellId] == textLayerId) return this.parseCellId(cellId);
    }
  }

  getTablePixelHeight() {
    var height = 0;
    for (let row = 0; row < this.tblRows; row ++) height += this.getRowHeight(row);
    return height;
  }

  getTablePixelWidth() {
    var width = 0;
    for (let col = 0; col < this.tblCols; col ++) width += this.getColWidth(col);
    return width;
  }

  getRowHeight(row) {
    return this.tblRowHeights[row] || this.tblRowDefaultHeight;
  }

  getColWidth(col) {
    return this.tblColWidths[col] || this.tblColDefaultWidth;
  }

  setRowHeight(row, height) {
    this.tblRowHeights[row] = height;
  }

  setColWidth(col, width) {
    this.tblColWidths[col] = width;
  }


  emptyTextLayers() {
    for (let cellId in this.textLayers) {
      if(!this.cellIsVisible(cellId)) this.archiveCell(cellId);
    }
  }

  cellIsVisible(cellId) {
    let [row, col] = this.parseCellId(cellId);
    return (row < this.tblRows && col < this.tblCols);
  }

  archiveCell(cellId) {
    let textLayer = this.getTextLayer(cellId);
    this.cellTextArchive[cellId] = textLayer.contents;
    textLayer.commit(() => textLayer.empty());
    delete this.textLayers[cellId];
  }

  reviveCell(cellId, absRow, absCol) {
    let textLayer = new TextLayer(
        canvas.getPixelByRowCol(absRow, absCol).id(), this.id
    );
    textLayer.contents = this.cellTextArchive[cellId] || this.defaultCellContents.split("");
    layerManager.addSecond(textLayer);
    this.textLayers[cellId] = textLayer.id;
    textLayer.commit(() => textLayer.drawLayer());
  }

  getTextLayer(cellId) {
    return layerManager.getLayerById(this.textLayers[cellId]);
  }

  setNewTextSpacing(textLayerId) {
    let [cellRow, cellCol] = this.getCellFromTextLayerId(textLayerId);
    // For the row and column that has a change, reset the height/widths for a fresh count.
    this.setRowHeight(cellRow, 0);
    this.setColWidth(cellCol, 0);
    for (let cellId in this.textLayers) {
      let [row, col] = this.parseCellId(cellId);
      // If the edited text is not on the same row or column as this text,
      // we don't need to consider it.
      if (row != cellRow && col != cellCol) continue;
      let lineLengths = this.getTextLayer(cellId).getLineLengths();
      let [textHeight, textWidth] = [lineLengths.length + 1, Math.max(...lineLengths) + 1];
      // If the row is on the edited text's row, consider it's height as the new tallest.
      if (row == cellRow && textHeight > this.tblRowHeights[row]) this.setRowHeight(row, textHeight)
      // If the col is on the edited text's col, consider it's width as the new longest.
      if (col == cellCol && textWidth > this.tblColWidths[col]) this.setColWidth(col, textWidth);
    }
  }

  addTextLayers(topLeftPixel) {
    var absRow = topLeftPixel.row;
    var absCol = topLeftPixel.col;
    for(var tblRow = 0; tblRow < this.tblRows; tblRow ++) {
      for (var tblCol = 0; tblCol < this.tblCols; tblCol ++) {
        let cellId = this.makeCellId(tblRow, tblCol);
        var textLayer = this.getTextLayer(cellId);
        // If a table rollback caused a TextLayer to empty (but it becomes visible again),
        // we must ensure it is redrawn here.
        if (textLayer && !textLayer.pixels.length) {
          textLayer.commit(() => textLayer.drawLayer());
        }
        // If the layer doesn't exist, add a new layer and fill it with any
        // saved content from the past at the same cell location.
        if (!textLayer) this.reviveCell(cellId, 1 + absRow, 1 + absCol);
        absCol += this.getColWidth(tblCol);
      }
      absCol = topLeftPixel.col;
      absRow += this.getRowHeight(tblRow);
    }
  }

  moveTextLayers(topLeftPixel) {
    var absRow = topLeftPixel.row;
    var absCol = topLeftPixel.col;
    for(var tblRow = 0; tblRow < this.tblRows; tblRow ++) {
      for (var tblCol = 0; tblCol < this.tblCols; tblCol ++) {
        let textLayer = this.getTextLayer(this.makeCellId(tblRow, tblCol));
        // Add 1s here to locate the text within the cell.
        let verticalDiff = 1 + absRow - textLayer.fromPixel.row;
        let lateralDiff = 1 + absCol - textLayer.fromPixel.col;
        // If the cell has changed position, then move the layer.
        if (verticalDiff || lateralDiff) {
          textLayer.commit(() => textLayer.move(verticalDiff, lateralDiff));
        }
        absCol += this.getColWidth(tblCol);
      }
      absCol = topLeftPixel.col;
      absRow += this.getRowHeight(tblRow);
    }
  }
}

/////////////////////
//// COMPONENTS /////
/////////////////////
class Component {
  _MagicMethodEventPrefix = "on";
  _MagicPropCssPrefix = "css";

  value = "";
  name = "";
  children = [];
  type = "div";

  constructor(props) {
    this.visible = true;
    if (props) for (let prop in props) this[prop] = props[prop];
  }

  create() {
    this.element = document.createElement(this.type);
  }

  registerMagicProps() {
    var obj = this;

    // Get all properties
    let props = Object.keys(obj);

    // Get all methods
    let allMethods = new Set();
    while (obj = Reflect.getPrototypeOf(obj)) {
      let keys = Reflect.ownKeys(obj);
      keys.forEach((key) => allMethods.add(key));
    }
    props = props.concat(Array.from(allMethods.values()));

    // Assign magic functionality to each magic property type
    for (let prop of props.filter(prop => prop.includes("_"))) {
      let [type, value] = prop.split("_");
      switch(type) {
        case this._MagicPropCssPrefix:
          this.css(value, this[prop]);
        case this._MagicMethodEventPrefix:
          this.element.addEventListener(value.toLowerCase(), () => this[prop]());
        break;
      }
    }
  }

  renderChildren() {
    this.children = this.defineChildren();
    for (let child of this.children) child.render(this.element);
  }

  defineChildren() { return this.children; }
  defineTheme() { };
  renderTheme() {
    this.defineTheme();
    this.children.forEach(child => child.renderTheme());
  }

  renderCallback() {};
  id() {return ""};


  assignParent(parent) {
    this.parent = parent;
    this.parent.appendChild(this.element);
  }

  render(parent) {
    this.create();
    this.setId();
    this.setValue(this.value);
    this.registerMagicProps();
    this.renderChildren();
    this.assignParent(parent);
    this.renderTheme();
    this.renderCallback();
  }

  css(style, value) {
    let valueFromTheme = themeManager.getTheme()[value];
    this.element.style[style] = valueFromTheme? valueFromTheme: value;
  }

  setId() {
    let id = this.id();
    if (id) this.element.id = id;
  }

  setValue(value) {
    this.value = value;
    this.element.innerHTML = value;
  }

  getValue() {
    return this.value;
  }

  show() {
    this.visible = true;
    this.css("display", "block");
  }

  hide() {
    this.visible = false;
    this.css("display", "none");
  }

  toggle() {
    this.visible? this.hide(): this.show();
  }
}

class Pixel extends Component {

  type = "pixel";

  css_position = "absolute";

  constructor(size, widthDivider, row, col) {
    super();
    this.row = row;
    this.col = col;
    this.size = size;
    this.widthDivider = widthDivider;
    this.defaultBorder = "none";
    this.cursorFlashInterval = null;
    this.selected = false;
  }

  id() {
    return Pixel.makeId(this.row, this.col);
  }

  is(pixel) {
    return this.id() == pixel.id();
  }

  static makeId(row, col) {
    return `pixel-${row},${col}`
  }

  renderSelected() {
    this.selected = true;
    this.css("backgroundColor", "pixelSelectedBgColor");
    this.css("color", "pixelSelectedFgColor");
  }

  renderUnselected() {
    this.selected = false;
    this.css("backgroundColor", "pixelNormalBgColor");
    this.css("color", "pixelNormalFgColor");
  }

  renderResizable() {
    this.css("backgroundColor", "pixelResizeBgColor");
  }

  renderAreaSelected() {
    this.css("backgroundColor", "areaSelectionBgColor");
  }

  renderJoint() {
    this.css("backgroundColor", "pixelJointBgColor");
  }

  renderJointNear() {
    this.css("backgroundColor", "pixelJointNearBgColor");
  }

  renderWasSelected() {
    this.selected? this.renderSelected(): this.renderUnselected();
  }

  stopCursor() {
    this.renderNoCursor();
    if (this.cursorFlashInterval) clearInterval(this.cursorFlashInterval);
  }

  renderNoCursor() {
    this.css("border", this.defaultBorder);
  }

  renderCursor() {
    this.css("borderRight", `1px solid ${themeManager.getTheme().pixelCursorColor}`);
  }

  startCursor() {
    this.renderCursor();
    setTimeout(() => this.renderNoCursor(), 500);
    this.cursorFlashInterval = setInterval((pixel) => {
       pixel.renderCursor(); setTimeout(() => pixel.renderNoCursor(), 500);
    }, 1000, this);
  }

  defineTheme() {
    this.renderNormal();
  }

  renderNormal() {
    this.stopCursor();
    this.css("color", "pixelNormalFgColor");
    this.css("backgroundColor", "pixelNormalBgColor");
  }


  clear() {
    this.setValue("");
    this.renderNormal();
  }

  isAbove(pixel) {
    return this.row < pixel.row;
  }

  isBelow(pixel) {
    return this.row > pixel.row;
  }

  isLeft(pixel) {
    return this.col < pixel.col;
  }

  isRight(pixel) {
    return this.col > pixel.col;
  }

  isNear(pixel, distance=6) {
    return (
      Math.abs(pixel.row - this.row) <= distance &&
      Math.abs(pixel.col - this.col) <= distance
    )
  }

  isNearestTo(pixels) {
    var closestPixel;
    var minDistance = -1;
    for (var pixel of pixels) {
      let distance = Math.abs(pixel.row - this.row) + Math.abs(pixel.col - this.col);
      if (distance < minDistance || minDistance == -1) {
        closestPixel = pixel;
        minDistance = distance;
      }
    }
    return closestPixel;
  }

  renderCallback() {
    this.renderNormal();
    this.css("marginLeft", `${this.col * this.size * this.widthDivider}px`);
    this.css("marginTop", `${this.row * this.size}px`);
    this.css("height", `${this.size}px`);
    this.css("width", `${this.size * this.widthDivider}px`);
    this.setValue("");
  }
}

////////////////
//// CANVAS ////
////////////////

class Canvas extends Component {

  type = "div";

  rowCount = 60;
  colCount = 160;

  css_userSelect = "none";
  css_position   = "absolute";
  css_zIindex    = "0";
  pixelSize = 14;
  pixelWidthDivider = 0.5;

  constructor() {
    super();
    this.pixels = {};
    this.setRowColWindowFit();
  }

  setRowColWindowFit() {
    this.rowCount = roundHalf(window.innerHeight / this.pixelSize) - 1;
    this.colCount = roundHalf(window.innerWidth / (this.pixelSize * this.pixelWidthDivider)) - 1;
  }

  getPixelById(id) {
    return this.pixels[id];
  }

  getPixelByRowCol(row, col) {
    return this.getPixelById(Pixel.makeId(row, col));
  }

  clearPixels(pixels) {
    pixels.forEach((pixel) => pixel.clear());
  }

  clear() {
    for(var pixel in this.pixels) this.pixels[pixel].clear();
  }

  getCroppedRowsCols() {
    var maxCol = -1;
    var minCol = this.colCount;
    var maxRow = -1;
    var minRow = this.rowCount;
    for (let pixelId in this.pixels) {
      let pixel = this.pixels[pixelId];
      if (pixel.getValue() != "") {
        if (pixel.col > maxCol) maxCol = pixel.col;
        if (pixel.col < minCol) minCol = pixel.col;
        if (pixel.row > maxRow) maxRow = pixel.row;
        if (pixel.row < minRow) minRow = pixel.row;
      }
    }
    return [maxCol, minCol, maxRow, minRow];
  }

  exportToClipboard() {
    layerManager.switchModeCallback();

    // Scrape text from canvas with linebreaks
    var text = "";
    let [maxCol, minCol, maxRow, minRow] = this.getCroppedRowsCols();
    for (var row = minRow; row < maxRow + 1; row++) {
      var rowText = "";
      for (var col = minCol; col < maxCol + 1; col++) {
        let pixel = this.getPixelByRowCol(row, col);
        let pixelValue = pixel.getValue();
        let value = pixelValue == ""? " ": pixelValue;
        rowText += value;
      }
      if(rowText.split("").filter(v => v != " ").length == 0) continue;
      text += `${rowText}\n`;
    }

    // This is a slight hack to preserve styles if possible.
    // It fills scraped export text into a dump div styled nicely,
    // then copies it literally from there.
    // This allows same-browser exports to preserve styling.
    bodyComponent.canvasDump.setValue(text);
    var selection = window.getSelection()
    var range = document.createRange()
    range.selectNodeContents(bodyComponent.canvasDump.element)
    selection.removeAllRanges()
    selection.addRange(range)
    document.execCommand('copy')
    window.getSelection().removeAllRanges()
  }

  defineTheme() {
    this.css("backgroundColor", "canvasBgColor");
    this.css("fontFamily", "canvasFont");
  }

  on_mouseDown() {
    bodyComponent.settings.hide();
  }

  defineChildren() {
    for (var row = 0; row < this.rowCount; row++) {
      for (var col = 0; col < this.colCount; col++) {
        let pixel = new Pixel(this.pixelSize, this.pixelWidthDivider, row, col);
        this.pixels[pixel.id()] = pixel;
      }
    }
    return Object.values(this.pixels);
  }

  renderCallback() {
    this.css("width", `${this.colCount * this.pixelSize * this.pixelWidthDivider}px`);
    this.css("height", `${this.rowCount * this.pixelSize}px`);
    this.css("fontSize", `${this.pixelSize}px`);
  }
}

class Settings extends Component {

  css_border          = "1px solid #212121"; // TODO These can be based classed with buttons / mixin
  css_boxShadow       = "0px 0px 20px #403f3f";
  css_borderRadius    = "15px";
  css_padding         = "15px";

  css_width           = "300px";
  css_height          = "300px";
  css_backgroundColor = "bodyBgColor";
  css_position        = "absolute";
  css_zIndex          = "1000";
  css_marginLeft      = "calc(50vw - 150px)";
  css_marginTop       = "20vh";
  css_userSelect      = "none";

  charsetButtons = [
    new Button({
      charsetId: "ascii",
      selectByDefault: charManager.getCharset() == "ascii",
      value: "Ascii",
      css_width: "50%",
      on_click: () => this.setCharset("ascii"),
    }),
    new Button({
      charsetId: "unicode",
      selectByDefault: charManager.getCharset() == "unicode",
      value: "Unicode",
      css_width: "50%",
      on_click: () => this.setCharset("unicode"),
    }),
  ];
  themeButtons = [
    new Button({
      themeId: "darkTheme",
      selectByDefault: themeManager.defaultTheme == "darkTheme",
      css_width: "33%",
      value: "Dark",
      on_click: () => this.setTheme("darkTheme")
    }),
    new Button({
      themeId: "lightTheme",
      selectByDefault: themeManager.defaultTheme == "lightTheme",
      css_width: "33%",
      value: "Light",
      on_click: () => this.setTheme("lightTheme")
    }),
    new Button({
      themeId: "consoleTheme",
      selectByDefault: themeManager.defaultTheme == "consoleTheme",
      css_width: "33%",
      value: "Console",
      on_click: () => this.setTheme("consoleTheme")
    }),
  ]

  setCharset(charsetId) {
    for (let button of this.charsetButtons) {
      button.charsetId == charsetId? button.select(): button.unselect();
    }
    charManager.setCharset(charsetId);
    layerManager.refresh(() => layerManager.renderCharset());
  }

  setTheme(themeId) {
    themeManager.setTheme(themeId);
    themeManager.renderTheme();
    for (let button of this.themeButtons) {
      button.themeId == themeId? button.select(): button.unselect();
    }
  }

  defineTheme() {
    this.css("background", "bodyBgColor");
  }

  defineChildren() {
    return [
      new Component({css_fontSize: "50px", css_width: "100%", css_height: "15%", css_textAlign: "center", value: "⚙"}),
      new Component({css_width: "100%", css_marginTop: "30px",
        children: [
          new Component({css_textAlign: "center", css_marginBottom: "10px", value: "Charset"}),
        ].concat(this.charsetButtons)
      }),
      new Component({
        css_width: "100%", css_marginTop: "20px",
        children: [
          new Component({css_textAlign: "center", css_marginBottom: "10px", value: "Theme"}),
        ].concat(this.themeButtons)
      }),
    ]
  }

  renderCallback() {
    this.hide();
  }

}


class Button extends Component {

  type = "button"
  css_fontFamily       = "monospace";
  css_fontSize         = "13px";
  css_paddingBottom    = "3px";
  css_borderRadius     = "15px";
  css_height           = "40px";
  css_border           = "1px solid #212121";
  css_userSelect       = "none";

  defineTheme() {
    this.css("backgroundColor", "menuButtonBgColor");
    this.css("color", "menuButtonFgColor");
    this.selected? this.select(): this.unselect();
  }

  unselect() {
    this.selected = false;
    this.css("backgroundColor", "menuButtonBgColor");
  }

  select() {
    this.selected = true;
    this.css("backgroundColor", "menuButtonSelectedBgColor");
  }

  renderCallback() {
    if (this.selectByDefault) this.select();
  }

  on_mouseDown() {
    this.css("backgroundColor", "menuButtonClickBgColor");
  }

  on_mouseUp() {
    this.css("backgroundColor", "menuButtonBgColor");
  }
}

class MenuButton extends Button {


  css_marginLeft       = "5px";
  css_marginTop        = "10px";
  css_height           = "40px";
  css_border           = "1px solid #212121";
  css_boxShadow        = "0px 0px 20px #403f3f";
  css_borderRadius     = "15px";
  css_float            = "left";


  constructor (icon, name, showCondition, setModes, activeModes, callback=()=>{}) {
    super();
    /*
    name: display name of the button
    showCondition: A ModeMaster condition that gets checked every Menu.refresh
      call to show/hide the button.
    setModes: A ModeMaster update command when the button is pressed.
    activeModes: A ModeMaster condition to choose if the button is selected.
    callback: A function callback on press.
    */
    this.icon = icon;
    this.name = name;
    this.isConditional = Boolean(showCondition.length);
    this.showCondition = modeMaster.makeFunc(showCondition);
    this.callback = callback;
    this.setModes = modeMaster.makeFunc(setModes);
    this.activeModes = activeModes;
  }

  on_mouseDown() {
    this.callback();
    this.setModes();
    if (!this.activeModes.length) super.on_mouseDown();
  }

  on_mouseUp() {
    if (!this.activeModes.length) super.on_mouseUp();
  }


  defineChildren() {
    return [
      new Component({css_display: "inline-block", css_fontSize: "18px", value: this.icon}),
      new Component({css_marginLeft: "5px", css_display: "inline-block", value: this.name}),
    ]
  }

  isActive() {
    return this.activeModes.length && modeMaster.hasOr(...this.activeModes);
  }

  refresh() {
    this.hide();
    this.unselect();
    if (this.showCondition()) this.show();
    if (this.isActive()) this.select();
  }
}

class MenuButtonLeft extends MenuButton {
  css_width = "100%";
}


class Menu extends Component {

  unselectAll() {
    this.buttons.forEach(button => button.unselect());
  }

  refresh() {
    this.buttons.forEach(button => button.refresh());
  }

  defineChildren() {
    return this.buttons;
  }

  renderCallback() {
    modeMaster.registerCallback(() => this.refresh());
    this.refresh();
  }
}

class MainMenu extends Menu {
  css_position       = "absolute";
  css_top            = "0";
  css_left           = "0";
  css_right          = "0";
  css_bottom         = "0";
  css_margin         = "0 auto";
  css_width          = "fit-content";
  css_zIndex         = "100";
  css_height         = "7vh";

  buttons = [
    new MenuButton("➤", "Select",
      [], [modeMaster.reset, "select"], ["selected", "select"], () => layerManager.switchModeCallback()),
    new MenuButton("◻", "Square",
      [], [modeMaster.reset, "draw", "square", "dsbutton"], ["dsbutton"], () => layerManager.switchModeCallback()),
    new MenuButton("t",  "Text",
      [], [modeMaster.reset, "draw", "text", "dtbutton"], ["writing", "dtbutton"], () => layerManager.switchModeCallback()),
    new MenuButton("/", " Line",
      [], [modeMaster.reset, "draw", "line", "free-line", "dflbutton"], ["dflbutton"], () => layerManager.switchModeCallback()),
    new MenuButton("_|", "Step",
      [], [modeMaster.reset, "draw", "line", "step-line", "dslbutton"], ["dslbutton"], () => layerManager.switchModeCallback()),
    new MenuButton("_|‾", "Switch",
      [], [modeMaster.reset, "draw", "line", "switch-line", "dswlbutton"], ["dswlbutton"], () => layerManager.switchModeCallback()),
    new MenuButton("◇", "Diamond",
      [], [modeMaster.reset, "draw", "diamond", "ddibutton"], ["ddibutton"], () => layerManager.switchModeCallback()),
    new MenuButton("᎒᎒᎒", "Table",
      [], [modeMaster.reset, "draw", "table", "dtblbutton"], ["dtblbutton"], () => layerManager.switchModeCallback()),
    new MenuButton("∿", "Free",
      [], [modeMaster.reset, "draw", "free", "dfbutton"], ["dfbutton"], () => layerManager.switchModeCallback()),
    new MenuButton("⌫", "Erase",
      [], [modeMaster.reset, "erase", "ebutton"], ["ebutton"], () => layerManager.switchModeCallback()),
    new MenuButton("↺", "Undo",
      [], [], [], (event) => layerManager.undoEvent(event)),
    new MenuButton("↻", "Redo",
      [], [], [], (event) => layerManager.redoEvent(event)),
    new MenuButton("x", "Restart",
      [], [], [], () => layerManager.refresh(() => layerManager.empty())),
    new MenuButton("->", "Export",
      [], [], [], () => canvas.exportToClipboard()),
    new MenuButton("⚙", "Settings",
      [], [], [], () => bodyComponent.settings.toggle()),
  ]
}

class LeftMenu extends Menu {
  css_height    = "100vh";
  css_width     = "130px";
  css_float     = "left";
  css_position  = "relative";
  css_zIndex    = "100";
  css_marginTop = "7vh";

  buttons = [
    new MenuButtonLeft("⧉", "Copy",
      [modeMaster.has, "selected"], [], [], (event) => layerManager.copySelectedLayersEvent(event)),
    new MenuButtonLeft("⧓", "Group",
      [modeMaster.has, "multi-select", "selected"], [], [], (event) => layerManager.groupSelectedLayersEvent(event)),
    new MenuButtonLeft("⧎", "Ungroup",
      [modeMaster.has, "multi-select", "selected"], [], [], (event) => layerManager.ungroupSelectedLayersEvent(event)),
    new MenuButtonLeft("✕", "Delete",
      [modeMaster.has, "selected"], [modeMaster.reset, "select"], [], (event) => layerManager.deleteLayersEvent(event)),
    new MenuButtonLeft("⎘", "Forward",
      [modeMaster.has, "selected"], [], [], (event) => layerManager.bringForwardEvent(event)),
    new MenuButtonLeft("⎗", "Backwards",
      [modeMaster.has, "selected"], [], [], (event) => layerManager.sendBackwardsEvent(event)),
    new MenuButtonLeft("⎘", "Front",
      [modeMaster.has, "selected"], [], [], (event) => layerManager.bringToFrontEvent(event)),
    new MenuButtonLeft("⎗", "Back",
      [modeMaster.has, "selected"], [], [], (event) => layerManager.sendToBackEvent(event)),
    new MenuButtonLeft("⏴", "Arrow",
      [modeMaster.has, "selected", "line"], [], [], () => layerManager.redrawLinesEvent("left")),
    new MenuButtonLeft("⏵", "Arrow",
      [modeMaster.has, "selected", "line"], [], [], () => layerManager.redrawLinesEvent("right")),
    new MenuButtonLeft("⋮", "Dotted",
      [modeMaster.has, "selected", "line-based"], [], [], () => layerManager.redrawLineBasedEvent("dotted")),
    new MenuButtonLeft("--", "Dashed",
      [modeMaster.has, "selected", "line-based"], [], [], () => layerManager.redrawLineBasedEvent("dashed")),
    new MenuButtonLeft("―", "Solid",
      [modeMaster.has, "selected", "line-based"], [], [], () => layerManager.redrawLineBasedEvent("solid-thin")),
  ]

  refresh() {
    super.refresh();
    this.hide();
    if (this.buttons.map(button => button.showCondition()).some(Boolean)) this.show();
  }

}


class CanvasDump extends Component {
  // We never display this, but export uses this
  // to output before copying to preserve styling.
  // If a user pastes an export in the same browser,
  // the following styles can get preserved.
  // Otherwise, good luck!
  css_fontFamily = "monospace";
  css_backgroundColor = "white";
  css_color = "black";
  css_whiteSpace = "pre-wrap";
  // Hide far away (body overflow is hidden)
  css_marginLeft = "500vw";
}


class Body extends Component {
  type = "body";
  css_overflow = "hidden";

  assignParent(parent) {
    this.parent = document;
    this.parent.body = this.element;
  }

  defineChildren() {
    this.settings   = new Settings();
    this.mainMenu   = new MainMenu();
    this.leftMenu   = new LeftMenu();
    this.canvas     = new Canvas();
    this.canvasDump = new CanvasDump();
    return [
      this.settings,
      this.mainMenu,
      this.leftMenu,
      this.canvas,
      this.canvasDump,
    ];
  }

  defineTheme() {
    this.css("backgroundColor", "bodyBgColor");
    this.css("color", "bodyFgColor");
    this.css("fontFamily", "bodyFont");
  }
}


function main() {
  modeMaster         = new ModeMaster();
  layerManager       = new LayerManager();
  areaSelectManager  = new AreaSelectManager();
  eventManager       = new EventManager();
  charManager        = new CharManager();
  themeManager       = new ThemeManager();

  bodyComponent = new Body();
  bodyComponent.render();

  canvas = bodyComponent.canvas;
  eventManager.assignAll(
    {window: window, document: document, canvas: canvas.element}
  );
}

main(); // :)
</script>
