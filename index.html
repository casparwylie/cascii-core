<html>
  <head>
    <style>
      body {
        background: black;
      }
      #canvas {
        background: black;
        user-select: none;
      }

      #menu {
        height: 50px;
      }

      #menu button {
        padding: 10px;
        margin-left: 10px;
        color: white;
        border: 1px solid white;
        float: left;
      }
    </style>
  </head>
  <body>
    <div id="menu"></div>
    <div id="canvas"></div>

  <script defer>
    /*

    TODO
    FE 
    - restart -> clear (allow undo)
    - select all (ctrl-a)
    - cmd v ctrl for Mac
    - make all text pixels joinable
    - make all line pixels joinable
    - make joint pixels x
    - mini success messages
    - clever resize: text in boxes main issue
    - arrows editable
    - file break up?
    - export 
    - clever free draw straight chars
    - more shapes: diagnol lines, tables, diamonds, triangles
    - arrow headed lines
    - proper design / config
    - unicode v ascii
    - themes
    - z-index concepting
    - intro / why ascii
    - manual page. shortcuts, etc.

    - BE: save, share, manage, user, login google + github,  CRUD
      - guest auto save (refresh keeps)
      - plain text request / curl

    BUGS / IMPROVEMENTS:
    - writing cursor move focus one only
    - cannot area select right most column

    var out = "";
    for(var row = 0; row < canvas.rowCount; row ++ ) {
        for (var col = 0; col < canvas.colCount; col ++) {
           let content = canvas.getPixelByRowCol(row, col).element.innerHTML;
           out += (content == "")? " ": content;
        }
        out += "\n";
    }
    console.log(out);

    */
    const KEYS = {
      "up"      : 38,
      "right"   : 39,
      "down"    : 40,
      "left"    : 37,

      "shift"   : 16,
      "back"    : 8,
      "delete"  : 46,
      "esc"     : 27,
      "ctrl"    : 17,
      "enter"   : 13,

      "z"       : 90,
      "c"       : 67,
      "g"       : 71,
    }

    const ArrowKeyGroup = ["up", "down", "left", "right"];
    
    function reportError(message) {
      console.log(message);
    }

    function debugError(message) {
      alert(`[DEBUG]: ${message}`);
    }
    
    function roundHalf(value) {
      return parseInt(Math.round(value / 0.5) * 0.5);
    } 

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function keyGroup(...names) {
      let keys = names.map(name => KEYS[name].toString());
      return keys.join(",");
    }

    var layerManager;
    var eventManager;
    var areaSelectManager;
    var modeMaster;
    var menu;
    var canvas;

    //////////////////
    ////// MODES /////
    //////////////////

    class ModeMaster {
      constructor() {
        this._modes = [];
        this.callbacks = [];
      }

      registerCallback(func) {
        this.callbacks.push(func);
      }
      
      modeChangedCallback() {
        for (var func of this.callbacks) func();
      }

      makeFunc(instruction) {
        // This just gives dispatchers a prettier notation... 
        // e.g () => modeMaster.has("x", "y") becomes [modeMaster.has, "x", "y"]
        return (instruction.length)? instruction[0].bind(this, ...instruction.slice(1)): () => true;
      }

      change(beforeMode, afterMode) {
        let index = this._modes.indexOf(beforeMode);
        if (index == -1) return;
        this._modes[index] = afterMode;
        this.modeChangedCallback();
      }

      toggle(mode) {
        if (this.has(mode)) {
          this.remove(mode);
        } else {
          this.add(mode);
        }
      }

      remove(...modes) {
        modes.forEach((mode) => {
          let index = this._modes.indexOf(mode);
          if (index == -1) return; 
          this._modes.splice(index, 1);
        });
        this.modeChangedCallback();
      }

      reset(...modes) {
        this._modes = modes;
        this.modeChangedCallback();
      }

      add(...modes) {
        this._modes = this._modes.concat(modes);
        this.modeChangedCallback();
      }

      has(...modes) {
        return modes.map((mode) => this._modes.includes(mode)).every(Boolean);
      }

      hasOr(...modes) {
        return modes.map((mode) => this._modes.includes(mode)).some(Boolean);
      }

      is(...modes) {
        return this._modes.toString() == modes.toString(); 
      }
      
      removeLayers() {
        this.remove("square");
        this.remove("free-line");
        this.remove("step-line");
        this.remove("free");
        this.remove("text");
      }

      setLayer(name) {
        this.removeLayers();
        this.add(name);
      }
    }

    ////////////////
    //// EVENTS ////
    ////////////////



    class EventDef {
      constructor(modeCondition, modeUpdate, callback=()=>{}) {
        this.callback = callback;
        this.condition = modeMaster.makeFunc(modeCondition);
        this.update = modeMaster.makeFunc(modeUpdate);
      }
      
      run(event) {
        if (this.condition()) {
          this.update();
          this.callback(event);
          console.log(modeMaster._modes);
          return true;
        }
      }
    }
    
    class EventManager {
      MAP = {
        document: {
          keyEvents: {
            keypress: {
              "*": [
                new EventDef([modeMaster.has, "writing", "text"], [], TextLayer.keyDownEvent),
              ],
            },
            keydown: {
              [keyGroup(...ArrowKeyGroup)]: [
                new EventDef([modeMaster.has, "selected"],
                    [], (event) => layerManager.selectedArrowKeyDownEvent(event)),
              ],                                                                        
              [keyGroup("shift")]: [
                new EventDef([], 
                    [modeMaster.add, "shift"])
              ],
              [keyGroup("back", "delete")]: [
                new EventDef([modeMaster.has, "selected"],
                    [modeMaster.reset, "select"], () => layerManager.deleteLayersEvent()),
              ],
              [keyGroup("esc")]: [
                new EventDef([modeMaster.has, "selected"],
                    [modeMaster.reset, "select"], () => layerManager.unselectAll()),
              ],
              [keyGroup("back", "delete", ...ArrowKeyGroup)]: [
                new EventDef([modeMaster.has, "writing", "text"],
                    [], TextLayer.keyDownEvent),
              ],
              [keyGroup("ctrl")]: [
                new EventDef([],
                    [modeMaster.add, "ctrl"]),
              ],
              [keyGroup("z")]: [
                new EventDef([modeMaster.has, "shift", "ctrl"],
                    [], () => layerManager.redoEvent()),
                new EventDef([modeMaster.has, "ctrl"], 
                    [], () => layerManager.undoEvent()),
              ],
              [keyGroup("c")]: [
                new EventDef([modeMaster.has, "ctrl", "selected"],
                    [], () => layerManager.copySelectedLayersEvent()),
              ],
              [keyGroup("g")]: [
                new EventDef([modeMaster.has, "selected"],
                    [], () => layerManager.groupSelectedLayersEvent()),
              ],
            },
            keyup: {
              [keyGroup("shift")]: [
                new EventDef([modeMaster.has, "shift"],
                    [modeMaster.remove, "shift"]),
              ],
              [keyGroup("ctrl")]: [
                new EventDef([modeMaster.has, "ctrl"],
                    [modeMaster.remove, "ctrl"]),
              ],
            }
          }
        },
        window: {
          mouseEvents: {
            mouseup: [
              new EventDef([modeMaster.has, "drawing"],
                  [modeMaster.change, "drawing", "draw"], () => layerManager.tidyLayers()), 
              new EventDef([modeMaster.has, "erasing"],
                  [modeMaster.change, "erasing", "erase"]),
              new EventDef([modeMaster.has, "moving"],
                  [modeMaster.remove, "moving"], () => layerManager.tidyLayers()),
              new EventDef([modeMaster.has, "area-selecting"],
                  [modeMaster.remove, "area-selecting"], (event) => areaSelectManager.areaSelectingMouseUpEvent(event)),
              new EventDef([modeMaster.has, "resizing"],
                  [modeMaster.reset, "selected"], () => layerManager.tidyLayers()),
            ],
          }
        }, 
        canvas: {
          mouseEvents: {
            mousedown: [
              new EventDef([modeMaster.has, "draw", "text"],
                  [modeMaster.change, "draw", "writing"], TextLayer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "draw", "free-line"],
                  [modeMaster.change, "draw", "drawing"], FreeLineLayer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "draw", "step-line"],
                  [modeMaster.change, "draw", "drawing"], StepLineLayer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "draw", "free"],
                  [modeMaster.change, "draw", "drawing"], FreeLayer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "draw", "square"],
                  [modeMaster.change, "draw", "drawing"], SquareLayer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "writing", "text"],
                  [], TextLayer.writingMouseDownEvent),
              new EventDef([modeMaster.has, "erase"],
                  [modeMaster.change, "erase", "erasing"], (event) => layerManager.erasePixelEvent(event)),
              new EventDef([modeMaster.hasOr, "selected", "select"], 
                  [], Layer.selectMouseDownEvent),
            ],
            mouseover: [
              new EventDef([modeMaster.has, "draw", "free-line"],
                  [], FreeLineLayer.drawMouseOver),
              new EventDef([modeMaster.has, "draw", "step-line"],
                  [], StepLineLayer.drawMouseOver),
              new EventDef([modeMaster.has, "drawing", "free"],
                  [], FreeLayer.drawingMouseOverEvent),
              new EventDef([modeMaster.has, "drawing", "free-line"],
                  [], FreeLineLayer.drawingMouseOverEvent),
              new EventDef([modeMaster.has, "drawing", "step-line"],
                  [], StepLineLayer.drawingMouseOverEvent),
              new EventDef([modeMaster.has, "drawing", "square"],
                  [], SquareLayer.drawingMouseOverEvent),
              new EventDef([modeMaster.has, "erasing"],
                  [], (event) => layerManager.erasePixelEvent(event)),
              new EventDef([modeMaster.has, "moving"],
                  [], (event) => layerManager.movingMouseOverEvent(event)),
              new EventDef([modeMaster.has, "area-selecting"],
                  [], (event) => areaSelectManager.areaSelectingMouseOverEvent(event)),
              new EventDef([modeMaster.has, "resizing", "free-line"],
                  [], FreeLineLayer.resizingMouseOverEvent),
              new EventDef([modeMaster.has, "resizing", "step-line"],
                  [], StepLineLayer.resizingMouseOverEvent),
              new EventDef([modeMaster.has, "resizing", "square"],
                  [], SquareLayer.resizingMouseOverEvent),
            ],
            dblclick: [
              new EventDef([modeMaster.has, "selected", "text"],
                  [modeMaster.change, "selected", "writing"], TextLayer.selectedDoubleClickEvent),
            ]
          }
        }
      }

      assignMouseEventDefs(element, allDefs) {
        for (const [eventType, defs] of Object.entries(allDefs)) {
          element.addEventListener(eventType, (event) => {
            for (var def of defs) if (def.run(event)) return;
          })
        }
      }

      assignKeyEventDefs(element, defs) {
        Object.keys(defs).forEach((eventType) => {
          element.addEventListener(eventType, (event) => {
            for (var keys in defs[eventType]) {
              keys.split(",").forEach(key => {
                if (key == event.keyCode.toString() || key == "*") {
                  for (var def of defs[eventType][keys]) {
                    if (def.run(event)) return;
                  }
                }
              });
            }
          });
        });
      } 

      assignAll(namedElements) {
        for (const [elementName, eventGroups] of Object.entries(this.MAP)) {
          for (const [eventGroup, eventDefs] of Object.entries(eventGroups)) {
            switch (eventGroup) {
              case "mouseEvents":
                this.assignMouseEventDefs(namedElements[elementName], eventDefs);
              break;
              case "keyEvents":
                this.assignKeyEventDefs(namedElements[elementName], eventDefs);
              break;
            }
          }
        }
      }
    }
    ////////////////////
    ////// LAYERS //////
    ////////////////////


    class GroupManager {
      constructor() {
        this.layerGroups = [];
      }

      findGroupsFromLayers(layers) {
        /*
          Find groups which are fully included in the provided layers.
          E.g
          Groups = [[1, 2, 3], [5, 6], [4, 5], [1, 2]]
          layers = [1, 2, 3, 4]
            => [[1, 2, 3], [1, 2]]
        */

        var foundGroups = [];
        let layerIds = layers.map(layer => layer.id);
        for (var groupLayerIds of this.layerGroups) {
          if (groupLayerIds.map(layerId => layerIds.includes(layerId)).every(Boolean)) {
            foundGroups.push(groupLayerIds);
          }
        }
        return foundGroups;
      }

      ungroupLayers(layers) {
        let groups = this.findGroupsFromLayers(layers).map(group => group.toString());
        this.layerGroups = this.layerGroups.filter(group => !groups.includes(group.toString()));
      }

      groupLayers(layers) {
        this.layerGroups.push(layers.map(layer => layer.id));
      }
      
      getSiblingLayerIds(memberLayer) {
        var layerIds = [];
        for (var group of this.layerGroups) {
          if (group.includes(memberLayer.id)) layerIds = layerIds.concat(group); 
        }
        return layerIds;
      }

      tidy(layers) {
        var index = 0;
        for (var layerGroup of this.layerGroups) {
          this.layerGroups[index] = layerGroup.filter(layerId => !layers.includes(layerId));
          index ++;
        }

        // Tidy empty / one layer groups 
        this.layerGroups = this.layerGroups.filter(group => group.length > 1);
      }
    }
      

    class AreaSelectManager {
      constructor() {
        this.areaSelectionPixels = [];
      }

      clearAreaSelection() {
        this.areaSelectionPixels.forEach(pixel => pixel.renderNormal());
        this.areaSelectionPixels = [];
      }

      areaSelectingMouseUpEvent(event) {
        this.clearAreaSelection();
        // Re-render selected layers having just cleared pixels.
        layerManager.getSelectedLayers().forEach(layer => layer.renderSelected());
      }
      
      areaSelectingMouseOverEvent(event) {
        this.clearAreaSelection();
        let firstPixel = layerManager.selectedPixel;
        let activePixel = canvas.getPixelById(event.target.id);

        let lateralDiff = activePixel.col - firstPixel.col;
        let verticalDiff = activePixel.row - firstPixel.row;
        let total = Math.abs(lateralDiff * verticalDiff)

        var drawRow = firstPixel.row;
        var drawCol = firstPixel.col;
        for (var i = 0; i < Math.abs(verticalDiff); i ++) {
          for (var x = 0; x < Math.abs(lateralDiff); x ++) {
            let pixel = canvas.getPixelByRowCol(parseInt(drawRow), parseInt(drawCol));
            this.areaSelectionPixels.push(pixel);
            pixel.renderAreaSelected();
            drawCol += lateralDiff / Math.abs(lateralDiff);
          }
          drawRow += verticalDiff / Math.abs(verticalDiff);
          drawCol = firstPixel.col;
        }

        this.selectLayersInAreaSelection();
      }

      selectLayersInAreaSelection() {
        for (var layer of layerManager.layers) {
          let layerPixelIds = layer.pixels.map(pixel => pixel.id());
          let selectedPixelIds = this.areaSelectionPixels.map(pixel => pixel.id());
          if (layerPixelIds.filter(pixel => !selectedPixelIds.includes(pixel)).length) {
            if (layer.isSelected()) {
              layer.unselect();
            }
          } else {
            layer.select();
            modeMaster.change("select", "selected");
          }
        }
      }
    }

    class LayerManager {
      constructor() {
        this.layers = [];
        this.selectedPixel = null;
        this.layerHistory = [[]];
        this.historyCursor = 0;
        this.groupManager = new GroupManager();
      }

      add(layer) {
        this.layers.unshift(layer);
      } 

      getLatestLayer() {
        return this.layers[0];
      }

      getLayerById(layerId) {
        for (var layer of this.layers) {
          if (layer.id == layerId) return layer;
        }
      }

      getLayerByPixelId(id) {
        for (var layer of this.layers) { 
          if (layer.getPixelIndex(id) > -1) return layer;
        }
      }

      getSelectedLayers() {
        return this.layers.filter((layer) => layer.isSelected());
      }

      deleteSelectedLayers() {
        this.getSelectedLayers().forEach((layer) => layer.empty()); 
        this.tidyLayers();
      }

      selectGroupsByMemberLayer(memberLayer) {
        let siblingLayerIds = this.groupManager.getSiblingLayerIds(memberLayer);
        siblingLayerIds.forEach(layerId => this.getLayerById(layerId).select());
      }

      copyAndRenderSelectedLayers() {
        let layersToCopy = this.getSelectedLayers();
        let groupsToCopy = this.groupManager.findGroupsFromLayers(layersToCopy);

        // Render layers in groups
        for (var group of groupsToCopy) {
          var newGroup = group.map(layerId => this.copyAndRender(this.getLayerById(layerId)));
          this.groupManager.groupLayers(newGroup);
        }

        // Render remaining layers
        for (var layer of layersToCopy) {
          if (groupsToCopy.flat().includes(layer.id)) continue;
          this.copyAndRender(layer);
        }
        this.capture();
      }

      copyAndRender(layer) {
        let layerCopy = layer.copy();
        while (this.isLayerOverlapped(layerCopy)) layerCopy.move(1, 1);
        this.add(layerCopy); 
        layer.unselect();
        layerCopy.select();
        return layerCopy;
      }

      isLayerOverlapped(subjectLayer) {
        for (var layer of this.layers) {
          if (layer.isOverlapping(subjectLayer)) return true;
        }
      }

      unselectAll() {
        this.layers.forEach(layer => layer.unselect());
        modeMaster.removeLayers();
      }

      refresh(updateFunc) {
        this.clearAll();
        updateFunc();
        this.renderAll();
      }
      
      tidyAllJoints(layersToDelete) {
        for (var layer of this.layers) {
          layer.joints = layer.joints.filter(joint => !layersToDelete.includes(joint.layerId));
          layer.tidyJoints();
        }
      }

      tidyLayers() {
        // Find layer IDs for dereferencing 
        let layersToDelete = this.layers.filter(layer => !layer.pixels.length).map(layer => layer.id);
        
        // Delete empty layers
        this.layers = this.layers.filter(layer => !layersToDelete.includes(layer.id));

        // Delete references to empty layers in groups
        this.groupManager.tidy(layersToDelete);

        // Delete references to empty layers in layer joints
        this.tidyAllJoints(layersToDelete);

        this.capture();
      }

      clearAll() {
        this.layers.forEach((layer) => layer.clear());
      }

      renderAll() {
        this.layers.slice().reverse().forEach((layer) => layer.render());
      }

      empty() {
        this.layers = [];
        this.layerHistory = [];
      }

      capture() {
        this.historyCursor = 0;
        this.layerHistory.unshift(this.copyReplaceLayers(this.layers));
      }

      copyReplaceLayers(layers) {
        return layers.map(layer => layer.copy(true));
      }

      undo() {
        let limit = this.layerHistory.length - 1;
        this.historyCursor = (this.historyCursor < limit)? this.historyCursor + 1: limit;
        // Copy historic layers to avoid mutating them now that they're current.
        // Past will otherwise show as present...
        this.layers = this.copyReplaceLayers(this.layerHistory[this.historyCursor]); 
      }

      redo() {
        this.historyCursor = (this.historyCursor > 0)? this.historyCursor - 1: 0;
        // Copy historic layers to avoid mutating them now that they're current.
        // Past will otherwise show as present...
        this.layers = this.copyReplaceLayers(this.layerHistory[this.historyCursor]);
      }
      
      setSelectPixel(selectedPixel) {
        this.selectedPixel = selectedPixel;
      }

      getSelectPixel() {
        return this.selectedPixel;
      }

      moveSelectedLayers(verticalDiff, lateralDiff) {
        let selectedLayers = this.getSelectedLayers();
        this.refresh(() => {
          selectedLayers.forEach((layer) => {
            let originalJoints = layer.getJointPixels();
            layer.move(verticalDiff, lateralDiff);
            layer.moveJointLayers(originalJoints);
          });
        });
        this.findJoints(selectedLayers);
      }

      findJoints(jointProbingLayers) {
        for (var layer of this.layers) {
          if (layer.isSelected()) continue;
          // Only joinable layers will return joint pixels here and therefore get probed.
          let jointPixels = layer.getJointPixels(); 
          var jointIndex = 0;
          for (var jointPixel of jointPixels) {
            var renderState = -1;
            for (var probingLayer of jointProbingLayers) {
              // Only prober layers will look for joins (e.g lines).
              let state = probingLayer.probeJoin(layer, jointIndex, jointPixel); 
              if (state > renderState) renderState = state;
            }
            switch (renderState) {
              case 0:
                jointPixel.renderNormal();
              break;
              case 1:
                jointPixel.renderJointNear();
              break;
              case 2:
                jointPixel.renderJoint();
              break;
            }
            jointIndex ++;
          } 
        }
      }

      // Generic multi-layer based events...

      movingMouseOverEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        let lastPixelSelected = this.getSelectPixel();
        let verticalDiff = activePixel.row - lastPixelSelected.row;
        let lateralDiff = activePixel.col - lastPixelSelected.col;
        this.moveSelectedLayers(verticalDiff, lateralDiff);
        this.setSelectPixel(activePixel);
      }
    
      selectedArrowKeyDownEvent(event) {
        var verticalDiff = 0;
        var lateralDiff = 0;
        switch (event.keyCode) {
          case KEYS["up"]:
            verticalDiff = -1;
            break;
          case KEYS["right"]:
            lateralDiff = 1;
            break;
          case KEYS["down"]:
            verticalDiff = 1;
            break;
          case KEYS["left"]:
            lateralDiff = -1;
            break;
        }
        this.moveSelectedLayers(verticalDiff, lateralDiff);
        this.capture();
      }

      deleteLayersEvent(event) {
        this.refresh(() => this.deleteSelectedLayers());
      }

      copySelectedLayersEvent(event) {
        this.refresh(() => this.copyAndRenderSelectedLayers());
      }

      undoEvent(event) {
        this.refresh(() => this.undo());
      }

      redoEvent(event) {
        this.refresh(() => this.redo());
      }

      groupSelectedLayersEvent(event) {
        this.groupManager.groupLayers(this.getSelectedLayers());
      }

      ungroupSelectedLayersEvent(event) {
        this.groupManager.ungroupLayers(this.getSelectedLayers());
        layerManager.unselectAll();
      }

      erasePixelEvent(event) {
        // TODO: This only really works for free draw layers. Also bug if erase resize pixels. 
        let activePixel = canvas.getPixelById(event.target.id);
        let layer = this.getLayerByPixelId(activePixel.id());
        if (layer) layer.erasePixel(activePixel.id());
        activePixel.clear();
      }
    }
    

    class Layer {

      lateralChar = "―";
      verticalChar = "|";

      constructor(firstPixelId) {
        this.id = this.makeId();
        this.pixels = [];
        this.values = [];
        this.joints = [];
        this._isSelected = false;
        
        this.setFirstTouchedPixel(canvas.getPixelById(firstPixelId));
        layerManager.setSelectPixel(this.firstTouchedPixel);
      }

      makeId() {
        return randomInt(1, 100000).toString() + Date.now().toString();
      }

      static selectMouseDownEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        let layer = layerManager.getLayerByPixelId(activePixel.id());
        let selectedLayers = layerManager.getSelectedLayers();

        if (!layer) {
          modeMaster.add("area-selecting");
          layerManager.setSelectPixel(activePixel);
        }

        // Unselect all if...
        // 1. clicked-off (no layer selected)
        // 2. Single select mode (not multi) and alternative layer picked. 
        if (!layer || (!modeMaster.has("shift") && !layer.isSelected())) {
          layerManager.unselectAll();
          modeMaster.change("selected", "select");
        }

        if (layer) {
          modeMaster.change("select", "selected");
          modeMaster.setLayer(layer.name);
          let resizePixel = layer.getResizeFirstPixel(activePixel);
          if (resizePixel) {
            layer.setFirstTouchedPixel(resizePixel);
            modeMaster.add("resizing");
          } else {
            layerManager.setSelectPixel(activePixel);
            modeMaster.add("moving");
          }
          layer.select();
          if (!modeMaster.has("ctrl")) layerManager.selectGroupsByMemberLayer(layer);
        }
      }

      select() {
        this._isSelected = true;
        this.renderSelected();
      }

      unselect() {
        this._isSelected = false;
        this.renderUnselected();
      }


      setFirstTouchedPixel(pixel) {
        this.firstTouchedPixel = pixel;
      }

      getLastPixel() {
        return (this.pixels.length)? this.pixels[this.pixels.length - 1]: this.firstTouchedPixel;
      }

      getFirstPixel() {
        return (this.pixels.length)? this.pixels[0]: this.firstTouchedPixel;
      }

      draw(pixel, value) {
        let existingPixelIndex = this.getPixelIndex(pixel.id());

        if (existingPixelIndex == -1) {
          this.pixels.push(pixel);
          this.values.push(value);
        } else {
          this.values[existingPixelIndex] = value;
        }
        if (this.pixels.length != this.values.length) {
          console.log(`layer pixel/value mismatch: ${this.pixels} != ${this.values}`)
        }
      }
      
      // Implement if the layer get be joined to (e.g a square)
      getJointPixels() {
        return [];
      }
      
      // Implement if the layer can join to another (e.g a line)
      probeJoin(layer, index, pixel) {
        return -1;
      }

      // Implement if the layer can be resized.
      // This will determine which pixels can be used to
      // resize a layer.
      getResizePixels() { 
        return [];
      } 

      // Implement if the layer can be resized.
      // This will determine which pixel to resize from, 
      // given a resize point. 
      getResizeFirstPixel() {
        return false;
      }
      
      clear() {
        this.pixels.forEach((pixel) => pixel.clear());
      }

      copyRenameJointLayerIds() {
        var index = 0;
        for (var joint of this.joints) {
          this.joints[index].layerId = joint.layerId + "c!";
          index ++;
        }
      }

      tidyJoints() {
        let jointPixels = this.getJointPixels();
        for (var joint of this.joints) {
          let layer = layerManager.getLayerById(joint.layerId);
          if (!layer) {
            // If the joining layer doesn't exist, then remove the reference.
            // This can happen if a layer has been copied without it's 
            // joining layer. The layer will now hold a copied joint reference
            // without a physical joint or the copied reference actually pointing
            // to a new joint.
            this.unjoin(joint.layerId, joint.jointIndex);
            continue;
          }
          let jointPixel = jointPixels[joint.jointIndex];

          // We can use probeJoin here to clean up dangling joints.
          // By probing, if the joints are no longer together, it will
          // unjoin.
          let state = layer.probeJoin(this, joint.jointIndex, jointPixel);
          if (state != 2) {
            debugError("had to unjoin dangling join");
          }
        }
      }

      copy(replace=false) {
        let layerCopy = new this.constructor(this.firstTouchedPixel.id());
        if (replace) {
          // This is an exact copy, mainly used for capturing snapshots,
          // reverting history.
          layerCopy.id = this.id;
          layerCopy.joints = this.joints.map(joint => joint); 
        } else {
          // Here we use the same ID to maintain identity / relationships in
          // copied layer references (e.g joints), but add c! to provide a new identity.
          // If a layer is copied, it assumes joints have been copied with it, and references
          // are updated with c! too. Otherwise, these joints will be deleted in this.tidyJoints.
          layerCopy.id = this.id + "c!"; 
          layerCopy.joints = this.joints.map(joint => structuredClone(joint)); 
          layerCopy.copyRenameJointLayerIds();
        }
        layerCopy.pixels = this.pixels.map(pixel => pixel);
        layerCopy.values = this.values.map(value => value);
        return layerCopy;
      }

      isOverlapping(targetLayer) {
        /*
          Check if target layer is fully visually covered by this layer.

          E.g 
          target pixels = [1, 2, 3, 4]
          this pixels   = [1, 2, 3, 4, 5]
            => true

          target pixels = [1, 2, 3]
          this pixels   = [1, 2, 5, 6]
            => false
        */
        let layerPixelIds = this.pixels.map(pixel => pixel.id());
        return targetLayer.pixels.map(pixel => layerPixelIds.includes(pixel.id())).every(Boolean)
      }
      
      renderUnselected() {
        this.pixels.forEach((pixel) => pixel.renderNormal());
      }

      renderSelected() {
        this.getResizePixels().forEach(pixel => pixel.renderResizable());
        this.pixels.forEach(pixel => pixel.renderSelected());
      }

      render() {
        if (this.isSelected()) this.renderSelected();
        for (var i = 0; i < this.pixels.length; i++) this.pixels[i].setValue(this.values[i]);
      }

      move(verticalDiff, lateralDiff) {
        let newPixels = [];
        for (var oldPixel of this.pixels) {
          let newPixel = canvas.getPixelByRowCol(
            oldPixel.row + verticalDiff,
            oldPixel.col + lateralDiff
          );
          if (!newPixel) return;
          newPixels.push(newPixel);
        }
        this.pixels = newPixels;
      }

      moveJointLayers(originalJointPixels) {
        // Only joint layers will have joints.
        for (var joint of this.joints) {
          let layer = layerManager.getLayerById(joint.layerId);

          // If the layer is selected, it must be moving, meaning
          // it doesn't need moving here aswell.
          if (!layer || layer.isSelected()) continue;

          let jointPixel = this.getJointPixels()[joint.jointIndex];
          let resizePixel = layer.getResizeFirstPixel(originalJointPixels[joint.jointIndex]);

          // The resize pixel may not get found if the main layer has
          // somehow moved without the jointed layer. This should not happen.
          if (!resizePixel) {
            debugError("resize pixel not found");
            return;
          }
          layer.setFirstTouchedPixel(resizePixel);
          layer.drawLayer(jointPixel.id()); 
        }
      }

      join(layerId, jointIndex) {
        for (var joint of this.joints) {
          if (layerId == joint.layerId && jointIndex == joint.jointIndex) {
            return;
          }
        }
        this.joints.push({layerId: layerId, jointIndex: jointIndex});
      }

      unjoin(layerId, jointIndex) {
        var index = 0;
        for (var joint of this.joints) {
          if (layerId == joint.layerId && jointIndex == joint.jointIndex) {
            this.joints.splice(index, 1);
            return;
          }
          index ++;
        }
      }

      getPixelIndex(id) {
        for (var i = 0; i < this.pixels.length; i++) {
          let pixel = this.pixels[i];
          if (pixel.id() == id) return i;
        }
        return -1;
      }

      erasePixel(id) {
        for (var i = 0; i < this.pixels.length; i++) {
          if (this.pixels[i].id() == id) this.deletePixelByPosition(i);
        }
      }

      deletePixelByPosition(index) {
        this.pixels.splice(index, 1);
        this.values.splice(index, 1);
      }
      
      isSelected() {
        return this._isSelected;
      }

      empty() {
        this.pixels = [];
        this.values = [];
      }
    }
    

    /////////////////////////
    ////// TEXT LAYER ///////
    /////////////////////////

    class TextLayer extends Layer {
      
      name = "text"

      constructor(firstPixelId) {
        super(firstPixelId);
        this.cursor = 0;
        this.contents = [];
        this.layer = null;
      }
      
      static selectedDoubleClickEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        let layer = layerManager.getLayerByPixelId(activePixel.id());
        layer.moveCursorToPixel(activePixel);
      }

      static drawMouseDownEvent(event) {
        let layer = new TextLayer(event.target.id);
        layerManager.add(layer);
        layer.firstTouchedPixel.renderFocus();
      }

      static writingMouseDownEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        let layer = layerManager.getLayerByPixelId(activePixel.id());
        if (layer) {
          layer.moveCursorToPixel(activePixel);
        } else {
          modeMaster.change("writing", "select");
          layerManager.unselectAll();
        }
      }

      static keyDownEvent(event) {
        let selectedLayers = layerManager.getSelectedLayers();
        let layer = (selectedLayers.length) ? selectedLayers[0]: layerManager.getLatestLayer();
        layer.writeChar(event.keyCode);
      }

      getLength() {
        return this.contents.length;
      }

      moveCursorToPixel(pixel) {
        this.cursor = this.getPixelIndex(pixel.id()) + 1;
        pixel.renderFocus();
      }

      getCursorLineOffset() {
        for (var i = this.cursor; i >= 0; i --) {
          if (i == 0) {
            return this.cursor - i;
          } else if (this.contents[i] == "\n") {
            if ((this.cursor - i) == 0) {
              continue;
            }
            return this.cursor - i - 1;
          }
        }
      }

      getCurrentLine() {
        var line = 0;
        for (var i = 0; i < this.getLength(); i++) {
          if (i == this.cursor || i + 1 == this.getLength()) return line;
          if (this.contents[i] == "\n") line ++;
        }
        return 0;
      }

      getLineStart(lineNum) {
        var line = 0;
        for (var i = 0; i < this.getLength(); i++) {
          if (line == lineNum) return i;
          if (this.contents[i] == "\n") line ++;
        }
        return i;
      }

      getLineLengths() {
        var lengths = [0];
        for (var i = 0; i < this.getLength(); i++) {
          if (this.contents[i] == "\n") {
            lengths.push(0);
          } else {
            lengths[lengths.length - 1] ++;
          }
        }
        return lengths;
      }

      drawLayer() {
        // Get latest first pixel given the layer may have moved and this could be
        // an edit. 
        this.firstTouchedPixel = (this.pixels.length) ? this.pixels[0]: this.firstTouchedPixel;
        if(this.lastCursorPixel) this.lastCursorPixel.renderNormal();
        this.empty();
        let pixels = [];
        var line = 0;
        var col = 0;
        for (var i = 0; i < this.getLength(); i++) {
          if (this.contents[i] == "\n") {
            line ++;
            col = 0;
          }
          let pixel = canvas.getPixelByRowCol(
            this.firstTouchedPixel.row + line,
            this.firstTouchedPixel.col + col)
          ;
          if (this.cursor == i + 1) {
            this.lastCursorPixel = pixel;
            pixel.renderCursor();
          }
          if (!pixel || this.contents[i] == "\n") continue;
          this.draw(pixel, this.contents[i]);
          col ++;
        }
      }


      getVerticalCursor(direction) {
        let currentLine = this.getCurrentLine();
        let lineLengths = this.getLineLengths(); 
        let cursorLineOffset = this.getCursorLineOffset();
        var nextLine;
        if (direction == "up") {
            nextLine = (currentLine > 0)? currentLine - 1: currentLine;
        } else {
            nextLine = (lineLengths.length - 1 > currentLine)? currentLine + 1: currentLine;
        }
        let col = (lineLengths[nextLine] > cursorLineOffset)? cursorLineOffset: lineLengths[nextLine];
        return this.getLineStart(nextLine) + col;
      }

      writeChar(key) {
        let char = String.fromCharCode(key);
        let length = this.getLength();
        let currentLine = this.getCurrentLine();
        let lineLengths = this.getLineLengths(); 
        let cursorLineOffset = this.getCursorLineOffset();
        switch (key) {
          case KEYS["down"]: 
            this.cursor = this.getVerticalCursor("down");
          break;
          case KEYS["up"]:
            this.cursor = this.getVerticalCursor("up");
          break;
          case KEYS["right"]:
            this.cursor = (this.cursor >= length)? length: this.cursor + 1;
          break;
          case KEYS["left"]:
            this.cursor = (this.cursor <= 0)? 0: this.cursor - 1;
          break;
          case KEYS["enter"]:
            this.contents.splice(this.cursor, 0, "\n");
            this.cursor++;
          break;
          case KEYS["back"]:
            this.cursor = (this.cursor <= 0)? 0: this.cursor - 1;
            this.contents.splice(this.cursor, 1);
          break;
          default:
            this.contents.splice(this.cursor, 0, char);
            this.cursor++;
          break;
        }
        layerManager.refresh(() => this.drawLayer());

      }
    }

    /////////////////////////
    ////// LINE LAYER ///////
    /////////////////////////

    class BaseLineLayer extends Layer {
      
      constructor(firstPixelId) {
        super(firstPixelId);
        this.hasArrowLeft = modeMaster.has("arrow-left");
        this.hasArrowRight = modeMaster.has("arrow-right");
        this.keepArrowEnd = null;
        this.keepArrowStart = null;
      }

      static drawingMouseOverEvent(event) {
        let layer = layerManager.getLatestLayer();
        layerManager.refresh(() => layer.drawLayer(event.target.id));
        layerManager.findJoints([layer]);
      }

      static resizingMouseOverEvent(event) {
        let layer = layerManager.getSelectedLayers()[0];
        layerManager.refresh(() => layer.drawLayer(event.target.id));
        layerManager.findJoints([layer]);
      }

      static drawMouseOver(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        for (var layer of layerManager.layers) {
          for (var jointPixel of layer.getJointPixels()) {
            if (activePixel.isNear(jointPixel)) {
              jointPixel.renderJointNear();
            } else if (layer.isSelected()) {
              jointPixel.renderSelected();
            } else {
              jointPixel.renderNormal();
            }
          }
        }
      }

      getEndPixels() {
        if (this.pixels.length > 0) {
          return [this.pixels[0], this.getLastPixel()]; 
        }
        return [];
      }

      getResizePixels() {
        return this.getEndPixels(); 
      }

      getResizeFirstPixel(pixel) {
        let resizePixels = this.getResizePixels();
        if (pixel.is(resizePixels[0])) return resizePixels[1];
        if (pixel.is(resizePixels[1])) return resizePixels[0];
      }

      probeJoin(layer, jointIndex, jointPixel) {
          var state = 0;
          for (var lineEndPixel of this.getEndPixels()) {
            if (lineEndPixel.isNear(jointPixel)) {
              state = 1;
              if (jointPixel.is(lineEndPixel)) {
                state = 2;
                layer.join(this.id, jointIndex);
                // Break to avoid unjoining in the following iteration.
                break;
              }
            }
          layer.unjoin(this.id, jointIndex);
        }
        return state
      }

      getFromToPixels(activePixel) {
        let lastPixel = this.getLastPixel();
        let firstPixel = this.getFirstPixel();
        var fromPixel = firstPixel;
        var toPixel = activePixel;
        if (this.pixels.length) {
          if (this.firstTouchedPixel.is(firstPixel)) {
            fromPixel = firstPixel;
            toPixel = activePixel;
          } else  {
            fromPixel = activePixel;
            toPixel = lastPixel;
          }
        }
        return [fromPixel, toPixel];
      }
    }

    class FreeLineLayer extends BaseLineLayer {
      
      name = "free-line"

      static drawMouseDownEvent(event) {
        let layer = new FreeLineLayer(event.target.id);
        layerManager.add(layer);
      }

      drawLayer(activePixelId) {
        
        let activePixel = canvas.getPixelById(activePixelId);
        let [fromPixel, toPixel] = this.getFromToPixels(activePixel);

        let verticalDiff  = toPixel.row - fromPixel.row;
        let lateralDiff   = toPixel.col - fromPixel.col;
        
        var totalSteps   = Math.max(Math.abs(verticalDiff), Math.abs(lateralDiff));
        var verticalStep = verticalDiff / totalSteps;
        var lateralStep  = lateralDiff / totalSteps;

        var colDraw = fromPixel.col;
        var rowDraw = fromPixel.row;

        var value = "x";
        
        if (Math.abs(verticalStep) < 0.3){
          value = this.lateralChar;
        } else if (Math.abs(lateralStep) < 0.5) {
          value = this.verticalChar;
        } else if (toPixel.isLeft(fromPixel) && toPixel.isBelow(fromPixel)) {
          value = "/";
        } else if (toPixel.isRight(fromPixel) && toPixel.isBelow(fromPixel)) {
          value = "\\";
        } else if (toPixel.isLeft(fromPixel) && toPixel.isAbove(fromPixel)) {
          value = "\\";
        } else if (toPixel.isRight(fromPixel) && toPixel.isAbove(fromPixel)) {
          value = "/";
        }
         
        var startValue = value;
        var endValue = value;
        // Once a direction can be determined, work out arrows needed.
        if (this.pixels.length > 3) {
          if (Math.abs(verticalDiff) > Math.abs(lateralDiff)) {
            if (toPixel.isAbove(fromPixel)) {
              endValue = (this.hasArrowLeft || this.keepArrowEnd) ? "^" : value;
              startValue = (this.hasArrowRight || this.keepArrowStart) ? "v" : value;
              if (this.keepArrowEnd == null) {
                this.keepArrowEnd = this.hasArrowLeft;
                this.keepArrowStart = this.hasArrowRight;
              }
            } else {
              endValue = (this.hasArrowLeft || this.keepArrowEnd) ? "v" : value;
              startValue = (this.hasArrowRight || this.keepArrowStart) ? "^" : value;
              if (this.keepArrowEnd == null) {
                this.keepArrowEnd = this.hasArrowLeft;
                this.keepArrowStart = this.hasArrowRight;
              }
            }
          } else{
            if (fromPixel.isLeft(toPixel)) {
              endValue = (this.hasArrowRight || this.keepArrowEnd) ? ">" : value;
              startValue = (this.hasArrowLeft || this.keepArrowStart) ? "<" : value;
              if (this.keepArrowEnd == null) {
                this.keepArrowEnd = this.hasArrowRight;
                this.keepArrowStart = this.hasArrowLeft;
              }
            } else {
              endValue = (this.hasArrowLeft || this.keepArrowEnd) ? "<" : value;
              startValue = (this.hasArrowRight || this.keepArrowStart) ? ">" : value;
              if (this.keepArrowEnd == null) {
                this.keepArrowEnd = this.hasArrowLeft;
                this.keepArrowStart = this.hasArrowRight;
              }
           } 
          }
          this.hasArrowRight = false;
          this.hasArrowLeft = false;
        }
        this.empty();
        for (var i = 0; i <= totalSteps; i ++) {
          this.draw(
            canvas.getPixelByRowCol(roundHalf(rowDraw), roundHalf(colDraw)),
            (i == 0)? startValue: value
          );
          rowDraw += verticalStep;
          colDraw += lateralStep;
        }
        this.draw(this.getLastPixel(), endValue);
      }
    }

    class StepLineLayer extends BaseLineLayer {

      name = "step-line"

      static drawMouseDownEvent(event) {
        let layer = new StepLineLayer(event.target.id);
        layerManager.add(layer);
      }

      drawLayer(activePixelId) {
        let activePixel = canvas.getPixelById(activePixelId);
        let [fromPixel, toPixel] = this.getFromToPixels(activePixel);
        var lateralArrowValue = this.lateralChar;
        var verticalArrowValue = this.verticalChar;
        
        if (toPixel.isAbove(fromPixel)) {
          verticalArrowValue = (this.hasArrowRight) ? "^" : verticalArrowValue;
        } else {
          verticalArrowValue = (this.hasArrowRight) ? "v" : verticalArrowValue;
        }
        if (toPixel.isRight(fromPixel)) {
          lateralArrowValue = (this.hasArrowLeft) ? "<" : lateralArrowValue;
        } else {
          lateralArrowValue = (this.hasArrowLeft) ? ">" : lateralArrowValue;
        }

        let verticalDiff  = toPixel.row - fromPixel.row;
        let lateralDiff   = toPixel.col - fromPixel.col;
          
        var drawCol = fromPixel.col; 
        var drawRow = fromPixel.row;

        this.empty();
        for (var i = 0; i <= Math.abs(lateralDiff); i ++) {
          this.draw(canvas.getPixelByRowCol(fromPixel.row, drawCol), (i == 0)? lateralArrowValue: this.lateralChar);
          drawCol += lateralDiff / Math.abs(lateralDiff);
        }
        for (var i = 0; i <= Math.abs(verticalDiff); i ++) {
          var value = this.verticalChar;
          if (i == Math.abs(verticalDiff)) value = "v";
          this.draw(canvas.getPixelByRowCol(drawRow, toPixel.col), (i == Math.abs(verticalDiff))? verticalArrowValue: this.verticalChar);
          drawRow += verticalDiff / Math.abs(verticalDiff);
        }
      }
    }

    /////////////////////////
    ////// FREE LAYER ///////
    /////////////////////////

    class FreeLayer extends Layer {
      
      name = "free";

      static drawMouseDownEvent(event) {
        let layer = new FreeLayer(event.target.id);
        layerManager.add(layer);
        layerManager.refresh(() => layer.drawFree(event.target.id));
      }

      static drawingMouseOverEvent(event) {
        let layer = layerManager.getLatestLayer();
        layerManager.refresh(() => layer.drawFree(event.target.id));
      }

      drawFree(activePixelId) {
        let activePixel = canvas.getPixelById(activePixelId);
        this.draw(activePixel, "x");
      }
    }

    //////////////////////
    //// SQUARE LAYER ////
    //////////////////////

    class SquareLayer extends Layer {
      
      name = "square" 

      static drawMouseDownEvent(event) {
        let layer = new SquareLayer(event.target.id);
        layerManager.add(layer);
      }

      static drawingMouseOverEvent(event) {
        let layer = layerManager.getLatestLayer();
        layerManager.refresh(() => layer.drawLayer(event.target.id));
      }

      static resizingMouseOverEvent(event) {
        let layer = layerManager.getSelectedLayers()[0];
        layerManager.refresh(() => layer.drawLayer(event.target.id));
      }
      
      getResizePixels() {
        return this.getCornerPixels();
      }

      getJointPixels() {
        let corners = this.getCornerPixels();
        let halfways = this.getHalfwayPixels(corners);
        return corners.concat(halfways);
      }

      getResizeFirstPixel(pixel) {
        let corners = this.getResizePixels();
        let cornerMatch = corners.map(pixel => pixel.id()).indexOf(pixel.id());
        if (cornerMatch == -1) return;
        let firstPixelIndex = cornerMatch + 2;
        if (firstPixelIndex > 3) {
          firstPixelIndex = firstPixelIndex - 4;
        }
        return corners[firstPixelIndex];
      }

      getCornerPixels() {
        if (this.pixels.length == 0) {
          return [];
        }
        var maxCol = -1;
        var minCol = -1;
        var maxRow = -1;
        var minRow = -1;
        for (var pixel of this.pixels) {
          if (pixel.col > maxCol) {
            maxCol = pixel.col;
          }
          if (pixel.col < minCol || minCol == -1) {
            minCol = pixel.col; 
          }
          if (pixel.row > maxRow) {
            maxRow = pixel.row;
          }
          if (pixel.row < minRow || minRow == -1) {
            minRow = pixel.row; 
          }
        }
        return [
          canvas.getPixelByRowCol(minRow, minCol), // Top left
          canvas.getPixelByRowCol(minRow, maxCol), // Top right
          canvas.getPixelByRowCol(maxRow, maxCol), // Bottom right
          canvas.getPixelByRowCol(maxRow, minCol), // Bottom left
        ]
      }

      getHalfwayPixels(corners) {
        if (this.pixels.length == 0) {
          return [];
        }
        let minRow = corners[0].row;
        let maxRow = corners[2].row;
        let minCol = corners[0].col;
        let maxCol = corners[2].col;

        let halfwayRow = parseInt((maxRow - minRow) / 2);
        let halfwayCol = parseInt((maxCol - minCol) / 2);

        return [
          canvas.getPixelByRowCol(minRow + halfwayRow, minCol),
          canvas.getPixelByRowCol(minRow + halfwayRow, maxCol),
          canvas.getPixelByRowCol(maxRow, minCol + halfwayCol),
          canvas.getPixelByRowCol(minRow, minCol + halfwayCol),
        ]
      }

      drawLayer(activePixelId) {
        let originalJoints = this.getJointPixels();
        this.empty();
        let activePixel = canvas.getPixelById(activePixelId);
        if (activePixel.isAbove(this.firstTouchedPixel)) {
          for(var row = this.firstTouchedPixel.row; row >= activePixel.row; row --) {
            this.draw(canvas.getPixelByRowCol(row, this.firstTouchedPixel.col), this.verticalChar);
            this.draw(canvas.getPixelByRowCol(row, activePixel.col), this.verticalChar);
          }
        } else if (activePixel.isBelow(this.firstTouchedPixel)) {
          for(var row = this.firstTouchedPixel.row; row <= activePixel.row; row ++) {
            this.draw(canvas.getPixelByRowCol(row, this.firstTouchedPixel.col), this.verticalChar);
            this.draw(canvas.getPixelByRowCol(row, activePixel.col), this.verticalChar);
          }
        }
        if (activePixel.isLeft(this.firstTouchedPixel)) {
          for(var col = this.firstTouchedPixel.col; col >= activePixel.col; col --) {
            this.draw(canvas.getPixelByRowCol(this.firstTouchedPixel.row, col), this.lateralChar);
            this.draw(canvas.getPixelByRowCol(activePixel.row, col), this.lateralChar);
          }
        } else if (activePixel.isRight(this.firstTouchedPixel)) {
          for(var col = this.firstTouchedPixel.col; col <= activePixel.col; col ++) {
            this.draw(canvas.getPixelByRowCol(this.firstTouchedPixel.row, col), this.lateralChar);
            this.draw(canvas.getPixelByRowCol(activePixel.row, col), this.lateralChar);
          }
        }
        this.moveJointLayers(originalJoints);
      } 
    }

    ////////////////
    //// PIXEL /////
    ////////////////

    class Pixel {
      constructor(size, widthDivider, row, col) {
        this.row = row;
        this.col = col;
        this.size = size;
        this.widthDivider = widthDivider;
        this.defaultColor = "#ffffff";
        this.defaultBgColor = "transparent";
        this.defaultBorder = "none";
        this.cursorFlashInterval = null;
      }
      
      id() {
        return Pixel.makeId(this.row, this.col);
      }

      is(pixel) {
        return this.id() == pixel.id();
      }

      static makeId(row, col) {
        return `pixel-${row},${col}`
      }

      setValue(value) {
        this.element.innerHTML = value;
      }

      renderSelected() {
        this.setColor("blue");
      }

      renderResizable() {
        this.setBgColor("red");
      }
      
      renderAreaSelected() {
        this.setBgColor("#14005e");
      }
      
      renderJoint() {
        this.setBgColor("pink");
      }

      renderJointNear() {
        this.setBgColor("green");
      }

      renderCursor() {
        this.renderNormal();
        this.element.style.borderRight = "1px solid orange";
        setTimeout((pixel) => {
          pixel.element.style.borderRight = "none";
        }, 500, this);
        this.cursorFlashInterval = setInterval(
            (pixel) => {
              this.element.style.borderRight = "1px solid orange";
              setTimeout(() => {
                pixel.element.style.borderRight = "none";
              }, 500);
            }, 1000, this);
      }

      renderFocus() {
        this.setBgColor("orange");
      }

      renderNormal() {
        clearInterval(this.cursorFlashInterval);
        this.setColor(this.defaultColor);
        this.setBgColor(this.defaultBgColor);
        this.element.style.border = "none";
      }

      setColor(color) {
        this.element.style.color = color;
      }

      setBgColor(color) {
        this.element.style.backgroundColor = color;
      }


      clear() {
        this.setValue(" ");
        this.renderNormal();
      }

      isAbove(pixel) {
        return this.row < pixel.row;
      }

      isBelow(pixel) {
        return this.row > pixel.row;
      }

      isLeft(pixel) {
        return this.col < pixel.col;
      }

      isRight(pixel) {
        return this.col > pixel.col;
      }

      isNear(pixel, distance=6) {
        return (
          Math.abs(pixel.row - this.row) <= distance &&
          Math.abs(pixel.col - this.col) <= distance
        )
      }

      isClosestTo(pixels) {
        var closestPixel;
        var minDistance = -1;
        for (var pixel of pixels) {
          let distance = Math.abs(pixel.row - this.row) + Math.abs(pixel.col - this.col);
          if (distance < minDistance || minDistance == -1) {
            closestPixel = pixel;
            minDistance = distance;
          }
        }
        return closestPixel;
      }

      render(parent) {
        this.element = document.createElement("div");
        this.element.className = "pixel";
        this.element.id = this.id();
        this.element.style.position = "absolute";
        this.renderNormal();
        //this.element.style.border = "1px solid black";
        this.element.style.marginLeft = `${this.col * this.size * this.widthDivider}px`;
        this.element.style.marginTop = `${this.row * this.size}px`;
        this.element.style.height = `${this.size}px`;
        this.element.style.width = `${this.size * this.widthDivider}px`;
        this.setValue(" ");
        parent.appendChild(this.element);
      }
    }

    ////////////////
    //// CANVAS ////
    ////////////////

    class Canvas {
      
      rowCount = 60;
      colCount = 160;

      pixelSize = 14;
      pixelWidthDivider = 0.6;

      constructor() {
        this.pixels = {};
      }

      getPixelById(id) {
        return this.pixels[id];
      }

      getPixelByRowCol(row, col) {
        return this.getPixelById(Pixel.makeId(row, col));
      }
      
      clearPixels(pixels) {
        pixels.forEach((pixel) => pixel.clear());
      }

      clear() {
        for(var pixel in this.pixels) this.pixels[pixel].clear();
      }

      render() {
        this.element = document.getElementById("canvas");
        this.element.style.width  = `${this.colCount * this.pixelSize * this.pixelWidthDivider}px`;
        this.element.style.height = `${this.rowCount * this.pixelSize}px`;
        this.element.style.fontSize = `${this.pixelSize}px`;
        this.element.style.fontFamily = `monospace`;
        for (var row = 0; row < this.rowCount; row++) {
          for (var col = 0; col < this.colCount; col++) {
            let pixel = new Pixel(this.pixelSize, this.pixelWidthDivider, row, col);
            pixel.render(this.element);
            this.pixels[pixel.id()] = pixel;
          }
        }
      }
    }

    //////////////
    //// MENU ////
    //////////////
    
    class MenuButton {
      
      constructor (name, showCondition, setModes, activeModes, callback=()=>{}) {
        /*
        name: display name of the button
        showCondition: A ModeMaster condition that gets checked every Menu.refresh
          call to show/hide the button.
        setModes: A ModeMaster update command when the button is pressed.
        activeModes: A ModeMaster condition to choose if the button is selected.
        callback: A function callback on press.
        */
        this.name = name;
        this.showCondition = modeMaster.makeFunc(showCondition);
        this.callback = callback;
        this.setModes = modeMaster.makeFunc(setModes);
        this.activeModes = activeModes;

        this.defaultButtonColor = "black";
        this.defaultSelectedButtonColor = "blue";
      }
      
      onPress() {
        this.callback();
        this.setModes();
      }

      render(parent) {
        this.element = document.createElement("button");
        this.element.innerHTML = this.name;
        this.element.addEventListener("mousedown", () => this.onPress());
        parent.appendChild(this.element);
      }

      hide() {
        this.element.style.display = "none";
      }

      show() {
        this.element.style.display = "block";
      }

      unselect() {
        this.element.style.backgroundColor = this.defaultButtonColor; 
      }

      select() {
        this.element.style.backgroundColor = this.defaultSelectedButtonColor; 
      }

      isActive() {
        return this.activeModes.length && modeMaster.hasOr(...this.activeModes);
      }
    }

    class Menu {
      buttons = [
        new MenuButton("Draw Square",
          [], [modeMaster.reset, "draw", "square", "dsbutton"], ["dsbutton"], () => layerManager.unselectAll()),
        new MenuButton("Text",
          [], [modeMaster.reset, "draw", "text", "dtbutton"], ["dtbutton"], () => layerManager.unselectAll()),
        new MenuButton("Draw Line",
          [], [modeMaster.reset, "draw", "line", "free-line", "dflbutton"], ["dflbutton"], () => layerManager.unselectAll()),
        new MenuButton("Draw Step Line", 
          [], [modeMaster.reset, "draw", "line", "step-line", "dslbutton"], ["dslbutton"], () => layerManager.unselectAll()),
        new MenuButton("Draw Free",
          [], [modeMaster.reset, "draw", "free", "dfbutton"], ["dfbutton"], () => layerManager.unselectAll()),
        new MenuButton("Erase Free",
          [], [modeMaster.reset, "erase", "ebutton"], ["ebutton"], () => layerManager.unselectAll()),
        new MenuButton("Select",
          [], [modeMaster.reset, "select"], ["selected", "select"]),
        new MenuButton("Undo",
          [], [], [], () => layerManager.undoEvent()),
        new MenuButton("Redo",
          [], [], [], () => layerManager.redoEvent()),
        new MenuButton("Restart",
          [], [], [], () => layerManager.refresh(() => layerManager.empty())),
        new MenuButton("Copy",
          [modeMaster.has, "selected"], [], [], () => layerManager.copySelectedLayersEvent()),
        new MenuButton("Group",
          [modeMaster.has, "selected"], [], [], () => layerManager.groupSelectedLayersEvent()),
        new MenuButton("Ungroup",
          [modeMaster.has, "selected"], [], [], () => layerManager.ungroupSelectedLayersEvent()),
        new MenuButton("Delete",
          [modeMaster.has, "selected"], [modeMaster.reset, "select"], [], () => layerManager.deleteLayersEvent()),
        new MenuButton("<",
          [modeMaster.has, "draw", "line"], [modeMaster.toggle, "arrow-left"], ["arrow-left"]),
        new MenuButton(">",
          [modeMaster.has, "draw", "line"], [modeMaster.toggle, "arrow-right"], ["arrow-right"]),
      ] 
      
      constructor() {
        this.id = "menu";
        this.element = document.getElementById(this.id);
        modeMaster.registerCallback(() => menu.refresh());
      }
      
      unselectAll() {
        this.buttons.forEach(button => button.unselect());
      }

      refresh() {
        for (var button of this.buttons) {
          button.hide();
          button.unselect();
        }
        for (var button of this.buttons) {
          if (button.showCondition()) button.show();
          if (button.isActive()) button.select();
        }
      }

      render() {
        for (var button of this.buttons) button.render(this.element);
        this.refresh();
      }
    }
    
    
    // MANAGERS
    modeMaster = new ModeMaster();
    layerManager = new LayerManager();
    areaSelectManager = new AreaSelectManager();
    eventManager = new EventManager();
    
    // COMPONENTS
    menu = new Menu();
    canvas = new Canvas();

    menu.render();
    canvas.render();
    
    // EVENT ASSIGNMENT
    eventManager.assignAll(
      {window: window, document: document, canvas: canvas.element}
    );

    </script>
  </body>
</html>
