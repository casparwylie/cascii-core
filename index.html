<html>
  <head>
    <style>
      body {
        background: white;
        margin: 0;
        font-family: monospace;
      }
      #canvas {
        background: white;
        user-select: none;
      }

      #menu {
        height: 60px;
        margin: 0;
      }

      #menu button {
        font-family: monospace;
        padding: 10px;
        margin-left: 10px;
        margin-top: 10px;
        height: 40px;
        color: white;
        border: 1px solid #212121;
        box-shadow: 0px 0px 20px #403f3f;
        border-radius: 15px;
        float: left;
      }
    </style>
  </head>
  <body>
    <div id="menu"></div>
    <div id="canvas"></div>

  <script defer>
    /*

    *** TODO ***
    
    FE  -

      - various todos
      - COPY zindex
      - check diamond behavioru for multi resize.
      - TextLayer activepixel for drawLayer /redraw - ensure consistent params for drawLayer
      - export 
      - diamond layers
      - z-index concepting: renderPixel funcs stack prio,
          groups prio same z-index (resize table new textlayers are off)
          easy way to ensure arrow heads are seen on joins that aren't outter 
          make joint pixels x / nicer
      - char manager: better redraw logic all around, unicode v ascii switch, line options. 
      - consider defaulting to select mode after draw
      - cmd v ctrl for Mac
      - improve diagonals - filler lines, unicode chars?
      - mini success messages
      - clever resize: text in boxes main issue
      - resize improvements: resize by % to avoid reverse
      - file break up?
      - import :)
      - clever free draw straight chars
      - proper design / config
      - themes
      - intro / why ascii
      - manual page. shortcuts, etc.

    BE -

      - save, share, manage, user, login google + github,  CRUD
      - guest auto save (refresh keeps)
      - plain text request / curl

    IMPROVEMENTS:
      - copy layers with joints by canvas boundry will break joint.

    */

    var layerManager;
    var eventManager;
    var areaSelectManager;
    var modeMaster;
    var charManager;

    var menu;
    var canvas;

    const KEYS = {
      "up"      : 38,
      "right"   : 39,
      "down"    : 40,
      "left"    : 37,

      "shift"   : 16,
      "back"    : 8,
      "delete"  : 46,
      "esc"     : 27,
      "ctrl"    : 17,
      "enter"   : 13,

      "z"       : 90,
      "c"       : 67,
      "g"       : 71,
      "a"       : 65,
    }

    const ArrowKeyGroup = ["up", "down", "left", "right"];

    //////////////////
    ////// UTILS /////
    //////////////////
    
    function reportError(message) {
      console.log(message);
    }

    function debugError(message) {
      console.log(`[DEBUG]: ${message}`);
    }
    
    function roundHalf(value) {
      return parseInt(Math.round(value / 0.5) * 0.5);
    } 

    function roundUp(value) {
      return parseInt(Math.ceil(value));
    } 

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function sum(arr) {
      return arr.reduce((a, b) => a + b, 0);
    }

    function keyGroup(...names) {
      let keys = names.map(name => KEYS[name].toString());
      return keys.join(",");
    }

    //////////////////
    ////// MODES /////
    //////////////////

    class ModeMaster {

      layerModes = [
        "square",
        "free",
        "free-line",
        "step-line",
        "switch-line",
        "line",
        "text",
        "table"
      ];

      constructor(layerTypes) {
        this._modes = [];
        this.callbacks = [];
      }

      registerCallback(func) {
        this.callbacks.push(func);
      }
      
      modeChangedCallback() {
        for (var func of this.callbacks) func();
      }

      makeFunc(instruction) {
        // This just gives dispatchers a prettier notation... 
        // e.g () => modeMaster.has("x", "y") becomes [modeMaster.has, "x", "y"]
        return (instruction.length)? instruction[0].bind(this, ...instruction.slice(1)): () => true;
      }

      change(beforeMode, afterMode) {
        let index = this._modes.indexOf(beforeMode);
        if (index == -1) return;
        this._modes[index] = afterMode;
        this.modeChangedCallback();
      }

      toggle(mode) {
        if (this.has(mode)) {
          this.remove(mode);
        } else {
          this.add(mode);
        }
      }

      remove(...modes) {
        modes.forEach((mode) => {
          let index = this._modes.indexOf(mode);
          if (index == -1) return; 
          this._modes.splice(index, 1);
        });
        this.modeChangedCallback();
      }

      reset(...modes) {
        this._modes = modes;
        this.modeChangedCallback();
      }

      add(...modes) {
        this._modes = this._modes.concat(modes);
        this.modeChangedCallback();
      }

      has(...modes) {
        return modes.map((mode) => this._modes.includes(mode)).every(Boolean);
      }

      hasOr(...modes) {
        return modes.map((mode) => this._modes.includes(mode)).some(Boolean);
      }

      is(...modes) {
        return this._modes.toString() == modes.toString(); 
      }
      
      removeLayers() {
        this.layerModes.forEach(mode => this.remove(mode));
      }

      setLayer(name) {
        this.removeLayers();
        this.add(name);
        if (name.includes("line")) this.add("line");
      }
    }

    ////////////////
    //// EVENTS ////
    ////////////////



    class EventDef {
      constructor(modeCondition, modeUpdate, callback=()=>{}) {
        this.callback = callback;
        this.condition = modeMaster.makeFunc(modeCondition);
        this.update = modeMaster.makeFunc(modeUpdate);
      }
      
      run(event) {
        if (this.condition()) {
          this.update();
          this.callback(event);
          console.log(modeMaster._modes);
          return true;
        }
      }
    }
    
    class EventManager {
      MAP = {
        document: {
          keyEvents: {
            keypress: {
              "*": [
                new EventDef([modeMaster.has, "writing", "text"], [], TextLayer.keyDownEvent),
              ],
            },
            keydown: {
              [keyGroup(...ArrowKeyGroup)]: [
                new EventDef([modeMaster.has, "selected"],
                    [], (event) => layerManager.selectedArrowKeyDownEvent(event)),
              ],                                                                        
              [keyGroup("shift")]: [
                new EventDef([], 
                    [modeMaster.add, "shift"])
              ],
              [keyGroup("back", "delete")]: [
                new EventDef([modeMaster.has, "selected"],
                    [modeMaster.reset, "select"], () => layerManager.deleteLayersEvent()),
              ],
              [keyGroup("esc")]: [
                new EventDef([modeMaster.has, "selected"],
                    [modeMaster.reset, "select"], () => layerManager.unselectAll()),
              ],
              [keyGroup("back", "delete", ...ArrowKeyGroup)]: [
                new EventDef([modeMaster.has, "writing", "text"],
                    [], TextLayer.keyDownEvent),
              ],
              [keyGroup("ctrl")]: [
                new EventDef([],
                    [modeMaster.add, "ctrl"]),
              ],
              [keyGroup("z")]: [
                new EventDef([modeMaster.has, "shift", "ctrl"],
                    [], () => layerManager.redoEvent()),
                new EventDef([modeMaster.has, "ctrl"], 
                    [], () => layerManager.undoEvent()),
              ],
              [keyGroup("c")]: [
                new EventDef([modeMaster.has, "ctrl", "selected"],
                    [], () => layerManager.copySelectedLayersEvent()),
              ],
              [keyGroup("a")]: [
                new EventDef([modeMaster.has, "ctrl"],
                    [modeMaster.reset, "selected"], (event) => layerManager.selectAllEvent(event)),
              ],
              [keyGroup("g")]: [
                new EventDef([modeMaster.has, "selected"],
                    [], () => layerManager.groupSelectedLayersEvent()),
              ],
            },
            keyup: {
              "*": [
                new EventDef([modeMaster.has, "writing", "text"], [], () => layerManager.tidyLayers()),
              ],
              [keyGroup("shift")]: [
                new EventDef([modeMaster.has, "shift"],
                    [modeMaster.remove, "shift"]),
              ],
              [keyGroup("ctrl")]: [
                new EventDef([modeMaster.has, "ctrl"],
                    [modeMaster.remove, "ctrl"]),
              ],
            }
          }
        },
        window: {
          mouseEvents: {
            mouseup: [
              new EventDef([modeMaster.has, "drawing"],
                  [modeMaster.change, "drawing", "draw"], () => layerManager.tidyLayers()), 
              new EventDef([modeMaster.has, "erasing"],
                  [modeMaster.change, "erasing", "erase"]),
              new EventDef([modeMaster.has, "moving"],
                  [modeMaster.remove, "moving"], () => layerManager.tidyLayers()),
              new EventDef([modeMaster.has, "area-selecting"],
                  [modeMaster.remove, "area-selecting"], (event) => areaSelectManager.areaSelectingMouseUpEvent(event)),
              new EventDef([modeMaster.has, "resizing"],
                  [modeMaster.remove, "resizing"], () => layerManager.tidyLayers()),
            ],
          }
        }, 
        canvas: {
          mouseEvents: {
            mousedown: [
              new EventDef([modeMaster.has, "draw", "text"],
                  [modeMaster.change, "draw", "writing"], TextLayer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "draw", "free-line"],
                  [modeMaster.change, "draw", "drawing"], FreeLineLayer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "draw", "step-line"],
                  [modeMaster.change, "draw", "drawing"], StepLineLayer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "draw", "switch-line"],
                  [modeMaster.change, "draw", "drawing"], SwitchLineLayer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "draw", "free"],
                  [modeMaster.change, "draw", "drawing"], FreeLayer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "draw", "square"],
                  [modeMaster.change, "draw", "drawing"], SquareLayer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "draw", "diamond"],
                  [modeMaster.change, "draw", "drawing"], DiamondLayer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "draw", "table"],
                  [modeMaster.change, "draw", "drawing"], TableLayer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "writing", "text"],
                  [], TextLayer.writingMouseDownEvent),
              new EventDef([modeMaster.has, "erase"],
                  [modeMaster.change, "erase", "erasing"], (event) => layerManager.erasePixelEvent(event)),
              new EventDef([modeMaster.hasOr, "selected", "select"], 
                  [], Layer.selectMouseDownEvent),
            ],
            mouseover: [
              new EventDef([modeMaster.has, "draw", "line"], // Technically this should be for any joiner layer...
                  [], BaseLineLayer.drawMouseOver),
              new EventDef([modeMaster.has, "drawing"],
                  [], Layer.drawingMouseOverEvent),
              new EventDef([modeMaster.has, "erasing"],
                  [], (event) => layerManager.erasePixelEvent(event)),
              new EventDef([modeMaster.has, "area-selecting"],
                  [], (event) => areaSelectManager.areaSelectingMouseOverEvent(event)),
              new EventDef([modeMaster.has, "moving"],
                  [], (event) => layerManager.movingMouseOverEvent(event)),
              new EventDef([modeMaster.has, "resizing"],
                  [], (event) => layerManager.resizingMouseOverEvent(event)),
              new EventDef([modeMaster.hasOr, "selected", "select"],
                  [], (event) => layerManager.selectMouseOverEvent(event)),
            ],
            dblclick: [
              new EventDef([modeMaster.has, "selected", "text"],
                  [modeMaster.change, "selected", "writing"], TextLayer.selectedDoubleClickEvent),
              new EventDef([modeMaster.has, "writing"],
                  [], TextLayer.selectedDoubleClickEvent),
            ]
          }
        }
      }

      assignMouseEventDefs(element, allDefs) {
        for (const [eventType, defs] of Object.entries(allDefs)) {
          element.addEventListener(eventType, (event) => {
            for (var def of defs) if (def.run(event)) return;
          })
        }
      }

      assignKeyEventDefs(element, defs) {
        Object.keys(defs).forEach((eventType) => {
          element.addEventListener(eventType, (event) => {
            for (var keys in defs[eventType]) {
              keys.split(",").forEach(key => {
                if (key == event.keyCode.toString() || key == "*") {
                  for (var def of defs[eventType][keys]) {
                    if (def.run(event)) return;
                  }
                }
              });
            }
          });
        });
      } 

      assignAll(namedElements) {
        for (const [elementName, eventGroups] of Object.entries(this.MAP)) {
          for (const [eventGroup, eventDefs] of Object.entries(eventGroups)) {
            switch (eventGroup) {
              case "mouseEvents":
                this.assignMouseEventDefs(namedElements[elementName], eventDefs);
              break;
              case "keyEvents":
                this.assignKeyEventDefs(namedElements[elementName], eventDefs);
              break;
            }
          }
        }
      }
    }
    

    class CharManager {
        
        form = "ascii";
        line = "solid-thin";

        // Useful: https://www.w3.org/TR/xml-entity-names/025.html
        charset = {

          // Dotted lines
          "•": ["dotted", "line", "vertical", "lateral", "unicode"],
          ".": ["dotted", "line", "vertical", "lateral", "ascii"],

          // Solid lines
          "━": ["solid-bold", "line", "lateral", "unicode"],
          "┃": ["solid-bold", "line", "vertical", "unicode"],
          "─": ["solid-thin", "line", "lateral", "unicode"],
          "│": ["solid-thin", "line", "vertical", "unicode"],
          "|": ["solid-thin", "solid-bold", "line", "vertical", "ascii"],
          "\\": ["solid-thin", "solid-bold", "diag-back", "line", "unicode", "ascii"],
          "/": ["solid-thin", "solid-bold", "diag-forward", "line", "unicode", "ascii"],

          // Dashed lines
          "¦": ["dashed", "line", "vertical", "unicode"],
          "'": ["dashed", "line", "vertical", "ascii"],
          "-": ["dashed", "solid-bold", "solid-thin", "line", "lateral", "ascii", "unicode"],

          // Arrows
          "^": ["arrow", "up", "ascii"],
          ">": ["arrow", "right", "ascii"],
          "<": ["arrow", "left", "ascii"],
          "v": ["arrow", "down", "ascii"],
          "▲": ["arrow", "up", "unicode"],
          "▶": ["arrow", "right", "unicode"],
          "◀": ["arrow", "left", "unicode"],
          "▼": ["arrow", "down", "unicode"],

          // Corners 
          "┏": ["corner", "solid-bold", "top-left", "unicode"],
          "┓": ["corner", "solid-bold", "top-right", "unicode"],
          "┗": ["corner", "solid-bold", "bottom-left", "unicode"],
          "┛": ["corner", "solid-bold", "bottom-right", "unicode"],

          "┌": ["corner", "solid-thin", "top-left", "unicode"],
          "┐": ["corner", "solid-thin", "top-right", "unicode"],
          "└": ["corner", "solid-thin", "bottom-left", "unicode"],
          "┘": ["corner", "solid-thin", "bottom-right", "unicode"],

          "+": [
            "corner", "solid-bold", "solid-thin", "dashed",
            "ascii", "unicode", "top-left", "top-right",
            "bottom-left", "bottom-right", "generic"
          ],
    
          // Misc
          "x": ["free"],
        }
        getBestChar(...description) {
          var lastMatches = -1;
          var lastChar = null;
          for (let character in this.charset) {
            let tags = this.charset[character]; 
            let matches = tags.filter(tag => description.includes(tag)).length;
            if (matches > lastMatches) {
              lastMatches = matches;
              lastChar = character;
            }
          }
          return lastChar;
        }

        getDiagBackLine() {
          return this.getBestChar("diag-back", "line", this.form, this.line);
        }

        getDiagForwardLine() {
          return this.getBestChar("diag-forward", "line", this.form, this.line);
        }

        getVerticalLine() {
          return this.getBestChar("vertical", "line", this.form, this.line);
        }

        getLateralLine() {
          return this.getBestChar("lateral", "line", this.form, this.line);
        }

        getArrow (direction) {
          return this.getBestChar("arrow", direction, this.form);
        }

        getCorner(position) {
          return this.getBestChar("corner", position, this.form, this.line);
        }

        getFree() {
          return this.getBestChar("free");
        }
    }


    ////////////////////
    ////// LAYERS //////
    ////////////////////


    class GroupManager {
      constructor() {
        this.layerGroups = [];
      }

      findGroupsFromLayers(layers) {
        /*
          Find groups which are fully included in the provided layers.
          E.g
          Groups = [[1, 2, 3], [5, 6], [4, 5], [1, 2]]
          layers = [1, 2, 3, 4]
            => [[1, 2, 3], [1, 2]]
        */

        var foundGroups = [];
        let layerIds = layers.map(layer => layer.id);
        for (var groupLayerIds of this.layerGroups) {
          if (groupLayerIds.map(layerId => layerIds.includes(layerId)).every(Boolean)) {
            foundGroups.push(groupLayerIds);
          }
        }
        return foundGroups;
      }

      ungroupLayers(layers) {
        let groups = this.findGroupsFromLayers(layers).map(group => group.toString());
        this.layerGroups = this.layerGroups.filter(group => !groups.includes(group.toString()));
      } 
      
      groupLayers(layers) {
        this.layerGroups.push(layers.map(layer => layer.id));
      }
      
      getSiblingLayerIds(memberLayer) {
        var layerIds = [];
        for (var group of this.layerGroups) {
          if (group.includes(memberLayer.id)) layerIds = layerIds.concat(group); 
        }
        return layerIds;
      }

      tidy(layers) {
        var index = 0;
        for (var layerGroup of this.layerGroups) {
          this.layerGroups[index] = layerGroup.filter(layerId => !layers.includes(layerId));
          index ++;
        }

        // Tidy empty / one layer groups 
        this.layerGroups = this.layerGroups.filter(group => group.length > 1);
      }
    }
      

    class AreaSelectManager {
      constructor() {
        this.areaSelectionPixels = [];
      }

      clearAreaSelection() {
        this.areaSelectionPixels.forEach(pixel => pixel.renderNormal());
        this.areaSelectionPixels = [];
      }

      areaSelectingMouseUpEvent(event) {
        this.clearAreaSelection();
        // Re-render selected layers having just cleared pixels.
        layerManager.getSelectedLayers().forEach(layer => layer.renderSelected());
      }
      
      areaSelectingMouseOverEvent(event) {
        this.clearAreaSelection();
        let firstPixel = layerManager.getSelectPixel();

        let activePixel = canvas.getPixelById(event.target.id);
        let lateralDiff = activePixel.col - firstPixel.col;
        let verticalDiff = activePixel.row - firstPixel.row;
        let total = Math.abs(lateralDiff * verticalDiff)

        var drawRow = firstPixel.row;
        var drawCol = firstPixel.col;
        for (var row = 0; row <= Math.abs(verticalDiff); row ++) {
          for (var col = 0; col <= Math.abs(lateralDiff); col ++) {
            let pixel = canvas.getPixelByRowCol(parseInt(drawRow), parseInt(drawCol));
            this.areaSelectionPixels.push(pixel);
            drawCol += lateralDiff / Math.abs(lateralDiff);
          }
          drawRow += verticalDiff / Math.abs(verticalDiff);
          drawCol = firstPixel.col;
        }

        this.selectLayersInAreaSelection();
        this.areaSelectionPixels.forEach(pixel => pixel.renderAreaSelected());
      }

      selectLayersInAreaSelection() {
        let layersToSelect = [];
        for (var layer of layerManager.layers) {
          let layerPixelIds = layer.pixels.map(pixel => pixel.id());
          let selectedPixelIds = this.areaSelectionPixels.map(pixel => pixel.id());
          if (layerPixelIds.filter(pixel => !selectedPixelIds.includes(pixel)).length) {
            if (layer.isSelected()) {
              layer.unselect();
            }
          } else {
            layersToSelect.push(layer);
          }
        }

        if (layersToSelect.length) modeMaster.change("select", "selected");
        for (let layer of layersToSelect) {
          layer.select();
          layerManager.selectGroupsByMemberLayer(layer);
        }
      }
    }

    class LayerManager {
      constructor() {
        this.layers = [];
        this.selectedPixel = null;
        this.layerHistory = [[]];
        this.historyCursor = 0;
        this.editingTextLayer = null;
        this.groupManager = new GroupManager();
      }

      add(layer) {
        this.layers.unshift(layer);
      } 

      addSecond(layer) {
        this.layers.splice(1, 0, layer);
      } 

      getLatestLayer() {
        return this.layers[0];
      }

      hasLayer(layerId) {
        return this.layers.map(layer => layer.id).includes(layerId);
      }

      getLayerById(layerId) {
        for (var layer of this.layers) {
          if (layer.id == layerId) return layer;
        }
      }

      getLayerByPixelId(id) {
        // Descending (reversed)
        for (var layer of this.getLayersOrderedByZindex().reverse()) { 
          if (layer.hasPixel(id)) return layer;
        }
      }

      getSelectedLayers() {
        return this.layers.filter((layer) => layer.isSelected());
      }

      deleteSelectedLayers() {
        this.getSelectedLayers().forEach((layer) => layer.empty()); 
        this.tidyLayers();
      }

      selectGroupsByMemberLayer(memberLayer) {
        let siblingLayerIds = this.groupManager.getSiblingLayerIds(memberLayer);
        siblingLayerIds.forEach(layerId => this.getLayerById(layerId).select());
      }


      undo() {
        let limit = this.layerHistory.length - 1;
        this.historyCursor = (this.historyCursor < limit)? this.historyCursor + 1: limit;
        // Copy historic layers to avoid mutating them now that they're current.
        // Past will otherwise show as present...
        this.layers = this.copyReplaceLayers(this.layerHistory[this.historyCursor]); 
      }

      redo() {
        this.historyCursor = (this.historyCursor > 0)? this.historyCursor - 1: 0;
        // Copy historic layers to avoid mutating them now that they're current.
        // Past will otherwise show as present...
        this.layers = this.copyReplaceLayers(this.layerHistory[this.historyCursor]);
      }

      copyReplaceLayers(layers) {
        return layers.map(layer => layer.copy(true));
      }

      copyAndRenderSelectedLayers() {
        // Copy layers and create a lookup for old to new. This can be used
        // by various functions to update new layers with appropriate relationships
        // and states (given those of old layers). 
        let layerLookup = {};
        let layersToCopy = this.getSelectedLayers();
        for (var layer of layersToCopy) layerLookup[layer.id] = {old: layer, new: layer.copyAndRender()};
        this.moveLayersToAvailableSpace(Object.values(layerLookup).map(oldNewLayer => oldNewLayer.new));

        this.repointJointsForCopiedLayers(layerLookup);
        this.regroupForCopiedLayers(layerLookup);
        this.repointTableTextLayers(layerLookup);
      }

      repointTableTextLayers(layerLookup) {
        // For tables, we must point text layer references to the newly copied text layers.
        // We also ensure new TextLayers point to their new table.
        for (let oldLayerId in layerLookup) {
          let oldLayer = layerLookup[oldLayerId].old;
          let newLayer = layerLookup[oldLayerId].new;
          if (oldLayer.name == "table") {
            for (let cellId in oldLayer.textLayers) {
              let oldTextLayerId = oldLayer.textLayers[cellId];

              // Find the new version of the TextLayer given the old TextLayer ID.
              let newTextLayer = layerLookup[oldTextLayerId].new;
              
              // Give the new TextLayer it's new table reference.
              newTextLayer.tableId = newLayer.id;

              // Give the TableLayer at the corresponding cell it's new TextLayer reference.
              newLayer.textLayers[cellId] = newTextLayer.id;
            }
          }
        }
      }

      regroupForCopiedLayers(layerLookup) {
        // This groups the newly copied layers which were grouped before being copied.
        let layersToCopy = Object.values(layerLookup).map(oldNewLayer => oldNewLayer.old);
        let groupsToCopy = this.groupManager.findGroupsFromLayers(layersToCopy);
        for (var group of groupsToCopy) {
          var newGroup = group.map(layerId => layerLookup[layerId].new);
          this.groupManager.groupLayers(newGroup);
        }
        this.capture();
      }

      repointJointsForCopiedLayers(layerLookup) {
        // This goes through joints of old layers and updates
        // the joint layers to the newly copied joints if they 
        // were included in the copied selection / are in the lookup. 
        for (var oldLayerId in layerLookup) {
          let oldNewLayer = layerLookup[oldLayerId];
          for (var joint of oldNewLayer.old.joints) {

            // Find the new version of the joint layer given the old layer ID.
            let jointOldNewLayer = layerLookup[joint.layerId];

            if (jointOldNewLayer) {
              let newJoint = structuredClone(joint);
              newJoint.layerId = jointOldNewLayer.new.id;
              oldNewLayer.new.joints.push(newJoint);
            }
          }
        }
      }
      
      getNearOverlappingCount(subjectLayer, withNames) {
        /*
        This counts how many pixels from other layers are near
        or overlapping the subjectLayer. withNames can also
        be provided to only worry about specific layer types
        being near/overlapping. This is mainly used to make decisions
        based on how busy a space is.
        */
        var count = 0; 
        for (let layer of this.layers) {
          if (withNames && withNames.includes(layer.name)) {
            count += layer.getNearOverlappingCount(subjectLayer);
          }
        }
        return count;
      }

      unselectAll() {
        this.layers.forEach(layer => layer.unselect());
        modeMaster.removeLayers();
      }

      switchModeCallback() {
        this.unselectAll();
        this.capture();
      }

      refresh(updateFunc) {
        this.clearAll();
        updateFunc();
        this.renderAll();
      }
      
      tidyAllJoints(layersToDelete) {
        for (var layer of this.layers) {
          layer.joints = layer.joints.filter(joint => !layersToDelete.includes(joint.layerId));
          layer.tidyJoints();
        }
      }

      deleteLayers() {
        // Find layer IDs for dereferencing 
        let layersToDelete = this.layers.filter(layer => !layer.pixels.length).map(layer => layer.id);
        
        // Delete empty layers
        this.layers = this.layers.filter(layer => !layersToDelete.includes(layer.id));

        // Delete references to empty layers in groups
        this.groupManager.tidy(layersToDelete);

        // Delete references to empty layers in layer joints
        this.tidyAllJoints(layersToDelete);
      }

      tidyLayers() {
        this.deleteLayers();
        this.capture();
      }

      clearAll() {
        this.layers.forEach((layer) => layer.clear());
      }
      
      getLayersOrderedByZindex() {
        // Ascending
        return this.layers.slice().sort((a, b) => a.zindex - b.zindex);
      }
      renderAll() {
        this.getLayersOrderedByZindex().forEach((layer) => layer.render());
      }

      layerPixelIsVisible(targetLayer, pixel) {
        // This checks if the value of a layer at a specific pixel is actually showing.
        // (Otherwise, a layer on the same pixel is showing it's value first)

        // For each layer, we also check it isn't a joiner to the targetLayer,
        // as that means it's probably only covering the joint pixel, which 
        // we still want to show for other joiners. The edge case that it's a
        // joiner and doesn't properly hide other overlapped pixels is fine.
        let joinerLayers = this.getJoinersFromLayers([targetLayer]);

        // Descending
        for (let layer of this.getLayersOrderedByZindex().reverse()) {
          if (layer.hasPixel(pixel.id()) && !joinerLayers.includes(layer.id)) return layer.id == targetLayer.id;
        }
        return false;
      }

      empty() {
        this.layers = [];
        this.layerHistory = [];
      }

      capture() {
        this.historyCursor = 0;
        this.layerHistory.unshift(this.copyReplaceLayers(this.layers));
      }
      
      setSelectPixel(selectedPixel) {
        this.selectedPixel = selectedPixel;
      }

      getSelectPixel() {
        return this.selectedPixel;
      }
        
      moveLayersAtomically(layers, verticalDiff, lateralDiff) {
        // If multiple layers are selected, they should all move
        // together to avoid breaking joints. If one layer hits
        // the canvas boundary, none should move. Hence, here
        // we ensure all moves are doable before keeping them.
        let committedLayers = [];
        for (let layer of layers) {
          let committed = layer.commit(() => layer.move(verticalDiff, lateralDiff));
          if (!committed) {
            // If a the layer failed to move, then rollback the others that did move.
            committedLayers.forEach(layer => layer.rollback());
            return;
          }
          committedLayers.push(layer);
        }
        // If we are here, all layers have moved, so we can now resize
        // their joiner layers.
        for (let layer of layers) {
          // resizeSelectedJoinerLayers is false here because moving
          // them takes priority, and doing both is error prone. They will move
          // with their joint layer anyway, meaning the joint is persisted.
          // Otherwise, the joiner layer could unjoin because it's moved
          // twice, from the main move routine and the resize joiner layer routine.  
          layer.resizeJoinerLayers(false);
        }
        return true;
      }

      moveSelectedLayers(verticalDiff, lateralDiff) {
        let selectedLayers = this.getSelectedLayers();
        this.refresh(() => this.moveLayersAtomically(selectedLayers, verticalDiff, lateralDiff));
        this.findJoints(selectedLayers);
      }
      
      moveLayersToAvailableSpace(layers) {
        let directions = [[1, 1], [-1, 1], [1, -1], [-1, -1]];
        for (let direction of directions) {
          if(this.moveLayersAtomically(layers, ...direction)) return true;
        }
        return false;
      }

      findJoints(changedLayers) {
        for (var layer of this.layers) {
          if (layer.isSelected()) continue;
          // Only joinable layers will return joint pixels here and therefore get probed.
          let keyedJoints = layer.getKeyedJointPixels(); 
          for (let jointKey in keyedJoints) {
            let jointPixel = keyedJoints[jointKey];
            var renderState = -1;
            for (var probingLayer of changedLayers) {
              if (probingLayer.id == layer.id) continue;
              // Only prober layers will look for joins (e.g lines).
              let state = probingLayer.probeJoint(layer, jointKey, jointPixel); 
              if (state > renderState) renderState = state;
            }
            switch (renderState) {
              case 0:
                jointPixel.renderWasSelected();
              break;
              case 1:
                jointPixel.renderJointNear();
              break;
              case 2:
                jointPixel.renderJoint();
              break;
            }
          } 
        }
      }

      getJoinersFromLayers(layers) {
        var layerIds = [];
        for (var layer of layers) {
          for (var joint of layer.joints) {
            layerIds.push(joint.layerId);
          }
        }
        return layerIds;
      }

      prepareLayerResizing(activePixel, leadLayer) {
        let resizePixelIndex = leadLayer.getResizePixelIndex(activePixel);
        if (resizePixelIndex == -1) return false;
        for (var resizeLayer of this.getSelectedLayers()) {
          if (!resizeLayer.isResizable()) continue;
          var resizePixel;
          if (resizeLayer.id == leadLayer.id) {
            // If the selected layer is the lead / currently selected layer 
            // Then we already know the activePixel is the resize pixel.
            resizePixel = activePixel;
          } else if (resizeLayer.name == leadLayer.name && !leadLayer.name.includes("line")) {
            // If the lead layer is the same type as a selected layer,
            // we can use the same resize pixel position and resize the layer
            // in the same way for the best experience.

            // Lines are excluded because resize positions are subjective to the line
            // depending on where it was drawn from. Using the "nearest" logic is better.
            resizePixel = resizeLayer.getResizePixels()[resizePixelIndex];
          } else {
            // Otherwise, we find the layer's nearest resize pixel and
            // resize from there.
            resizePixel = resizeLayer.getNearestResizePixel(activePixel);
          }

          // The "to" pixel has been determined above depending on various rules. 
          resizeLayer.setToPixel(resizePixel);

          // The resize "from" pixel is the opposite to the active "to" resize pixel
          // determined above. We set it here as the from pixel to mimic
          // the act of drawing it from the first pixel selected.
          let fromResizePixel = resizeLayer.getResizeOppositePixel(resizePixel);
          resizeLayer.setFromPixel(fromResizePixel);
        }
        return true;
      }

      // Generic multi-layer based events...

      resizingMouseOverEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        let layers = this.getSelectedLayers();
        this.refresh(() => this.resizeLayers(layers, activePixel));
        this.findJoints(layers);
      }

      resizeLayers(layers, activePixel) {
        let selectPixel = this.getSelectPixel();
        let verticalDiff = activePixel.row - selectPixel.row;
        let lateralDiff = activePixel.col - selectPixel.col;
        let joinerLayers = this.getJoinersFromLayers(layers);
        
        for (var layer of layers) {
          // Selected layers that are joiners to another selected layer should not
          // get resized, as the joint will handle moving it correctly.
          // Otherwise, the resize is at risk of unexpectly unjoining the layers
          // in question.
          if (joinerLayers.includes(layer.id)) continue;

          // If the layer belongs to a table, resizing should never happen
          // as resizing tables is used to add/remove columns, not move child
          // layers around.
          if (layer.hasTable()) continue; 

          if (!layer.isResizable()) {
            // If the layer is not resizable, the best thing we can do is move it.
            if (layer.commit(() => layer.move(verticalDiff, lateralDiff))) layer.resizeJoinerLayers(true);
            continue;
          }
          /*             
          layer.fromPixel: The "from" pixel for a specific layer (where it should be drawn from)
          layer.toPixel: The pixel the layer should draw to
          selectPixel: The previous activePixel to determine the diff with current activePixel.
                       This pixel starts as wherever the user first pressed.
          activePixel: The actual current pixel of the mouse.

          layer.fromPixel 
              ._________ 
              *        |
              |        |   
              |        |       *.. selectedPixel 
              |        |        \
              |        |         \ .. vertical/lateralDiff
              |________*          \ 
                       .\           * .. activePixel
                       . \  
                       .  \
                       .   * .. layer.toPixel + vertical/lateralDiff
                       .   
                    layer.toPixel

          With both of these determined, the layer can be resized.
          */
          
          // For this layer, the resize pixel is out of bounds.

          let toPixel = canvas.getPixelByRowCol(
            layer.toPixel.row + verticalDiff, layer.toPixel.col + lateralDiff
          );
          if (!toPixel) continue;
          
          // resizeSelectedJoinerLayers is true because layers are changing
          // and selected joiner layers should favour maintaining joints and resizing
          // that way, instead of resizing independently.
          layer.draw(toPixel.id(), true);
        }
        // Note we set selectPixel to activePixel so that the next iteration
        // can diff the new activePixel to this one.
        this.setSelectPixel(activePixel);
      }

      movingMouseOverEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        let lastPixelSelected = this.getSelectPixel();
        let verticalDiff = activePixel.row - lastPixelSelected.row;
        let lateralDiff = activePixel.col - lastPixelSelected.col;
        this.moveSelectedLayers(verticalDiff, lateralDiff);
        this.setSelectPixel(activePixel);
      }
    
      selectedArrowKeyDownEvent(event) {
        var verticalDiff = 0;
        var lateralDiff = 0;
        switch (event.keyCode) {
          case KEYS["up"]:
            verticalDiff = -1;
            break;
          case KEYS["right"]:
            lateralDiff = 1;
            break;
          case KEYS["down"]:
            verticalDiff = 1;
            break;
          case KEYS["left"]:
            lateralDiff = -1;
            break;
        }
        this.moveSelectedLayers(verticalDiff, lateralDiff);
        this.capture();
      }

      deleteLayersEvent(event) {
        this.refresh(() => this.deleteSelectedLayers());
      }

      copySelectedLayersEvent(event) {
        this.refresh(() => this.copyAndRenderSelectedLayers());
      }

      selectMouseOverEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        for (var layer of this.layers) {
          // Avoid showing / unshowing resize pixels as they're
          // already permanently on for selected layers.
          if (layer.isSelected()) continue;
          for (var resizePixel of layer.getResizePixels()) {
            if (activePixel.isNear(resizePixel) && this.layerPixelIsVisible(layer, resizePixel)) {
              resizePixel.renderResizable();
            } else {
              resizePixel.renderWasSelected();
            }
          }
        }
      }

      undoEvent(event) {
        this.refresh(() => this.undo());
      }

      redoEvent(event) {
        this.refresh(() => this.redo());
      }

      groupSelectedLayersEvent(event) {
        this.groupManager.groupLayers(this.getSelectedLayers());
      }

      ungroupSelectedLayersEvent(event) {
        this.groupManager.ungroupLayers(this.getSelectedLayers());
        layerManager.unselectAll();
      }
      
      redrawLinesEvent(direction) {
        for (var layer of this.getSelectedLayers()) {
          if (layer.name.includes("line")) {
            this.refresh(() => layer.toggleArrows(direction));
          }
        }
      }

      selectAllEvent(event) {
        event.preventDefault();
        this.layers.forEach(layer => layer.select());
      }

      erasePixelEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        let layer = this.getLayerByPixelId(activePixel.id());
        if (layer && layer.name != "free") return;
        if (layer) layer.erasePixel(activePixel.id());
        activePixel.clear();
      }

      getHighestZindex() {
        // This ensures the first ever layer is set to 0 given that
        // layers use this method during initialization to determine
        // the next zindex needed.
        if (this.layers.length == 0) return 0;

        return Math.max(...this.getZindexes());
      }

      getZindexes() {
        return this.layers.map(layer => layer.zindex);
      }

      getLowestZindex() {
        return Math.min(...this.layers.map(layer => layer.zindex));
      }

      bringForwardEvent(event) {
        let highestZindex = this.getHighestZindex();
        this.refresh(() => this.getSelectedLayers().forEach(layer =>  layer.zindex ++));
      }

      sendBackwardsEvent(event) {
        let lowestZindex = this.getLowestZindex();
        this.refresh(() => this.getSelectedLayers().forEach(layer => layer.zindex --));
      }

      bringToFrontEvent(event) {
        let highestZindex = this.getHighestZindex();
        this.refresh(() => this.getSelectedLayers().forEach(layer => layer.zindex = highestZindex + 1));
      }

      sendToBackEvent(event) {
        let lowestZindex = this.getLowestZindex();
        this.refresh(() => this.getSelectedLayers().forEach(layer => layer.zindex = lowestZindex - 1));
      }
    }
    
    
    class Layer {

      lateralChar = charManager.getLateralLine();
      verticalChar = charManager.getVerticalLine();
      diagBackChar = charManager.getDiagBackLine();
      diagForwardChar = charManager.getDiagForwardLine();
      cornerTopLeftChar = charManager.getCorner("top-left");
      cornerTopRightChar = charManager.getCorner("top-right");
      cornerBottomLeftChar = charManager.getCorner("bottom-left");
      cornerBottomRightChar = charManager.getCorner("bottom-right");
      cornerGenericChar = charManager.getCorner("generic");
      arrowUpChar    = charManager.getArrow("up");
      arrowDownChar  = charManager.getArrow("down");
      arrowLeftChar  = charManager.getArrow("left");
      arrowRightChar = charManager.getArrow("right");

      constructor(firstPixelId) {
        this.id = this.makeId();
        this.pixels = [];
        this.values = [];
        this.joints = [];
        this.stashed = null;
        this.zindex = layerManager.getHighestZindex() + 1;
        this._isSelected = false;
        
        this.setToPixel(null) // This gets set when drawing begins;
        this.setFromPixel(canvas.getPixelById(firstPixelId));
      }

      makeId() {
        return randomInt(1, 100000).toString() + Date.now().toString();
      }

      static drawingMouseOverEvent(event) {
        let layer = layerManager.getLatestLayer();
        layerManager.refresh(() => layer.draw(event.target.id));
        layerManager.findJoints([layer]);
      }
      
      static selectMouseDownEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        let layer = layerManager.getLayerByPixelId(activePixel.id());
        let selectedLayers = layerManager.getSelectedLayers();
        layerManager.setSelectPixel(activePixel);
        // Unselect all if...
        // 1. clicked-off (no layer selected)
        // 2. Single select mode (not multi) and alternative layer picked. 
        if (!layer || (!modeMaster.has("shift") && !layer.isSelected())) {
          layerManager.unselectAll();
          modeMaster.change("selected", "select");
        }
        if (!layer) {
          modeMaster.add("area-selecting");
          return;
        }
        layerManager.refresh(() => layer.select());
        modeMaster.change("select", "selected");
        modeMaster.setLayer(layer.name);
        modeMaster.add(
          layerManager.prepareLayerResizing(activePixel, layer)? "resizing": "moving"
        );
        if (!modeMaster.has("ctrl") || layer.name == "table" || layer.hasTable()) {
          // Select all members of a group if not bypassed by ctrl to select a grouped
          // layer.
          // This bypass shouldn't work for tables / table children to avoid undefined behaviour.
          layerManager.refresh(() => layerManager.selectGroupsByMemberLayer(layer));
        }
      }

      draw(activePixelId) {
        let committed = this.commit(() => this.drawLayer(activePixelId));
        if (committed && this.isJoinable()) this.resizeJoinerLayers(true);
      }
      
      isHappy() {
        // Anything that doesn't satisfy this condition will cause a rollback.
        // Currently, it just ensures pixels are valid, but it could be anything,
        // and extending this in specific layers is welcomed.
        return (this.pixels.every(Boolean) && this.getJointPixels().every(Boolean));
      }

      commit(updateFunc) {
        // Committing is used to trial ANY pixel/value changes of a layer.
        // The draw/move functions might recommend pixels that are out of bounds,
        // or in whatever way invalid. If the commited change (updateFunc)
        // results in an 'unhappy' state, we rollback to the stashed pixel related states.
        this.lastKeyedJointPixels = this.getKeyedJointPixels();
        this.stash();
        updateFunc();
        let isHappy = this.isHappy();
        if (!isHappy) this.rollback();
        return isHappy;
      }

      stash() {
        // This is used to store / remember a layer's pixels and values
        // in case a layer becomes unhappy.
        this.stashed = [this.fromPixel, this.toPixel, this.pixels.map(p => p), this.values.map(v => v)];
      }

      rollback() {
        // Uses stashed pixels/values and restores them to active state.
        [this.fromPixel, this.toPixel, this.pixels, this.values] = this.stashed;
      }
      
      redraw() {
        this.draw(this.toPixel.id());
      }

      select() {
        this._isSelected = true;
        this.renderSelected();
      }

      unselect() {
        this._isSelected = false;
        this.renderUnselected();
      }

      setToPixel(pixel) {
        this.toPixel = pixel;
      }

      setFromPixel(pixel) {
        this.fromPixel = pixel;
      }

      getLastPixel() {
        return (this.pixels.length)? this.pixels[this.pixels.length - 1]: this.fromPixel;
      }

      getMiddlePixel() {
        return (this.pixels.length)? this.pixels[roundHalf(this.pixels.length / 2)]: this.fromPixel;
      }

      getFirstPixel() {
        return (this.pixels.length)? this.pixels[0]: this.fromPixel;
      }

      add(pixel, value) {
        if (!pixel) return;
        let existingPixelIndex = this.getPixelIndex(pixel.id());
        if (existingPixelIndex == -1) {
          this.pixels.push(pixel);
          this.values.push(value);
        } else {
          this.values[existingPixelIndex] = value;
        }
        if (this.pixels.length != this.values.length) {
          console.log(`layer pixel/value mismatch: ${this.pixels} != ${this.values}`)
        }
      }
      
      getJointPixels() {
        return Object.values(this.getKeyedJointPixels());
      }
      
      // Implement if the shape can be joined to - a "joint" layer.
      // The keys should meaningful reflect the same part of a layer.
      // E.g the key "tl" should always represent the top left
      // corner pixel of a square.
      getKeyedJointPixels() {
        return {};
      }
      
      // Implement if the layer can join to another (e.g a line - a "joiner" layer)
      getJoinerPixels() {
        return [];
      }

      // Implement if the layer can be resized.
      // This will determine which pixels can be used to
      // resize a layer.
      getResizePixels() { 
        return [];
      } 

      // Implement if the layer can be resized.
      // This will determine which pixel to resize from, 
      // given a resize point. 
      getResizeOppositePixel() {
        return false;
      }
  
      hasTable() {
        return Boolean(this.tableId);
      }

      isResizable() {
        return Boolean(this.getResizePixels().length);
      }

      isJoinable() {
        return Boolean(this.getJointPixels().length);
      }

      getNearestResizePixel(pixel) {
        return pixel.isNearestTo(this.getResizePixels());
      }

      getResizePixelIndex(targetPixel) {
        return this.getResizePixels().map(pixel => pixel.id()).indexOf(targetPixel.id());
      }

      clear() {
        this.pixels.forEach((pixel) => pixel.clear());
      }

      tidyJoints() {
        // TODO consider requirement here
        let keyedJoints = this.getKeyedJointPixels();
        for (let joint of this.joints) {
          let layer = layerManager.getLayerById(joint.layerId);
          if (layer) {
            let jointPixel = keyedJoints[joint.jointKey];
            if (jointPixel) {
              let state = layer.probeJoint(this, joint.jointKey, jointPixel);
              if (state == 2) {
                continue;
              } else {
                // This should not happen.
                alert("had to unjoin dangling join: somehow disconnected");
              }
            } else {
              // This should not happen
              // - originally for tables only but they get unjoined now (when rows/cols are removed).
              alert("had to unjoin dangling join: joint pixel gone");
            }
          } else {
            // This should not happen because joints get deleted when layers do.
            alert("had to unjoin dangling join: join layer gone");
          }
          this.unjoin(joint.layerId, joint.jointKey);
        }
      }

      copy(replace=false) {
        let layerCopy = new this.constructor(this.fromPixel.id());
        if (replace) {
          // This is an exact copy, mainly used for capturing snapshots,
          // reverting history.
          // We only copy joints here, as other use cases need to manually
          // repoint joints to new layers.
          layerCopy.joints = this.joints.map(joint => structuredClone(joint));
          layerCopy.id = this.id;
        } 
        layerCopy.setFromPixel(this.fromPixel);
        layerCopy.setToPixel(this.toPixel);
        layerCopy.pixels = this.pixels.map(pixel => pixel);
        layerCopy.values = this.values.map(value => value);
        return layerCopy;
      }
      
      copyAndRender() {
        let layerCopy = this.copy();
        layerManager.add(layerCopy); 
        this.unselect();
        layerCopy.select();
        return layerCopy;
      }

      getNearOverlappingCount(targetLayer) {
        // Gets the amount of pixels which are common / the same (the amount of overlap).
        // Or, nearly the same by 1 pixel in any direction.
        var total = 0;
        if (targetLayer.id == this.id) return 0;
        let layerPixelIds = this.pixels.map(pixel => pixel.id());
        let directions = [[0, 0], [1, 1], [-1, 1], [1, -1], [-1, -1]];
        for (let direction of directions) {
          total += targetLayer.getMove(...direction).filter(
            pixel => pixel && layerPixelIds.includes(pixel.id())
          ).length
        }
        return total;
      }
      
      renderUnselected() {
        this.pixels.forEach((pixel) => pixel.renderUnselected());
      }

      renderSelected() {
        this.getJointPixels().forEach(pixel => pixel.renderWasSelected());
        this.pixels.forEach(pixel => pixel.renderSelected());
        this.getResizePixels().forEach(pixel => pixel.renderResizable());
      }

      render() {
        (this.isSelected()) ? this.renderSelected(): this.renderUnselected();
        for (var i = 0; i < this.pixels.length; i++) this.pixels[i].setValue(this.values[i]);
      }

      getMove(verticalDiff, lateralDiff) {
        return this.pixels.map(
          pixel => canvas.getPixelByRowCol(pixel.row + verticalDiff, pixel.col + lateralDiff)
        );
      }

      move(verticalDiff, lateralDiff) {
        this.pixels = this.getMove(verticalDiff, lateralDiff);
        // We must update the to/from pixels so that redraws happen at the new position.
        this.setFromPixel(
          canvas.getPixelByRowCol(this.fromPixel.row + verticalDiff, this.fromPixel.col + lateralDiff)
        );
        this.setToPixel(
          canvas.getPixelByRowCol(this.toPixel.row + verticalDiff, this.toPixel.col + lateralDiff)
        );
      }

      resizeJoinerLayers(resizeSelectedJoinerLayers=false) {
        // resizeSelectedJoinerLayers is used to determine what to do with a probe
        // joint layer if it's selected (as well as the main layer it's joint to).
        // Generally, it should resize as normal. However, if both layers are being 
        // moved, moving should take precedence.

        // Only joint layers will have joints.
        for (let joint of this.joints) {
          let layer = layerManager.getLayerById(joint.layerId);
          
          // Depending on multi-select and the action being taken,
          // it effects if a selected probe join layer should be redrawn.
          // Moved layers don't need to, where as resized layers do.
          if (!layer || (!resizeSelectedJoinerLayers && layer.isSelected())) continue;
          
          let beforeJointPixel = this.lastKeyedJointPixels[joint.jointKey];
          let currentJointPixel = this.getKeyedJointPixels()[joint.jointKey];

          if (!currentJointPixel) {
            // This means the layer has changed in such a way that the joint pixel
            // is no longer available. It will get unjoined. This only should happen
            // with tables.
            debugError("joint pixel not found");
            this.unjoin(joint.layerId, joint.jointKey);
            return;
          }

          // Get the "from" pixel given the joint pixel before the main layer was moved.
          // We have to use the before JointPixel as the joint layer hasn't moved yet,
          // so that's where it's joining pixel still is.
          let fromPixel = layer.getResizeOppositePixel(beforeJointPixel);

          // The resize pixel may not get found if the main layer has
          // somehow moved without the jointed layer. 
          if (!fromPixel) {
            alert("resize pixel not found");
            return;
          }
          layer.setFromPixel(fromPixel);
          layer.draw(currentJointPixel.id()); 
        }
      }

      probeJoint(layer, jointKey, jointPixel) {
          var state = 0;
          for (var probePixel of this.getJoinerPixels()) {
            if (probePixel.isNear(jointPixel)) {
              state = 1;
              if (probePixel.is(jointPixel)) {
                state = 2;
                layer.join(this.id, jointKey);
                // Break to avoid unjoining in the following iteration.
                // Only one joiner/probe pixel of the same layer can join to the same jointPixel.
                break;
              }
            }
          layer.unjoin(this.id, jointKey);
        }
        return state
      }


      join(layerId, jointKey) {
        for (var joint of this.joints) {
          if (layerId == joint.layerId && jointKey == joint.jointKey) {
            return;
          }
        }
        this.joints.push({layerId: layerId, jointKey: jointKey});
      }

      unjoin(layerId, jointKey) {
        var index = 0;
        for (var joint of this.joints) {
          if (layerId == joint.layerId && jointKey == joint.jointKey) {
            this.joints.splice(index, 1);
            return;
          }
          index ++;
        }
      }

      hasPixel(id) {
        // We include joint pixels so that z-index visibility works nicely.
        // There is yet to be a reason not to do this.
        return (
          this.getPixelIndex(id) > -1 ||
          this.getJointPixels().map(pixel => pixel.id()).includes(id)
        );
      }

      getPixelIndex(id) {
        for (var i = 0; i < this.pixels.length; i++) {
          let pixel = this.pixels[i];
          if (pixel.id() == id) return i;
        }
        return -1;
      }

      erasePixel(id) {
        for (var i = 0; i < this.pixels.length; i++) {
          if (this.pixels[i].id() == id) this.deletePixelByPosition(i);
        }
      }

      deletePixelByPosition(index) {
        this.pixels.splice(index, 1);
        this.values.splice(index, 1);
      }
      
      isSelected() {
        return this._isSelected;
      }

      empty() {
        this.pixels = [];
        this.values = [];
      }
    }
    

    /////////////////////////
    ////// TEXT LAYER ///////
    /////////////////////////

    class TextLayer extends Layer {
      
      name = "text";

      constructor(firstPixelId, tableId=null) {
        super(firstPixelId);

        // TextLayer's don't use toPixels, but it's easier to just set it. 
        this.setToPixel(this.fromPixel);

        this.cursor = 0;
        this.contents = [];
        this.tableId = tableId;
        if (tableId) this.zindex = layerManager.getLayerById(tableId).zindex;
      }

      
      static selectedDoubleClickEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        let layer = layerManager.getLayerByPixelId(activePixel.id());
        layerManager.editingTextLayer = layer;
        layer.moveCursorToPixel(activePixel);
      }

      static drawMouseDownEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!TextLayer.focusedOtherTextLayer(activePixel)) {
          let layer = new TextLayer(event.target.id);
          layerManager.add(layer);
          layerManager.editingTextLayer = layer;
          layer.fromPixel.renderFocus();

          // Give an instant cursor position so it can be cleared
          // even if no writing was done.
          layer.lastCursorPixel = layer.fromPixel;
        }
      }

      static writingMouseDownEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!TextLayer.focusedOtherTextLayer(activePixel)) {
          modeMaster.reset("select");
          layerManager.unselectAll();
        }
      }

      static keyDownEvent(event) {
        var layer = layerManager.editingTextLayer;
        if (layer && layer.name == "text") layer.writeChar(event.keyCode);
      }
      
      static focusedOtherTextLayer(activePixel) {
        let layer = layerManager.getLayerByPixelId(activePixel.id());
        if (layer && layer.name == "text") {
          layer.moveCursorToPixel(activePixel);
          layerManager.editingTextLayer = layer;
          return true;
        }
        return false;
      }

      unselect() {
        super.unselect();
        if (this.lastCursorPixel) this.lastCursorPixel.renderNormal();
      }
      
      copy(replace=false) {
        let layerCopy = super.copy(replace);
        layerCopy.contents = structuredClone(this.contents);
        if (replace) layerCopy.tableId = this.tableId;
        return layerCopy;
      }

      rollback() {
        // A little more is needed for TextLayer rollbacks, 
        // to ensure the cursor is removed if the rollback
        // caused the layer to get deleted (0 pixels).
        this.pixels.forEach(pixel => pixel.renderNormal());
        super.rollback();
      }

      getKeyedJointPixels() {
        if (this.hasTable()) return {}; // The table itself will be joinable instead.
        let firstPixel = this.getFirstPixel();
        let lastPixel = this.getLastPixel();
        let middlePixel = this.getMiddlePixel();
        return {
          l: canvas.getPixelByRowCol(firstPixel.row, firstPixel.col - 1), // Left
          r: canvas.getPixelByRowCol(lastPixel.row, lastPixel.col + 1), // Right
          mt: canvas.getPixelByRowCol(middlePixel.row - 1, middlePixel.col), // Middle top
          mb: canvas.getPixelByRowCol(middlePixel.row + 1, middlePixel.col), // Middle bottom
        }
      }


      getLength() {
        return this.contents.length;
      }

      moveCursorToPixel(pixel) {
        this.render();
        this.cursor = this.getPixelIndex(pixel.id()) + 1;
        pixel.renderFocus();
      }

      getCursorLineOffset() {
        for (var i = this.cursor; i >= 0; i --) {
          if (i == 0) {
            return this.cursor - i;
          } else if (this.contents[i] == "\n") {
            if ((this.cursor - i) == 0) {
              continue;
            }
            return this.cursor - i - 1;
          }
        }
      }

      getCurrentLine() {
        var line = 0;
        for (var i = 0; i < this.getLength(); i++) {
          if (i == this.cursor || i + 1 == this.getLength()) return line;
          if (this.contents[i] == "\n") line ++;
        }
        return 0;
      }

      getLineStart(lineNum) {
        var line = 0;
        for (var i = 0; i < this.getLength(); i++) {
          if (line == lineNum) return i;
          if (this.contents[i] == "\n") line ++;
        }
        return i;
      }

      getLineLengths() {
        var lengths = [0];
        for (var i = 0; i < this.getLength(); i++) {
          if (this.contents[i] == "\n") {
            lengths.push(0);
          } else {
            lengths[lengths.length - 1] ++;
          }
        }
        return lengths;
      }

      drawLayer(activePixelId) {
        this.empty();
        let pixels = [];
        var line = 0;
        var col = 0;
        for (var i = 0; i < this.getLength(); i++) {
          if (this.contents[i] == "\n") {
            line ++;
            col = 0;
          }
          let pixel = canvas.getPixelByRowCol(
            this.fromPixel.row + line,
            this.fromPixel.col + col)
          ;
          if (this.cursor == i + 1) {
            this.lastCursorPixel = pixel;
            pixel.renderCursor();
          }
          if (!pixel || this.contents[i] == "\n") continue;
          this.add(pixel, this.contents[i]);
          col ++;
        }

      }

      getVerticalCursor(direction) {
        let currentLine = this.getCurrentLine();
        let lineLengths = this.getLineLengths(); 
        let cursorLineOffset = this.getCursorLineOffset();
        var nextLine;
        if (direction == "up") {
            nextLine = (currentLine > 0)? currentLine - 1: currentLine;
        } else {
            nextLine = (lineLengths.length - 1 > currentLine)? currentLine + 1: currentLine;
        }
        let col = (lineLengths[nextLine] > cursorLineOffset)? cursorLineOffset: lineLengths[nextLine];
        return this.getLineStart(nextLine) + col;
      }

      writeChar(key) {
        let char = String.fromCharCode(key);
        let length = this.getLength();
        let currentLine = this.getCurrentLine();
        let lineLengths = this.getLineLengths(); 
        let cursorLineOffset = this.getCursorLineOffset();
        switch (key) {
          case KEYS["down"]: 
            this.cursor = this.getVerticalCursor("down");
          break;
          case KEYS["up"]:
            this.cursor = this.getVerticalCursor("up");
          break;
          case KEYS["right"]:
            this.cursor = (this.cursor >= length)? length: this.cursor + 1;
          break;
          case KEYS["left"]:
            this.cursor = (this.cursor <= 0)? 0: this.cursor - 1;
          break;
          case KEYS["enter"]:
            this.contents.splice(this.cursor, 0, "\n");
            this.cursor++;
          break;
          case KEYS["back"]:
            this.cursor = (this.cursor <= 0)? 0: this.cursor - 1;
            this.contents.splice(this.cursor, 1);
          break;
          default:
            this.contents.splice(this.cursor, 0, char);
            this.cursor++;
          break;
        }

        // This is a quick way of not loosing a layer just because
        // a user backspaced all characters. 
        if (this.contents.length == 0) this.contents = [">"];

        layerManager.refresh(() => {
          this.draw(null); // TextLayer's don't use toPixels, hence the null

          // If the text is part of a table, the table may need spacing.
          if (this.hasTable()) layerManager.getLayerById(this.tableId).refresh();
        });
      }
    }

    /////////////////////////
    ////// LINE LAYER ///////
    /////////////////////////

    class BaseLineLayer extends Layer {
      
      constructor(firstPixelId) {
        super(firstPixelId);
        this.hasArrowLeft = modeMaster.has("arrow-left");
        this.hasArrowRight = modeMaster.has("arrow-right");
      }

      static drawMouseOver(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        for (var layer of layerManager.layers) {
          for (var jointPixel of layer.getJointPixels()) {
            if (activePixel.isNear(jointPixel) && layerManager.layerPixelIsVisible(layer, jointPixel)) {
              jointPixel.renderJointNear();
            } else {
              jointPixel.renderWasSelected();
            }
          }
        }
      }

      copy(replace=false) {
        let layerCopy = super.copy(replace);
        layerCopy.hasArrowLeft = this.hasArrowLeft;
        layerCopy.hasArrowRight = this.hasArrowRight;
        return layerCopy;
      }
      
      toggleArrows(direction) {
        if (direction == "left") this.hasArrowLeft = !this.hasArrowLeft;
        if (direction == "right") this.hasArrowRight = !this.hasArrowRight;
        this.redraw();
      }

      getEndPixels() {
        if (this.pixels.length > 0) {
          return [this.getFirstPixel(), this.getLastPixel()]; 
        }
        return [];
      }

      getResizePixels() {
        return this.getEndPixels(); 
      }

      getJoinerPixels() {
        return this.getEndPixels(); 
      }

      getResizeOppositePixel(pixel) {
        let resizePixels = this.getResizePixels();
        if (!resizePixels.length) return;
        if (pixel.is(resizePixels[0])) return resizePixels[1];
        if (pixel.is(resizePixels[1])) return resizePixels[0];
      }
    }

    class FreeLineLayer extends BaseLineLayer {
      
      name = "free-line"

      static drawMouseDownEvent(event) {
        let layer = new FreeLineLayer(event.target.id);
        layerManager.add(layer);
      }

      drawLayer(activePixelId) {
        this.setToPixel(canvas.getPixelById(activePixelId));
        let fromPixel = this.fromPixel;
        let toPixel = this.toPixel;
        let verticalDiff  = toPixel.row - fromPixel.row;
        let lateralDiff   = toPixel.col - fromPixel.col;
        
        var totalSteps   = Math.max(Math.abs(verticalDiff), Math.abs(lateralDiff));
        var verticalStep = verticalDiff / totalSteps;
        var lateralStep  = lateralDiff / totalSteps;

        var colDraw = fromPixel.col;
        var rowDraw = fromPixel.row;

        var value = "x";

        if (Math.abs(verticalStep) < 0.3){
          value = this.lateralChar;
        } else if (Math.abs(lateralStep) < 0.5) {
          value = this.verticalChar;
        } else if (toPixel.isLeft(fromPixel) && toPixel.isBelow(fromPixel)) {
          value = this.diagForwardChar;
        } else if (toPixel.isRight(fromPixel) && toPixel.isBelow(fromPixel)) {
          value = this.diagBackChar;
        } else if (toPixel.isLeft(fromPixel) && toPixel.isAbove(fromPixel)) {
          value = this.diagBackChar;
        } else if (toPixel.isRight(fromPixel) && toPixel.isAbove(fromPixel)) {
          value = this.diagForwardChar;
        }
         
        var startValue = value;
        var endValue = value;
        if (Math.abs(verticalDiff) > Math.abs(lateralDiff)) {
          if (toPixel.isAbove(fromPixel)) {
            endValue = (this.hasArrowLeft) ? this.arrowUpChar : value;
            startValue = (this.hasArrowRight) ? this.arrowDownChar : value;
          } else {
            endValue = (this.hasArrowLeft) ? this.arrowDownChar : value;
            startValue = (this.hasArrowRight) ? this.arrowUpChar : value;
          }
        } else{
          if (fromPixel.isLeft(toPixel)) {
            endValue = (this.hasArrowRight) ? this.arrowRightChar : value;
            startValue = (this.hasArrowLeft) ? this.arrowLeftChar : value;
          } else {
            endValue = (this.hasArrowLeft) ? this.arrowLeftChar : value;
            startValue = (this.hasArrowRight) ? this.arrowRightChar : value;
         } 
        }

        this.empty();
        for (var i = 0; i <= totalSteps; i ++) {
          this.add(
            canvas.getPixelByRowCol(roundHalf(rowDraw), roundHalf(colDraw)),
            (i == 0)? startValue: value
          );
          rowDraw += verticalStep;
          colDraw += lateralStep;
        }
        this.add(this.getLastPixel(), endValue);
      }
    }

    class StepLineLayer extends BaseLineLayer {

      name = "step-line";

      static drawMouseDownEvent(event) {
        let layer = new StepLineLayer(event.target.id);
        layerManager.add(layer);
      }

      getKeyedJointPixels() {
        var lastRow = this.getFirstPixel().row;
        var index = 0;
        for (var pixel of this.pixels) {
          if (pixel.row != lastRow) {
            return {m: this.pixels[index - 1]}; // Middle
          }
          index ++;
        }
        return {m: this.getLastPixel()}; // Middle
      }

      drawLayer(activePixelId) {
        this.setToPixel(canvas.getPixelById(activePixelId));

        /* Try and draw the step line both ways e.g
            _____
            |                |
            |       Vs.   ___|
                            
        and choose which ever is more visible depending on other layers overlapping.
        */
        let layersToAvoid = ["square", "table", "diamond"];
        this.drawFromTo(this.fromPixel, this.toPixel);
        let resultNorm = layerManager.getNearOverlappingCount(this, layersToAvoid);
        this.drawFromTo(this.toPixel, this.fromPixel);
        let resultFlip = layerManager.getNearOverlappingCount(this, layersToAvoid);
        if (resultNorm > resultFlip) {
          this.drawFromTo(this.toPixel, this.fromPixel);
        } else {
          this.drawFromTo(this.fromPixel, this.toPixel);
        }
      }

      drawFromTo(fromPixel, toPixel) {
        this.empty();
        let verticalDiff  = toPixel.row - fromPixel.row;
        let lateralDiff   = toPixel.col - fromPixel.col;
        let absVerticalDiff = Math.abs(verticalDiff);
        let absLateralDiff = Math.abs(lateralDiff);
       
        let [lateralArrowValue, verticalArrowValue] = this.getArrowChars(fromPixel, toPixel);
        var cornerChar = this.getCornerChar(fromPixel, toPixel);

        var drawCol = fromPixel.col; 
        var drawRow = fromPixel.row;

        for (var i = 0; i < absLateralDiff; i ++) {
          this.add(
            canvas.getPixelByRowCol(fromPixel.row, drawCol),
            (i == 0)? lateralArrowValue: this.lateralChar
          );
          drawCol += lateralDiff / absLateralDiff;
        }

        if (verticalDiff && !lateralDiff) {
          cornerChar = this.verticalChar;
        } else if (!verticalDiff && lateralDiff) {
          cornerChar = this.lateralChar;
        }
        this.add(canvas.getPixelByRowCol(drawRow, drawCol), cornerChar);

        for (var i = 1; i <= absVerticalDiff; i ++) {
          drawRow += verticalDiff / absVerticalDiff;
          let value = (verticalDiff && lateralDiff)? cornerChar: this.verticalChar;
          this.add(
            canvas.getPixelByRowCol(drawRow, toPixel.col),
            (i == absVerticalDiff)? verticalArrowValue: this.verticalChar
          );
        }
      }

      getCornerChar(fromPixel, toPixel) {
        if (fromPixel.col < toPixel.col) {
          return fromPixel.row < toPixel.row? this.cornerTopRightChar:  this.cornerBottomRightChar;
        } else {
          return fromPixel.row < toPixel.row? this.cornerTopLeftChar:  this.cornerBottomLeftChar;
        }
        return "";
      }

      getArrowChars(fromPixel, toPixel) {
        var lateralArrowValue = this.lateralChar;
        var verticalArrowValue = this.verticalChar;
        if (fromPixel.col > toPixel.col) {
          // Vertical line is on left
          //    |
          //    |
          //    |____
          if (this.hasArrowRight) lateralArrowValue = this.arrowRightChar; 
          if (this.hasArrowLeft) {
            verticalArrowValue = fromPixel.row > toPixel.row? this.arrowUpChar: this.arrowDownChar;
          }
        } else {
          // Vertical line is on left
          //       |
          //       |
          //    ___|
          if (this.hasArrowLeft) lateralArrowValue = this.arrowLeftChar; 
          if (this.hasArrowRight) {
           verticalArrowValue = fromPixel.row > toPixel.row? this.arrowUpChar: this.arrowDownChar;
          }
        }
        return [lateralArrowValue, verticalArrowValue];
      }
    }


    class SwitchLineLayer extends BaseLineLayer {

      name = "switch-line";

      static drawMouseDownEvent(event) {
        let layer = new SwitchLineLayer(event.target.id);
        layerManager.add(layer);
      }

      getKeyedJointPixels() {
        // This finds the two corners of a switch line.
        let firstPixel = this.getFirstPixel();
        if(this.pixels.length < 2) return {0: firstPixel, 1: firstPixel};
        let joints = [];
        for (var index = 1; index < this.pixels.length - 1; index ++) {
          let pixel = this.pixels[index];
          let lastPixel = this.pixels[index - 1];
          let nextPixel = this.pixels[index + 1];
          if (
            (lastPixel.row == pixel.row && pixel.row != nextPixel.row) ||
            (lastPixel.col == pixel.col && pixel.col != nextPixel.col)
          ) {
            joints.push(pixel);
          }
        }

        // This means the line is straight, so we just join to the middle.
        if (joints.length != 2) {
          let middlePixel = this.getMiddlePixel();
          return {0: middlePixel, 1: middlePixel};
        }
        
        // This ensures the keys are the same for the meaningful locations,
        // regardless of a flip.
        let keyedJoints = {};
        if (joints[0].row > joints[1].row || joints[0].col > joints[1].col) {
          keyedJoints[0] = joints[0];
          keyedJoints[1] = joints[1];
        } else {
          keyedJoints[0] = joints[1];
          keyedJoints[1] = joints[0];
        }
        return keyedJoints;
      }

      drawLayer(activePixelId) {
        this.setToPixel(canvas.getPixelById(activePixelId));
        let fromPixel = this.fromPixel;
        let toPixel = this.toPixel;
        let verticalDiff  = toPixel.row - fromPixel.row;
        let lateralDiff   = toPixel.col - fromPixel.col;
        let absVerticalDiff = Math.abs(verticalDiff);
        let absLateralDiff = Math.abs(lateralDiff);

        /*
        Try and draw the switch line both ways e.g
            _____
            |                 | 
            |             ____| 
         ___|       Vs.   |
                              
                              

        and choose which ever is more visible depending on other layers overlapping.
        If there aren't notable overlaps, choose based on which direction is favoured.
        */
        let layersToAvoid = ["square", "table", "diamond"];
        this.drawVertical(fromPixel, toPixel);
        let verticalOverlap = layerManager.getNearOverlappingCount(this, layersToAvoid);
        this.drawLateral(fromPixel, toPixel);
        let lateralOverlap = layerManager.getNearOverlappingCount(this, layersToAvoid);
        if (verticalOverlap > lateralOverlap) {
          this.drawLateral(fromPixel, toPixel);
        } else if (lateralOverlap > verticalOverlap) {
          this.drawVertical(fromPixel, toPixel);
        } else if (absVerticalDiff > absLateralDiff) {
          this.drawVertical(fromPixel, toPixel);
        } else {
          this.drawLateral(fromPixel, toPixel);
        }
      }

      drawVertical(fromPixel, toPixel) {
        let [firstChar, lastChar] = this.getArrowCharsVertical(fromPixel, toPixel); 
        let [firstCornerChar, lastCornerChar] = this.getCornerCharsVertical(fromPixel, toPixel); 
        this.drawFromTo(
          fromPixel.col,
          fromPixel.row,
          toPixel.col,
          toPixel.row,
          [this.verticalChar, this.lateralChar, firstChar, lastChar, firstCornerChar, lastCornerChar],
          (a, b) => canvas.getPixelByRowCol(a, b),
        );
      }

      drawLateral(fromPixel, toPixel) {
        let [firstChar, lastChar] = this.getArrowCharsLateral(fromPixel, toPixel); 
        let [firstCornerChar, lastCornerChar] = this.getCornerCharsLateral(fromPixel, toPixel); 
        this.drawFromTo(
          fromPixel.row,
          fromPixel.col,
          toPixel.row,
          toPixel.col,
          [this.lateralChar, this.verticalChar, firstChar, lastChar, firstCornerChar, lastCornerChar],
          (a, b) => canvas.getPixelByRowCol(b, a),
        );
      } 

      drawFromTo(fromPixelCol, fromPixelRow, toPixelCol, toPixelRow, chars, pixelFunc) {
        this.empty();
        let [mainChar, midChar, firstChar, lastChar, firstCornerChar, lastCornerChar] = chars;
        let diffA = toPixelRow - fromPixelRow;
        let diffB = toPixelCol - fromPixelCol;
        let absDiffA = Math.abs(diffA);
        let absDiffB = Math.abs(diffB);
        var drawCol = fromPixelCol; 
        var drawRow = fromPixelRow;
        /*
         The following three loops represent each part of a
         switch layer in order.

         E.g

        "Lateral" 
                               __________ 
                               |     3
                     __________| 2
                         1   
        
        "Vertical"
            
                          | 1
                          |
                          |____
                            2  |
                               | 3
                               | 

        Note, the logic is the same both ways, but to draw laterally,
        this method is called with cols and rows swapped.
        It's quite confusing but I've found it works wonderfully.
        */

        let halfwayA = roundHalf(absDiffA / 2);
        // First line
        for (var i = 0; i < halfwayA; i ++) {
          this.add(pixelFunc(drawRow, drawCol), (i == 0)? firstChar: mainChar);
          drawRow += diffA / absDiffA;
        }

        // If there is no middle line (no diff in a direction),
        // fill with a continuation pixel using mainChar.
        if (absDiffB == 0) {
          this.add(pixelFunc(drawRow, drawCol), mainChar);
        } else {
          // First corner
          this.add(pixelFunc(drawRow, drawCol), firstCornerChar);
          // Second line (middle)
          for (var i = 0; i < absDiffB - 1; i ++) {
            drawCol += diffB / absDiffB;
            this.add(pixelFunc(drawRow, drawCol), midChar);
          }
          drawCol += diffB / absDiffB;
          // Second corner
          this.add(pixelFunc(drawRow, drawCol), lastCornerChar);
        }
        // Third line. We use a while to ensure the line is drawn all the way.
        // Otherwise, using, using another "halfwayA" might be uneven due to rounding. 
        while(drawRow != toPixelRow) {
          drawRow += diffA / absDiffA;
          this.add(pixelFunc(drawRow, toPixelCol), mainChar);
        }

        // This will replace the last char with arrows if needed.
        this.add(pixelFunc(drawRow, toPixelCol), lastChar); 
      }

      getArrowCharsVertical(fromPixel, toPixel) {
        var firstChar = this.verticalChar;
        var lastChar = this.verticalChar;
        if (fromPixel.row < toPixel.row) {
          // Going down
          if (fromPixel.col < toPixel.col) {
            // Going right
            if (this.hasArrowRight) lastChar = this.arrowDownChar;
            if (this.hasArrowLeft) firstChar = this.arrowUpChar;
          } else {
            // Going left
            if (this.hasArrowLeft) lastChar = this.arrowDownChar;
            if (this.hasArrowRight) firstChar = this.arrowUpChar;
          }
        } else {
          // Going up
          if (fromPixel.col < toPixel.col) {
            // Going right
            if (this.hasArrowRight) lastChar = this.arrowUpChar;
            if (this.hasArrowLeft) firstChar = this.arrowDownChar;
          } else {
            // Going left
            if (this.hasArrowLeft) lastChar = this.arrowUpChar;
            if (this.hasArrowRight) firstChar = this.arrowDownChar;
          }
        }
        return [firstChar, lastChar];
      }

      getArrowCharsLateral(fromPixel, toPixel) {
        var firstChar = this.lateralChar;
        var lastChar = this.lateralChar;
        if (fromPixel.col < toPixel.col) {
          // Going right
          if (this.hasArrowLeft) firstChar = this.arrowLeftChar;
          if (this.hasArrowRight) lastChar = this.arrowRightChar;
        } else {
          // Going left
          if (this.hasArrowLeft) lastChar = this.arrowLeftChar;
          if (this.hasArrowRight) firstChar = this.arrowRightChar;
        }
        return [firstChar, lastChar];
      }

      getCornerCharsVertical(fromPixel, toPixel) {
        var firstChar = "";
        var lastChar = "";
        if (fromPixel.row < toPixel.row) {
          // Going down
          if (fromPixel.col < toPixel.col) {
            // Going right
            firstChar = this.cornerBottomLeftChar; 
            lastChar = this.cornerTopRightChar;
          } else {
            // Going left
            firstChar = this.cornerBottomRightChar; 
            lastChar = this.cornerTopLeftChar;
          }
        } else {
          // Going up
          if (fromPixel.col < toPixel.col) {
            // Going right
            firstChar = this.cornerTopLeftChar; 
            lastChar = this.cornerBottomRightChar;
          } else {
            // Going left
            firstChar = this.cornerTopRightChar; 
            lastChar = this.cornerBottomLeftChar;
          }
        }
        return [firstChar, lastChar];
      }

      getCornerCharsLateral(fromPixel, toPixel) {
        var firstChar = "";
        var lastChar = "";
        if (fromPixel.row < toPixel.row) {
          // Going down
          if (fromPixel.col < toPixel.col) {
            // Going right
            firstChar = this.cornerTopRightChar; 
            lastChar = this.cornerBottomLeftChar;
          } else {
            // Going left
            firstChar = this.cornerTopLeftChar; 
            lastChar = this.cornerBottomRightChar;
          }
        } else {
          // Going up
          if (fromPixel.col < toPixel.col) {
            // Going right
            firstChar = this.cornerBottomRightChar; 
            lastChar = this.cornerTopLeftChar;
          } else {
            // Going left
            firstChar = this.cornerBottomLeftChar; 
            lastChar = this.cornerTopRightChar;
          }
        }
        return [firstChar, lastChar];
      }

    }

    /////////////////////////
    ////// FREE LAYER ///////
    /////////////////////////

    class FreeLayer extends Layer {
      
      name = "free";

      
      freeChar = charManager.getFree();

      static drawMouseDownEvent(event) {
        let layer = new FreeLayer(event.target.id);
        layerManager.add(layer);
        layerManager.refresh(() => layer.draw(event.target.id));
      }

      drawLayer(activePixelId) {
        this.setToPixel(canvas.getPixelById(activePixelId));
        this.add(this.toPixel, this.freeChar);
      }
    }


    //////////////////////
    //// SQUARE LAYER ////
    //////////////////////
    
    class SquareBoundLayer extends Layer { 
      
      getCornerPixels() {
        if (this.pixels.length == 0) {
          return [];
        }
        var maxCol = -1;
        var minCol = -1;
        var maxRow = -1;
        var minRow = -1;
        for (var pixel of this.pixels) {
          if (pixel.col > maxCol) maxCol = pixel.col;
          if (pixel.col < minCol || minCol == -1) minCol = pixel.col; 
          if (pixel.row > maxRow) maxRow = pixel.row;
          if (pixel.row < minRow || minRow == -1) minRow = pixel.row; 
        }
        return [
          canvas.getPixelByRowCol(minRow, minCol), // Top left
          canvas.getPixelByRowCol(minRow, maxCol), // Top right
          canvas.getPixelByRowCol(maxRow, maxCol), // Bottom right
          canvas.getPixelByRowCol(maxRow, minCol), // Bottom left
        ]
      }

      getResizePixels() {
        return this.getCornerPixels();
      }

      getResizeOppositePixel(targetPixel) {
        let corners = this.getResizePixels();
        let cornerMatchPixel = this.getResizePixelIndex(targetPixel);
        if (cornerMatchPixel == -1) return;
        let firstPixelIndex = cornerMatchPixel + 2;
        if (firstPixelIndex > 3) firstPixelIndex = firstPixelIndex - 4;
        return corners[firstPixelIndex];
      }
    }

    class DiamondLayer extends Layer {
      
      name = "diamond" 

      static drawMouseDownEvent(event) {
        let layer = new DiamondLayer(event.target.id);
        layerManager.add(layer);
      }
      
      getKeyedJointPixels() {
        let firstPixel = this.getFirstPixel();
        if (this.pixels.length < 4) return {t: firstPixel, r: firstPixel, b: firstPixel, l: firstPixel};
        let [leftPixel, rightPixel, topPixel, bottomPixel] = this.getCornerPixels();
        return {
          t: canvas.getPixelByRowCol(topPixel.row - 1, topPixel.col), 
          r: canvas.getPixelByRowCol(rightPixel.row, rightPixel.col + 1), 
          b: canvas.getPixelByRowCol(bottomPixel.row + 1, topPixel.col), 
          l: canvas.getPixelByRowCol(leftPixel.row, leftPixel.col - 1), 
        };
      }

      getCornerPixels() {
        var minCol;
        var maxCol;
        var minRow;
        var maxRow;
        for (let pixel of this.pixels) {
          if (!minCol || pixel.col < minCol.col) minCol = pixel;
          if (!maxCol || pixel.col > maxCol.col) maxCol = pixel;
          if (!minRow || pixel.row < minRow.row) minRow = pixel;
          if (!maxRow || pixel.row > maxRow.row) maxRow = pixel;
        }
        return [minCol, maxCol, minRow, maxRow];
      }

      getResizePixels() {
        return this.getCornerPixels();
      }

      getResizeOppositePixel(targetPixel) {
        let [minCol, maxCol, minRow, maxRow] = this.getCornerPixels();
        return canvas.getPixelByRowCol(
          minRow.row + roundHalf((maxRow.row - minRow.row) / 2),
          minCol.col + roundHalf((maxCol.col - minCol.col) / 2),
        )
      }
      
      drawLayer(activePixelId) {
        this.setToPixel(canvas.getPixelById(activePixelId));
        let verticalDiff = Math.abs(this.toPixel.row - this.fromPixel.row);
        let lateralDiff = Math.abs(this.toPixel.col - this.fromPixel.col);
        var diff = verticalDiff > lateralDiff? verticalDiff: roundHalf(lateralDiff / 2);
        
        var middlePixel = this.fromPixel;
        
        let topPixel = canvas.getPixelByRowCol(middlePixel.row - diff, middlePixel.col);
        let leftPixel = canvas.getPixelByRowCol(middlePixel.row, middlePixel.col - (diff * 2));
        let rightPixel = canvas.getPixelByRowCol(middlePixel.row, middlePixel.col + (diff * 2));
        let bottomPixel = canvas.getPixelByRowCol(middlePixel.row + diff, middlePixel.col);
        
        let corners = [topPixel, leftPixel, rightPixel, bottomPixel];
        if (!corners.every(Boolean)) return;

        this.empty();
        corners.forEach(pixel => this.add(pixel, this.cornerGenericChar)); 
        for (var backCount = 1; backCount < diff; backCount ++) {
          this.add(
            canvas.getPixelByRowCol(rightPixel.row - backCount, rightPixel.col - (backCount * 2)),
            this.diagBackChar, 
          );
          this.add(
            canvas.getPixelByRowCol(bottomPixel.row - backCount, bottomPixel.col - (backCount * 2)),
            this.diagBackChar, 
          );
        }
        for (var fCount = 1; fCount < diff; fCount ++) {
          this.add(
            canvas.getPixelByRowCol(leftPixel.row - fCount, leftPixel.col + (fCount * 2)),
            this.diagForwardChar, 
          );
          this.add(
            canvas.getPixelByRowCol(bottomPixel.row - fCount, bottomPixel.col + (fCount * 2)),
            this.diagForwardChar, 
          );
        }
      } 
    }

    class SquareLayer extends SquareBoundLayer {
      
      name = "square" 

      static drawMouseDownEvent(event) {
        let layer = new SquareLayer(event.target.id);
        layerManager.add(layer);
      }

      getKeyedJointPixels() {
        let fp = this.getFirstPixel();
        if (this.pixels.length < 2) {
          return {tl: fp, tr: fp, br: fp, bl: fp, l: fp, r: fp, b: fp, t: fp};
        }

        let corners = this.getCornerPixels();
        let halfways = this.getHalfwayPixels(corners);
        if (!corners.length || !halfways.length) return {};
        return {
          tl: corners[0], // Top left
          tr: corners[1], // Top right
          br: corners[2], // Bottom right
          bl: corners[3], // Bottom left
          l: canvas.getPixelByRowCol(halfways[0].row, halfways[0].col - 1), // Left
          r: canvas.getPixelByRowCol(halfways[1].row, halfways[1].col + 1), // Right
          b: canvas.getPixelByRowCol(halfways[2].row + 1, halfways[2].col), // Bottom
          t: canvas.getPixelByRowCol(halfways[3].row - 1, halfways[3].col), // Top
        };
      }
      
      getHalfwayPixels(corners) {
        if (this.pixels.length == 0) return [];
        let minRow = corners[0].row;
        let maxRow = corners[2].row;
        let minCol = corners[0].col;
        let maxCol = corners[2].col;
        let halfwayRow = parseInt((maxRow - minRow) / 2);
        let halfwayCol = parseInt((maxCol - minCol) / 2);
        return [
          canvas.getPixelByRowCol(minRow + halfwayRow, minCol), // Left
          canvas.getPixelByRowCol(minRow + halfwayRow, maxCol), // Right
          canvas.getPixelByRowCol(maxRow, minCol + halfwayCol), // Bottom
          canvas.getPixelByRowCol(minRow, minCol + halfwayCol), // Top
        ]
      }

      drawLayer(activePixelId) {
        this.setToPixel(canvas.getPixelById(activePixelId));
        let topLeftPixel = canvas.getPixelByRowCol(
          Math.min(this.toPixel.row, this.fromPixel.row),
          Math.min(this.toPixel.col, this.fromPixel.col),
        )
        let bottomRightPixel = canvas.getPixelByRowCol(
          Math.max(this.toPixel.row, this.fromPixel.row),
          Math.max(this.toPixel.col, this.fromPixel.col),
        )

        let verticalDiff = bottomRightPixel.row - topLeftPixel.row;
        let lateralDiff = bottomRightPixel.col - topLeftPixel.col;

        if (!verticalDiff || !lateralDiff) return;
        
        let absVerticalDiff = Math.abs(verticalDiff);
        let absLateralDiff = Math.abs(lateralDiff);
        var rowPos = topLeftPixel.row;
        var colPos = topLeftPixel.col;

        this.empty();

        // Draw corners
        this.add(canvas.getPixelByRowCol(rowPos, colPos), this.cornerTopLeftChar);
        this.add(canvas.getPixelByRowCol(rowPos, bottomRightPixel.col), this.cornerTopRightChar);
        this.add(canvas.getPixelByRowCol(bottomRightPixel.row, colPos), this.cornerBottomLeftChar);
        this.add(canvas.getPixelByRowCol(bottomRightPixel.row, bottomRightPixel.col), this.cornerBottomRightChar);

        // Draw lines
        for(var row = 0; row < absVerticalDiff - 1; row ++) {
          rowPos += verticalDiff / absVerticalDiff;
          this.add(canvas.getPixelByRowCol(rowPos, topLeftPixel.col), this.verticalChar);
          this.add(canvas.getPixelByRowCol(rowPos, bottomRightPixel.col), this.verticalChar);
        }
        for(var col = 0; col < absLateralDiff - 1; col ++) {
          colPos += lateralDiff / absLateralDiff;
          this.add(canvas.getPixelByRowCol(topLeftPixel.row, colPos), this.lateralChar);
          this.add(canvas.getPixelByRowCol(bottomRightPixel.row, colPos), this.lateralChar);
        }
      } 
    }

    /////////////////////
    //// TABLE LAYER ////
    /////////////////////


    class TableLayer extends SquareBoundLayer {
      name = "table"
      
      constructor(firstPixelId) {
        super(firstPixelId);
        this.textLayers = {};
        this.tableContents = {};
        this.tblRows = 0;
        this.tblCols = 0;
        this.defaultCellContents = "text...";
        this.tblColDefaultWidth = this.defaultCellContents.length;
        this.tblColWidths = [];
        this.tblRowHeights = [];
        this.tblRowDefaultHeight = 2;
      }

      static drawMouseDownEvent(event) {
        let layer = new TableLayer(event.target.id);
        layerManager.add(layer);
      }

      copy(replace=false) {
        // Please read base implementation. This extension ensures 
        // we also copy textLayers if it's a full replace copy.
        let layerCopy = super.copy(replace);
        if (replace) layerCopy.textLayers = structuredClone(this.textLayers);  

        // Copy row and col counts so that refresh() works immediately for copied tables.
        layerCopy.tblRows = this.tblRows;
        layerCopy.tblCols = this.tblCols;
        layerCopy.tblRowHeights = this.tblRowHeights;
        layerCopy.tblColWidths = this.tblColWidths;
        return layerCopy;
      }
      
      getExcessRowHeight() {
        return sum(this.tblRowHeights) - (this.tblRowDefaultHeight * this.tblRowHeights.length)
      }
      getExcessColWidth() {
        return sum(this.tblColWidths) - (this.tblColDefaultWidth * this.tblColWidths.length)
      }
      
      getTextLayers() {
        return Object.values(this.textLayers).map(layerId => layerManager.getLayerById(layerId));
      }
      
      getKeyedJointPixels() {
        let pixels = {};
        let corners = this.getCornerPixels();
        if (!corners.length) return [];
        let [topLeftPixel, topRightPixel, bottomRightPixel, bottomLeftPixel] = corners;
        var rowPos = topLeftPixel.row + 1;
        var index = 0;
        for (let height of this.tblRowHeights) {
          pixels[`l-${index}`] = canvas.getPixelByRowCol(rowPos, topLeftPixel.col - 1); // Left x
          pixels[`r-${index}`] = canvas.getPixelByRowCol(rowPos, topRightPixel.col + 1); // Right x
          rowPos += height;
          index ++;
        }
        var colPos = topLeftPixel.col + 1;
        var index = 0;
        for (let width of this.tblColWidths) {
          colPos += width;
          pixels[`t-${index}`] = canvas.getPixelByRowCol( // Top x
            topLeftPixel.row - 1, colPos - roundHalf(width / 2)
          );
          pixels[`b-${index}`] = canvas.getPixelByRowCol( // Bottom x
            bottomLeftPixel.row + 1, colPos - roundHalf(width / 2)
          );
          index ++;
        }
        return pixels;
      }

      ungroup() {
        // Ungroup all layers.
        layerManager.groupManager.ungroupLayers(this.getTextLayers().concat(this));
      }

      group() {
        // Group all existing visible layers, and ensure the table is always selected together.
        let textLayers = this.getTextLayers();
        if (this.isSelected()) textLayers.forEach(layer => layer.select());
        layerManager.groupManager.groupLayers(textLayers.concat(this));
      }
      
      setTableSpacing() {
        this.tblRowHeights = [];
        this.tblColWidths = [];

        let allLineLengths = {};
        for (let cellId in this.textLayers) {
          let lineLengths = this.getTextLayer(cellId).getLineLengths();
          allLineLengths[cellId] = {breaks: lineLengths.length, longest: Math.max(...lineLengths)};
        }

        // Build an array of the tallest (most line breaks) counts per row
        for (var row = 0; row < this.tblRows; row++) {
          var rowHeight = this.tblRowDefaultHeight;
          for (let cellId in this.textLayers) {
            let [cellRow, cellCol] = this.parseCellId(cellId);
            if (cellRow == row) {
              // Add one here so that breaks fairly match with row heights.
              // One line is actually two rows (the line and the text below).
              let linebreaks = allLineLengths[cellId].breaks + 1;
              if (linebreaks > rowHeight) rowHeight = linebreaks;
            }
          }
          this.tblRowHeights.push(rowHeight);
        }
        
        // Build an array of the lengths of the longest line per column
        this.tblColWidths = [];
        for (var col = 0; col < this.tblCols; col++) { 
          var colWidth = 0;
          for (let cellId in this.textLayers) {
            let [cellRow, cellCol] = this.parseCellId(cellId);
            if (cellCol == col) {
              let longestLine = allLineLengths[cellId].longest + 1;
              if (longestLine > colWidth) colWidth = longestLine;
            }
          }
          // If the column widths result in < 2 (one char),
          // text is about to be rendered but could not be used to measure width
          // So we use the default width.
          if (colWidth < 2) colWidth = this.tblColDefaultWidth + 1; 
          this.tblColWidths.push(colWidth);
        }
      }


      getTopLeftPixel() {
        return canvas.getPixelByRowCol(
          Math.min(this.toPixel.row, this.fromPixel.row),
          Math.min(this.toPixel.col, this.fromPixel.col),
        );
      }

      drawLayer(activePixelId) {
        this.setToPixel(canvas.getPixelById(activePixelId));
        
        let topLeftPixel = this.getTopLeftPixel();
        let bottomRightPixel = canvas.getPixelByRowCol(
          Math.max(this.toPixel.row, this.fromPixel.row),
          Math.max(this.toPixel.col, this.fromPixel.col),
        );

        let verticalDiff = topLeftPixel.row - bottomRightPixel.row;
        let lateralDiff = topLeftPixel.col - bottomRightPixel.col;
        

        // We deduct excess pixels so that larger cells don't count as multiple cells
        // and therefore generate more cells than expected when resizing.
        let newTblRows = roundHalf(
          (Math.abs(verticalDiff) - this.getExcessRowHeight()) / this.tblRowDefaultHeight
        );
        let newTblCols = roundHalf(
          (Math.abs(lateralDiff) - this.getExcessColWidth()) / this.tblColDefaultWidth
        );

        if (
           (newTblRows != this.tblRows || newTblCols != this.tblCols) && 
           (newTblCols != 0 && newTblRows != 0)
        ) {
          this.tblRows = newTblRows;
          this.tblCols = newTblCols;
          this.ungroup();
          this.emptyTextLayers();
          this.addTextLayers();
          this.drawFrame(topLeftPixel);
          this.moveTextLayers(topLeftPixel);
          this.group();
        } 
      }

      refresh() {
        let topLeftPixel = this.getTopLeftPixel();
        if (this.commit(() => this.drawFrame(topLeftPixel))) {
          this.moveTextLayers(topLeftPixel);
          this.resizeJoinerLayers(true);
        }
      }

      drawFrame(topLeftPixel) {
        this.empty();

        this.setTableSpacing();
        let tblHeight = sum(this.tblRowHeights);
        let tblWidth = sum(this.tblColWidths);

        let fromRow = topLeftPixel.row;
        let fromCol = topLeftPixel.col;
        let toRow = fromRow + tblHeight;
        let toCol = fromCol + tblWidth;

        // Draw corners...
        this.add(canvas.getPixelByRowCol(fromRow, fromCol), this.cornerTopLeftChar);
        this.add(canvas.getPixelByRowCol(fromRow, toCol), this.cornerTopRightChar);
        this.add(canvas.getPixelByRowCol(toRow, fromCol), this.cornerBottomLeftChar);
        this.add(canvas.getPixelByRowCol(toRow, toCol), this.cornerBottomRightChar);

        // Draw row lines with spacing based on text..
        // -----------------
        //
        // -----------------
        // -----------------
        var row = fromRow;
        for (var tblRow = 0; tblRow <= this.tblRows; tblRow ++) {
          for (var col = fromCol + 1; col < toCol; col++) {
            this.add(canvas.getPixelByRowCol(row,  col), this.lateralChar);
          }
          row += this.tblRowHeights[tblRow];
        }

        // Draw col lines with spacing based on text..
        // |      |   |    |
        // |      |   |    |
        // |      |   |    |
        var col = fromCol;
        for (var tblCol = 0; tblCol <= this.tblCols; tblCol ++) {
          for (var row = fromRow + 1; row < toRow; row ++) {
            this.add(canvas.getPixelByRowCol(row,  col), this.verticalChar);
          }
          col += this.tblColWidths[tblCol];
        }
      } 
      
      makeCellId(row, col) {
        return `${row},${col}`;
      }

      parseCellId(cellId) {
        return cellId.split(",")
      }
      
      emptyTextLayers() {
        let toKeep = {};
        for (let cellId in this.textLayers) {
          let [row, col] = this.parseCellId(cellId);
          // If the textLayer is still visible, then keep it.
          if (row < this.tblRows && col < this.tblCols) {
            toKeep[cellId] = this.textLayers[cellId];
            continue;
          }
          // Otherwise, empty the layer but save it's contents.
          let textLayer = this.getTextLayer(cellId);
          this.tableContents[cellId] = textLayer.contents;
          textLayer.empty();
        }

        this.textLayers = toKeep;
      }

      getTextLayer(cellId) {
        return layerManager.getLayerById(this.textLayers[cellId]);
      }

      moveTextLayer(row, col, absRow, absCol) {
        let textLayer = this.getTextLayer(this.makeCellId(row, col)); 
        let firstPixel = textLayer.getFirstPixel();
        textLayer.commit(() => textLayer.move(absRow - firstPixel.row, absCol - firstPixel.col));
      }

      addTextLayer(row, col) {
        let cellId = this.makeCellId(row, col);

        // If the layer already exists at the given cell, don't create a new one.
        if (this.textLayers[cellId]) return;
      
        // Otherwise, add a new layer and fill it with any saved content from the past
        // at the same cell location.
        let textLayer = new TextLayer(this.fromPixel.id(), this.id); 
        let existingContents = this.tableContents[cellId];
        let contents = (existingContents)? existingContents: this.defaultCellContents.split("");
        textLayer.contents = contents; 
        layerManager.addSecond(textLayer); 
        textLayer.drawLayer();
        this.textLayers[cellId] = textLayer.id;
      }

      addTextLayers() {
        for(var tblRow = 0; tblRow < this.tblRows; tblRow ++) {
          for (var tblCol = 0; tblCol < this.tblCols; tblCol ++) {
            this.addTextLayer(tblRow, tblCol);
          }
        }
      }

      moveTextLayers(topLeftPixel) {
        var rowPos = topLeftPixel.row;
        var colPos = topLeftPixel.col;
        for(var tblRow = 0; tblRow < this.tblRows; tblRow ++) {
          for (var tblCol = 0; tblCol < this.tblCols; tblCol ++) {
            // Add 1s here to locate the text within the cell.
            this.moveTextLayer(tblRow, tblCol, rowPos + 1, colPos + 1);
            colPos += this.tblColWidths[tblCol];
          }
          colPos = topLeftPixel.col;
          rowPos += this.tblRowHeights[tblRow];
        }
      }
    }

    ////////////////
    //// PIXEL /////
    ////////////////

    class Pixel {
      constructor(size, widthDivider, row, col) {
        this.row = row;
        this.col = col;
        this.size = size;
        this.widthDivider = widthDivider;
        this.defaultColor = "black";
        this.defaultBgColor = "transparent";
        this.defaultBorder = "none";
        this.cursorFlashInterval = null;
        this.selected = false;
      }
      
      id() {
        return Pixel.makeId(this.row, this.col);
      }

      is(pixel) {
        return this.id() == pixel.id();
      }

      static makeId(row, col) {
        return `pixel-${row},${col}`
      }

      setValue(value) {
        this.element.innerHTML = value;
      }

      renderSelected() {
        this.selected = true;
        this.setBgColor(this.defaultBgColor);
        this.setColor("blue");
      }

      renderUnselected() {
        this.selected = false;
        this.setColor(this.defaultColor);
        this.setBgColor(this.defaultBgColor);
      }

      renderResizable() {
        this.setBgColor("red");
      }
      
      renderAreaSelected() {
        this.setBgColor("#14005e");
      }
      
      renderJoint() {
        this.setBgColor("pink");
      }

      renderJointNear() {
        this.setBgColor("green");
      }

      renderWasSelected() {
        this.selected? this.renderSelected(): this.renderUnselected();
      }

      renderNoCursor() {
        clearInterval(this.cursorFlashInterval);
        this.element.style.border = "none";
      }

      renderCursor() {
        this.renderNormal();
        this.element.style.borderRight = "1px solid orange";
        setTimeout((pixel) => {
          pixel.element.style.borderRight = "none";
        }, 500, this);
        this.cursorFlashInterval = setInterval(
          (pixel) => {
            this.element.style.borderRight = "1px solid orange";
            setTimeout(() => {
              pixel.element.style.borderRight = "none";
            }, 500);
          },
        1000, this);
      }

      renderFocus() {
        this.setBgColor("orange");
      }

      renderNormal() {
        this.renderNoCursor();
        this.setColor(this.defaultColor);
        this.setBgColor(this.defaultBgColor);
      }

      setColor(color) {
        this.element.style.color = color;
      }

      setBgColor(color) {
        this.element.style.backgroundColor = color;
      }


      clear() {
        this.setValue(" ");
        this.renderNormal();
      }

      isAbove(pixel) {
        return this.row < pixel.row;
      }

      isBelow(pixel) {
        return this.row > pixel.row;
      }

      isLeft(pixel) {
        return this.col < pixel.col;
      }

      isRight(pixel) {
        return this.col > pixel.col;
      }

      isNear(pixel, distance=6) {
        return (
          Math.abs(pixel.row - this.row) <= distance &&
          Math.abs(pixel.col - this.col) <= distance
        )
      }

      isNearestTo(pixels) {
        var closestPixel;
        var minDistance = -1;
        for (var pixel of pixels) {
          let distance = Math.abs(pixel.row - this.row) + Math.abs(pixel.col - this.col);
          if (distance < minDistance || minDistance == -1) {
            closestPixel = pixel;
            minDistance = distance;
          }
        }
        return closestPixel;
      }

      render(parent) {
        this.element = document.createElement("div");
        this.element.className = "pixel";
        this.element.id = this.id();
        this.element.style.position = "absolute";
        this.renderNormal();
        //this.element.style.border = "1px solid black";
        this.element.style.marginLeft = `${this.col * this.size * this.widthDivider}px`;
        this.element.style.marginTop = `${this.row * this.size}px`;
        this.element.style.height = `${this.size}px`;
        this.element.style.width = `${this.size * this.widthDivider}px`;
        this.setValue(" ");
        parent.appendChild(this.element);
      }
    }

    ////////////////
    //// CANVAS ////
    ////////////////

    class Canvas {
      
      rowCount = 60;
      colCount = 160;

      pixelSize = 14;
      pixelWidthDivider = 0.6;

      constructor() {
        this.pixels = {};
      }

      getPixelById(id) {
        return this.pixels[id];
      }

      getPixelByRowCol(row, col) {
        return this.getPixelById(Pixel.makeId(row, col));
      }
      
      clearPixels(pixels) {
        pixels.forEach((pixel) => pixel.clear());
      }

      clear() {
        for(var pixel in this.pixels) this.pixels[pixel].clear();
      }

      render() {
        this.element = document.getElementById("canvas");
        this.element.style.width  = `${this.colCount * this.pixelSize * this.pixelWidthDivider}px`;
        this.element.style.height = `${this.rowCount * this.pixelSize}px`;
        this.element.style.fontSize = `${this.pixelSize}px`;
        this.element.style.fontFamily = `monospace`;
        for (var row = 0; row < this.rowCount; row++) {
          for (var col = 0; col < this.colCount; col++) {
            let pixel = new Pixel(this.pixelSize, this.pixelWidthDivider, row, col);
            pixel.render(this.element);
            this.pixels[pixel.id()] = pixel;
          }
        }
      }
    }

    //////////////
    //// MENU ////
    //////////////
    
    class MenuButton {
      
      constructor (name, showCondition, setModes, activeModes, callback=()=>{}) {
        /*
        name: display name of the button
        showCondition: A ModeMaster condition that gets checked every Menu.refresh
          call to show/hide the button.
        setModes: A ModeMaster update command when the button is pressed.
        activeModes: A ModeMaster condition to choose if the button is selected.
        callback: A function callback on press.
        */
        this.name = name;
        this.showCondition = modeMaster.makeFunc(showCondition);
        this.callback = callback;
        this.setModes = modeMaster.makeFunc(setModes);
        this.activeModes = activeModes;

        this.defaultButtonColor = "black";
        this.defaultSelectedButtonColor = "blue";
      }
      
      onPress() {
        this.callback();
        this.setModes();
      }

      render(parent) {
        this.element = document.createElement("button");
        this.element.innerHTML = this.name;
        this.element.addEventListener("mousedown", () => this.onPress());
        parent.appendChild(this.element);
      }

      hide() {
        this.element.style.display = "none";
      }

      show() {
        this.element.style.display = "block";
      }

      unselect() {
        this.element.style.backgroundColor = this.defaultButtonColor; 
      }

      select() {
        this.element.style.backgroundColor = this.defaultSelectedButtonColor; 
      }

      isActive() {
        return this.activeModes.length && modeMaster.hasOr(...this.activeModes);
      }
    }

    class Menu {
      buttons = [
        new MenuButton("Square",
          [], [modeMaster.reset, "draw", "square", "dsbutton"], ["dsbutton"], () => layerManager.switchModeCallback()),
        new MenuButton("Text",
          [], [modeMaster.reset, "draw", "text", "dtbutton"], ["writing", "dtbutton"], () => layerManager.switchModeCallback()),
        new MenuButton("Line",
          [], [modeMaster.reset, "draw", "line", "free-line", "dflbutton"], ["dflbutton"], () => layerManager.switchModeCallback()),
        new MenuButton("Step Line", 
          [], [modeMaster.reset, "draw", "line", "step-line", "dslbutton"], ["dslbutton"], () => layerManager.switchModeCallback()),
        new MenuButton("Switch Line", 
          [], [modeMaster.reset, "draw", "line", "switch-line", "dswlbutton"], ["dswlbutton"], () => layerManager.switchModeCallback()),
        new MenuButton("Diamond",
          [], [modeMaster.reset, "draw", "diamond", "ddibutton"], ["ddibutton"], () => layerManager.switchModeCallback()),
        new MenuButton("Table",
          [], [modeMaster.reset, "draw", "table", "dtblbutton"], ["dtblbutton"], () => layerManager.switchModeCallback()),
        new MenuButton("Free",
          [], [modeMaster.reset, "draw", "free", "dfbutton"], ["dfbutton"], () => layerManager.switchModeCallback()),
        new MenuButton("Erase",
          [], [modeMaster.reset, "erase", "ebutton"], ["ebutton"], () => layerManager.switchModeCallback()),
        new MenuButton("Select",
          [], [modeMaster.reset, "select"], ["selected", "select"], () => layerManager.switchModeCallback()),
        new MenuButton("Undo",
          [], [], [], (event) => layerManager.undoEvent(event)),
        new MenuButton("Redo",
          [], [], [], (event) => layerManager.redoEvent(event)),
        new MenuButton("Restart",
          [], [], [], () => layerManager.refresh(() => layerManager.empty())),
        new MenuButton("Copy",
          [modeMaster.has, "selected"], [], [], (event) => layerManager.copySelectedLayersEvent(event)),
        new MenuButton("Group",
          [modeMaster.has, "selected"], [], [], (event) => layerManager.groupSelectedLayersEvent(event)),
        new MenuButton("Ungroup",
          [modeMaster.has, "selected"], [], [], (event) => layerManager.ungroupSelectedLayersEvent(event)),
        new MenuButton("Delete",
          [modeMaster.has, "selected"], [modeMaster.reset, "select"], [], (event) => layerManager.deleteLayersEvent(event)),
        new MenuButton("Bring Forward",
          [modeMaster.has, "selected"], [], [], (event) => layerManager.bringForwardEvent(event)),
        new MenuButton("Send Backwards",
          [modeMaster.has, "selected"], [], [], (event) => layerManager.sendBackwardsEvent(event)),
        new MenuButton("Bring To Front",
          [modeMaster.has, "selected"], [], [], (event) => layerManager.bringToFrontEvent(event)),
        new MenuButton("Send To Back",
          [modeMaster.has, "selected"], [], [], (event) => layerManager.sendToBackEvent(event)),
        new MenuButton("<-",
          [modeMaster.has, "draw", "line"], [modeMaster.toggle, "arrow-left"], ["arrow-left"]),
        new MenuButton("->",
          [modeMaster.has, "draw", "line"], [modeMaster.toggle, "arrow-right"], ["arrow-right"]),
        new MenuButton("<-",
          [modeMaster.has, "selected", "line"], [], [], () => layerManager.redrawLinesEvent("left")),
        new MenuButton("->",
          [modeMaster.has, "selected", "line"], [], [], () => layerManager.redrawLinesEvent("right")),
      ] 
      
      constructor() {
        this.id = "menu";
        this.element = document.getElementById(this.id);
        modeMaster.registerCallback(() => menu.refresh());
      }
      
      unselectAll() {
        this.buttons.forEach(button => button.unselect());
      }

      refresh() {
        for (var button of this.buttons) {
          button.hide();
          button.unselect();
        }
        for (var button of this.buttons) {
          if (button.showCondition()) button.show();
          if (button.isActive()) button.select();
        }
      }

      render() {
        for (var button of this.buttons) button.render(this.element);
        this.refresh();
      }
    }
    

    // CONSTS
    let layerTypes = [
      FreeLayer,
      FreeLineLayer,
      StepLineLayer,
      SwitchLineLayer,
      SquareLayer,
      TableLayer,
      DiamondLayer,
      TextLayer,
    ]
    
    // MANAGERS
    modeMaster         = new ModeMaster(layerTypes);
    layerManager       = new LayerManager();
    areaSelectManager  = new AreaSelectManager();
    eventManager       = new EventManager();
    charManager        = new CharManager();
    
    // COMPONENTS
    menu   = new Menu();
    canvas = new Canvas();

    menu.render();
    canvas.render();
    
    // EVENT ASSIGNMENT
    eventManager.assignAll(
      {window: window, document: document, canvas: canvas.element}
    );

    </script>
  </body>
</html>
