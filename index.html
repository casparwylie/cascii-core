<html>
  <head>
    <style>
      #canvas {
        background: grey;
        user-select: none;
      }

      #menu {
        background: blue;
        height: 50px;
      }

      #menu button {
        padding: 10px;
        margin-left: 10px;
        float: left;
      }
    </style>
  </head>
  <body>
    <div id="menu"></div>
    <div id="canvas"></div>

  <script defer>
    /*

    TODO
    FE 
    - multi line text, redit text, double click
    - area selection (all layers in square)
    - file break up?
    - export 
    - choose char for free draw
    - diagnol shapes
    - arrow headed lines
    - proper design / config
    - unicode v ascii
    - themes
    - z-index concepting

    - BE: save, share, manage, user, login google + github,  CRUD
      - guest auto save (refresh keeps)
    
    DONE
    - copy / paste selection
    - undo/redo
    - square shape
    - shape resizing
    */
    const KEYS = {
      "up"      : 38,
      "right"   : 39,
      "down"    : 40,
      "left"    : 37,

      "shift"   : 16,
      "back"    : 8,
      "delete"  : 46,
      "esc"     : 27,
      "ctrl"    : 17,

      "z"       : 90,
      "c"       : 67,
    }

    const masterRowCount = 50;
    const masterColCount = 80;

    const pixelSize = 15;
    
    function reportError(message) {
      console.log(message);
    }

    //////////////////
    ////// MODES /////
    //////////////////

    class ModeMaster {
      constructor() {
        this._modes = []
      }

      change(beforeMode, afterMode) {
        let index = this._modes.indexOf(beforeMode);
        if (index == -1) return;
        this._modes[index] = afterMode;
      }

      remove(...modes) {
        modes.forEach((mode) => {
          let index = this._modes.indexOf(mode);
          if (index == -1) return; 
          this._modes.splice(index, 1);
        });
      }

      reset(...modes) {
        this._modes = modes;
      }

      add(...modes) {
        this._modes = this._modes.concat(modes);
      }

      has(...modes) {
        let r= modes.map((mode) => this._modes.includes(mode)).every(Boolean);
        return r;
      }

      is(...modes) {
        return this._modes.toString() == modes.toString(); 
      }
      
      removeShapes() {
        this.remove("square");
        this.remove("line");
        this.remove("free");
        this.remove("text");
      }

      setShape(name) {
        this.removeShapes();
        this.add(name);
      }

      get(modes, insist=false) {
        let result = modes.filter((mode) => this._modes.includes(mode));
        if (insist && result.length == 0) reportError(`Bad mode get ${this._modes}: expected ${modes}`);
        return result
      }
    }
    
    ////////////////////
    ////// LAYERS //////
    ////////////////////

    class LayerManager {
      constructor() {
        this.layers = [];
        this.selectedPixel = null;
        this.layerHistory = [[]];
        this.historyCursor = 0;
      }

      add(layer) {
        this.layers.unshift(layer);
      } 

      getLatestLayer() {
        return this.layers[0];
      }

      getLayerByPixelId(id) {
        for (var layer of this.layers) {
          if (layer.getPixelIndex(id) > -1) return layer;
        }
      }

      getSelectedLayers() {
        return this.layers.filter((layer) => layer.isSelected());
      }

      deleteSelectedLayers() {
        this.getSelectedLayers().forEach((layer) => layer.empty());
      }

      copySelectedLayers() {
        this.getSelectedLayers().forEach((layer) => {
          let layerCopy = layer.copy();
          while (this.isLayerOverlapped(layerCopy)) layerCopy.move(1, 1);
          this.add(layerCopy); 
          layer.unselect();
          layerCopy.select();
        });
        this.capture();
      }


      isLayerOverlapped(subjectLayer) {
        for (var layer of this.layers) {
          if (layer.isOverlapping(subjectLayer)) return true;
        }
      }

      unselectAll() {
        this.layers.forEach((layer) => layer.unselect());
        modeMaster.change("selected", "select");
        modeMaster.removeShapes();
      }

      refresh(updateFunc) {
        this.clearAll();
        updateFunc();
        this.renderAll();
      }

      tidyLayers() {
        this.layers = this.layers.filter((layer) => layer.pixels.length);
        this.capture();
      }

      clearAll() {
        this.layers.forEach((layer) => layer.clear());
      }

      renderAll() {
        this.layers.forEach((layer) => layer.render());
      }

      empty() {
        this.layers = [];
        this.layerHistory = [];
      }

      capture() {
        this.historyCursor = 0;
        this.layerHistory.unshift(this.copyLayers(this.layers));
      }

      copyLayers(layers) {
        return layers.map(layer => layer.copy());
      }

      undo() {
        let limit = this.layerHistory.length - 1;
        this.historyCursor = (this.historyCursor < limit)? this.historyCursor + 1: limit;
        // Copy historic layers to avoid mutating them now that they're current.
        // Past will otherwise show as present...
        this.layers = this.copyLayers(this.layerHistory[this.historyCursor]); 
      }

      redo() {
        this.historyCursor = (this.historyCursor > 0)? this.historyCursor - 1: 0;
        // Copy historic layers to avoid mutating them now that they're current.
        // Past will otherwise show as present...
        this.layers = this.copyLayers(this.layerHistory[this.historyCursor]);
      }
      
      setSelectPixel(selectedPixel) {
        this.selectedPixel = selectedPixel;
      }

      getSelectPixel() {
        return this.selectedPixel;
      }

      moveSelectedLayers(verticalDiff, lateralDiff) {
        this.getSelectedLayers().forEach((layer) => layer.move(verticalDiff, lateralDiff));
      }

      movingMouseOverEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        let lastPixelSelected = this.getSelectPixel();
        let verticalDiff = activePixel.row - lastPixelSelected.row;
        let lateralDiff = activePixel.col - lastPixelSelected.col;
        this.refresh(() => this.moveSelectedLayers(verticalDiff, lateralDiff));
        this.setSelectPixel(activePixel);
      }

      selectedArrowKeyDownEvent(event) {
        var verticalDiff = 0;
        var lateralDiff = 0;
        switch (event.keyCode) {
          case KEYS["up"]:
            verticalDiff = -1;
            break;
          case KEYS["right"]:
            lateralDiff = 1;
            break;
          case KEYS["down"]:
            verticalDiff = 1;
            break;
          case KEYS["left"]:
            lateralDiff = -1;
            break;
        }
        this.refresh(() => this.moveSelectedLayers(verticalDiff, lateralDiff));
      }
    }
    

    class Layer {
      constructor(firstPixelId) {
        this.pixels = [];
        this.values = [];
        this._isSelected = false;

        this.setFirstPixel(firstPixelId);
        layerManager.setSelectPixel(this.firstPixel);
      }

      static selectMouseDown(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        let layer = layerManager.getLayerByPixelId(activePixel.id());
        let selectedLayers = layerManager.getSelectedLayers();

        // Unselect all if...
        // 1. clicked-off (no layer selected)
        // 2. Single select mode (not multi) and only one selected,
        //    (otherwise multi was used but not active, so we keep selection).
        // 3. Single select mode (not multi) and selected other layer
        if (!layer || (!modeMaster.has("shift") && (selectedLayers.length < 2 && !layer.isSelected()))) {
          layerManager.unselectAll();
        }
        if (layer) {
          modeMaster.change("select", "selected");
          modeMaster.setShape(layer.name);
          let resizePixel = layer.getResizePixel(activePixel);
          if (resizePixel) {
            layer.setFirstPixel(resizePixel);
            modeMaster.add("resizing");
          } else {
            layerManager.setSelectPixel(activePixel);
            modeMaster.add("moving");
          }
          layer.select();
        }
      }

      select() {
        this._isSelected = true;
        this.pixels.forEach((pixel) => pixel.renderSelected());
      }

      setFirstPixel(id) {
        this.firstPixel = canvas.getPixelById(id);
      }

      draw(pixel, value) {
        let existingPixelIndex = this.getPixelIndex(pixel.id());

        if (existingPixelIndex == -1) {
          this.pixels.push(pixel);
          this.values.push(value);
        } else {
          this.values[existingPixelIndex] = value;
        }
        if (this.pixels.length != this.values.length) {
          console.log(`layer pixel/value mismatch: ${this.pixels} != ${this.values}`)
        }
      }

      getResizePixel() { // Resizeable layers will override this method
        return false;
      }
      
      clear() {
        this.pixels.forEach((pixel) => pixel.clear());
      }

      copy() {
        let layerCopy = new this.constructor(this.firstPixel.id());
        layerCopy.pixels = this.pixels.map(pixel => pixel);
        layerCopy.values = this.values.map(value => value);
        return layerCopy;
      }

      isOverlapping(subjectLayer) {
        for (var subjectPixel of subjectLayer.pixels) {
          var found = false;
          for (var pixel of this.pixels) {
            if (pixel.id() == subjectPixel.id()) {
              found = true;
              break;
            }
          }
          if (!found) return false;
        }
        return true;
      }

      render() {
        for (var i = 0; i < this.pixels.length; i++) {
          this.pixels[i].setValue(this.values[i]);
          if(this.isSelected()) this.pixels[i].renderSelected();
        }
      }

      move(verticalDiff, lateralDiff) {
        let newPixels = [];
        for (var oldPixel of this.pixels) {
          let newPixel = canvas.getPixelByRowCol(
            oldPixel.row + verticalDiff,
            oldPixel.col + lateralDiff
          );
          if (!newPixel) return;
          newPixels.push(newPixel);
        }
        this.pixels = newPixels;
      }

      getPreviousPixel() {
        return this.pixels[this.pixels.length - 1];
      }

      getPixelIndex(id) {
        for (var i = 0; i < this.pixels.length; i++) {
          let pixel = this.pixels[i];
          if (pixel.id() == id) return i;
        }
        return -1;
      }

      erasePixel(id) {
        for (var i = 0; i < this.pixels.length; i++) {
          if (this.pixels[i].id() == id) this.deletePixelByPosition(i);
        }
      }

      deletePixelByPosition(index) {
        this.pixels.splice(index, 1);
        this.values.splice(index, 1);
      }
      
      isSelected() {
        return this._isSelected;
      }

      unselect() {
        this._isSelected = false;
        this.pixels.forEach((pixel) => pixel.renderNormal());
      }

      empty() {
        this.pixels = [];
        this.values = [];
      }
    }
    

    function deleteLayersEvent() {
      layerManager.refresh(() => layerManager.deleteSelectedLayers());
    }

    function undoEvent(event) {
      layerManager.refresh(() => layerManager.undo());
    }

    function redoEvent(event) {
      layerManager.refresh(() => layerManager.redo());
    }

    /////////////////////////
    ////// TEXT LAYER ///////
    /////////////////////////

    class TextLayer extends Layer {
      
      name = "text"

      constructor(firstPixelId) {
        super(firstPixelId);
        this.cursor = 0;
        this.contents = [];
        this.layer = null;
      }
      
      static selectedDoubleClick(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        let layer = layerManager.getLayerByPixelId(activePixel.id());
        layer.moveCursorToPixel(activePixel);
      }
      static drawMouseDown(event) {
        let layer = new TextLayer(event.target.id);
        menu.unselectAll();
        layerManager.add(layer);
        layer.firstPixel.renderFocus();
      }

      static writingMouseDown(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        let layer = layerManager.getLayerByPixelId(activePixel.id());
        if (layer) {
          layer.moveCursorToPixel(activePixel);
        } else {
          modeMaster.change("writing", "select")
          layerManager.unselectAll();
        }
      }

      static keyDown(event) {
        let selectedLayers = layerManager.getSelectedLayers();
        let layer = (selectedLayers.length) ? selectedLayers[0]: layerManager.getLatestLayer();
        layer.writeChar(event.keyCode);
      }

      getLength() {
        return this.contents.length;
      }

      moveCursorToPixel(pixel) {
        this.cursor = this.getPixelIndex(pixel.id()) + 1;
        pixel.renderFocus();
      }

      renderChars() {
        // Get latest first pixel given the layer may have moved and this could be
        // an edit. 
        this.firstPixel = (this.pixels.length) ? this.pixels[0]: this.firstPixel;
        this.empty();
        let pixels = [];
        for (var i = 0; i < this.getLength(); i++) {
          let pixel = canvas.getPixelByRowCol(this.firstPixel.row, this.firstPixel.col + i);
          if (this.cursor == i + 1) pixel.renderCursor();
          if (!pixel) continue;
          this.draw(pixel, this.contents[i]);
        }
      }

      writeChar(key) {
        let char = String.fromCharCode(key);
        let length = this.getLength();
        switch (key) {
          case KEYS["up"]: 
          break;
          case KEYS["right"]:
            this.cursor = (this.cursor >= length)? length: this.cursor + 1;
          break;
          case KEYS["down"]:
          break;
          case KEYS["left"]:
            this.cursor = (this.cursor <= 0)? 0: this.cursor - 1;
          break;
          case KEYS["enter"]:
          break;
          case KEYS["back"]:
            this.cursor = (this.cursor <= 0)? 0: this.cursor - 1;
            this.contents.splice(this.cursor, 1);
          break;
          default:
            this.contents.splice(this.cursor, 0, char);
            this.cursor++;
          break;
        }
        layerManager.refresh(() => this.renderChars());

      }
    }

    /////////////////////////
    ////// LINE LAYER ///////
    /////////////////////////

    class LineLayer extends Layer {

      name = "line"

      static drawMouseDown(event) {
        let layer = new LineLayer(event.target.id);
        layerManager.add(layer);
      }

      static drawingMouseOver(event) {
        let layer = layerManager.getLatestLayer();
        layerManager.refresh(() => layer.drawLine(event.target.id));
      }

      static resizingMouseOver(event) {
        let layer = layerManager.getSelectedLayers()[0];
        layerManager.refresh(() => layer.drawLine(event.target.id));
      }

      getResizePixel(pixel) {
        if (pixel.id() == this.pixels[0].id()) return this.pixels[this.pixels.length - 1].id();
        if (pixel.id() == this.pixels[this.pixels.length - 1].id()) return this.pixels[0].id();
      }

      drawLine(activePixelId) {
        this.empty();
        let activePixel = canvas.getPixelById(activePixelId);
        let verticalDiff = Math.abs(activePixel.row - this.firstPixel.row);
        let lateralDiff = Math.abs(activePixel.col - this.firstPixel.col);

        if (activePixel.isAbove(this.firstPixel) && verticalDiff > lateralDiff) {
          for(var row = this.firstPixel.row; row >= activePixel.row; row --) {
            this.draw(canvas.getPixelByRowCol(row, this.firstPixel.col), "|");
          }
        } else if (activePixel.isBelow(this.firstPixel) && verticalDiff > lateralDiff) {
          for(var row = this.firstPixel.row; row <= activePixel.row; row ++) {
            this.draw(canvas.getPixelByRowCol(row, this.firstPixel.col), "|");
          }
        } else if (activePixel.isLeft(this.firstPixel) && verticalDiff < lateralDiff) {
          for(var col = this.firstPixel.col; col >= activePixel.col; col --) {
            this.draw(canvas.getPixelByRowCol(this.firstPixel.row, col), "─");
          }
        } else if (activePixel.isRight(this.firstPixel) && verticalDiff < lateralDiff) {
          for(var col = this.firstPixel.col; col <= activePixel.col; col ++) {
            this.draw(canvas.getPixelByRowCol(this.firstPixel.row, col), "─");
          }
        }
      } 
    }

    /////////////////////////
    ////// FREE LAYER ///////
    /////////////////////////

    class FreeLayer extends Layer {
      
      name = "free";

      static drawMouseDown(event) {
        let layer = new FreeLayer(event.target.id);
        layerManager.add(layer);
        layerManager.refresh(() => layer.drawFree(event.target.id));
      }

      static drawingMouseOver(event) {
        let layer = layerManager.getLatestLayer();
        layerManager.refresh(() => layer.drawFree(event.target.id));
      }

      drawFree(activePixelId) {
        let activePixel = canvas.getPixelById(activePixelId);
        this.draw(activePixel, "x");
      }
    }

    //////////////////////
    //// SQUARE LAYER ////
    //////////////////////

    class SquareLayer extends Layer {
      
      name = "square" 

      static drawMouseDown(event) {
        let layer = new SquareLayer(event.target.id);
        layerManager.add(layer);
      }

      static drawingMouseOver(event) {
        let layer = layerManager.getLatestLayer();
        layerManager.refresh(() => layer.drawSquare(event.target.id));
      }

      static resizingMouseOver(event) {
        let layer = layerManager.getSelectedLayers()[0];
        layerManager.refresh(() => layer.drawSquare(event.target.id));
      }

      getResizePixel(pixel) {
        let corners = this.getCornerPixels();
        let cornerMatch = corners.indexOf(pixel.id());
        if (cornerMatch == -1) return;
        let firstPixelIndex = cornerMatch + 2;
        if (firstPixelIndex > 3) {
          firstPixelIndex = firstPixelIndex - 4;
        }
        return corners[firstPixelIndex];
      }

      getCornerPixels() {
        var maxCol = -1;
        var minCol = -1;
        var maxRow = -1;
        var minRow = -1;
        for (var pixel of this.pixels) {
          if (pixel.col > maxCol) {
            maxCol = pixel.col;
          }
          if (pixel.col < minCol || minCol == -1) {
            minCol = pixel.col; 
          }
          if (pixel.row > maxRow) {
            maxRow = pixel.row;
          }
          if (pixel.row < minRow || minRow == -1) {
            minRow = pixel.row; 
          }
        }
        return [
          Pixel.makeId(minRow, minCol),
          Pixel.makeId(minRow, maxCol),
          Pixel.makeId(maxRow, maxCol),
          Pixel.makeId(maxRow, minCol),
        ]
      }

      drawSquare(activePixelId) {
        this.empty();
        let activePixel = canvas.getPixelById(activePixelId);
        if (activePixel.isAbove(this.firstPixel)) {
          for(var row = this.firstPixel.row; row >= activePixel.row; row --) {
            this.draw(canvas.getPixelByRowCol(row, this.firstPixel.col), "|");
          }
          for(var row = this.firstPixel.row; row >= activePixel.row; row --) {
            this.draw(canvas.getPixelByRowCol(row, activePixel.col), "|");
          }
        } else if (activePixel.isBelow(this.firstPixel)) {
          for(var row = this.firstPixel.row; row <= activePixel.row; row ++) {
            this.draw(canvas.getPixelByRowCol(row, this.firstPixel.col), "|");
          }
          for(var row = this.firstPixel.row; row <= activePixel.row; row ++) {
            this.draw(canvas.getPixelByRowCol(row, activePixel.col), "|");
          }
        }
        if (activePixel.isLeft(this.firstPixel)) {
          for(var col = this.firstPixel.col; col >= activePixel.col; col --) {
            this.draw(canvas.getPixelByRowCol(this.firstPixel.row, col), "─");
          }
          for(var col = this.firstPixel.col; col >= activePixel.col; col --) {
            this.draw(canvas.getPixelByRowCol(activePixel.row, col), "─");
          }
        } else if (activePixel.isRight(this.firstPixel)) {
          for(var col = this.firstPixel.col; col <= activePixel.col; col ++) {
            this.draw(canvas.getPixelByRowCol(this.firstPixel.row, col), "─");
          }
          for(var col = this.firstPixel.col; col <= activePixel.col; col ++) {
            this.draw(canvas.getPixelByRowCol(activePixel.row, col), "─");
          }
        }
      } 
    }

    
    ///////////////////
    ////// ERASE //////
    ///////////////////

    function erasingMouseUpEvent(event) {
    }

    function erasePixelEvent(event) {
      let activePixel = canvas.getPixelById(event.target.id);
      let layer = layerManager.getLayerByPixelId(activePixel.id());
      if (layer) layer.erasePixel(activePixel.id());
      activePixel.clear();
    }

    function eraseMouseDownEvent(event) {
      erasePixelEvent(event);
    }


    function erasingMouseOverEvent(event) {
      erasePixelEvent(event);
    }
    

    ////////////////
    //// EVENTS ////
    ////////////////

    const modeMaster = new ModeMaster();

    class EventInstruction {
      constructor(modeCondition, modeUpdate, callback=()=>{}) {
        this.callback = callback;
        this.condition = (modeCondition.length)? this.makeFunc(modeCondition): () => true;
        this.update = this.makeFunc(modeUpdate);
      }
      
      makeFunc(instruction) {
        return (instruction.length)? instruction[0].bind(modeMaster, ...instruction.slice(1)): () => {};
      }

      run(event) {
        if (this.condition()) {
          this.update();
          this.callback(event);
          console.log(modeMaster._modes);
          return true;
        }
      }
    }
    const ArrowKeyGroup = ["up", "down", "left", "right"];

    function keyGroup(...names) {
      let keys = names.map(name => KEYS[name].toString());
      return keys.join(",");
    }


    let documentEventKeyInstructions = {
      "keypress": {
        "*": [
          new EventInstruction([modeMaster.has, "writing", "text"], [], TextLayer.keyDown),
        ],
      },
      "keydown": {
        [keyGroup(...ArrowKeyGroup)]: [
          new EventInstruction([modeMaster.has, "selected"], [], (event) => layerManager.selectedArrowKeyDownEvent(event)),
        ],                                                                        
        [keyGroup("shift")]: [
          new EventInstruction([], [modeMaster.add, "shift"])
        ],
        [keyGroup("back", "delete")]: [
          new EventInstruction([modeMaster.has, "selected"], [modeMaster.reset, "select"], deleteLayersEvent),
        ],
        [keyGroup("esc")]: [
          new EventInstruction([modeMaster.has, "selected"], [modeMaster.reset, "select"], (event) => layerManager.unselectAll()),
        ],
        [keyGroup("back", "delete", ...ArrowKeyGroup)]: [
          new EventInstruction([modeMaster.is, "writing", "text"], [], TextLayer.keyDown),
        ],
        [keyGroup("ctrl")]: [
          new EventInstruction([], [modeMaster.add, "ctrl"]),
        ],
        [keyGroup("z")]: [
          new EventInstruction([modeMaster.has, "shift", "ctrl"], [], redoEvent),
          new EventInstruction([modeMaster.has, "ctrl"], [], undoEvent),
        ],
        [keyGroup("c")]: [
          new EventInstruction([modeMaster.has, "ctrl", "selected"], [], (event) => layerManager.refresh(() => layerManager.copySelectedLayers())),
        ],
      },
      "keyup": {
        [keyGroup("shift")]: [
          new EventInstruction([modeMaster.has, "shift"], [modeMaster.remove, "shift"]),
        ],
        [keyGroup("ctrl")]: [
          new EventInstruction([modeMaster.has, "ctrl"], [modeMaster.remove, "ctrl"]),
        ],
      }
    }

    let canvasEventInstructions = {
      "mousedown": [
        new EventInstruction([modeMaster.has, "draw", "text"],    [modeMaster.change, "draw", "writing"], TextLayer.drawMouseDown),
        new EventInstruction([modeMaster.has, "draw", "line"],    [modeMaster.change, "draw", "drawing"], LineLayer.drawMouseDown),
        new EventInstruction([modeMaster.has, "draw", "free"],    [modeMaster.change, "draw", "drawing"], FreeLayer.drawMouseDown),
        new EventInstruction([modeMaster.has, "draw", "square"],    [modeMaster.change, "draw", "drawing"], SquareLayer.drawMouseDown),
        new EventInstruction([modeMaster.has, "writing", "text"],    [], TextLayer.writingMouseDown),
        new EventInstruction([modeMaster.is, "erase"],            [modeMaster.change, "erase", "erasing"], eraseMouseDownEvent),
        new EventInstruction([modeMaster.has, "select"],          [], Layer.selectMouseDown),
        new EventInstruction([modeMaster.has, "selected"],        [], Layer.selectMouseDown),
      ],
      "mouseup": [
        new EventInstruction([modeMaster.has, "drawing"],         [modeMaster.change, "drawing", "draw"], (event) => layerManager.tidyLayers()), 
        new EventInstruction([modeMaster.is, "erasing"],          [modeMaster.change, "erasing", "erase"], erasingMouseUpEvent),
        new EventInstruction([modeMaster.has, "moving"],          [modeMaster.remove, "moving"], (event) => layerManager.tidyLayers()),
        new EventInstruction([modeMaster.has, "resizing"],          [modeMaster.reset, "selected"], (event) => layerManager.tidyLayers()),
      ],
      "mouseover": [
        new EventInstruction([modeMaster.has, "drawing", "free"], [], FreeLayer.drawingMouseOver),
        new EventInstruction([modeMaster.has, "drawing", "line"], [], LineLayer.drawingMouseOver),
        new EventInstruction([modeMaster.has, "drawing", "square"], [], SquareLayer.drawingMouseOver),
        new EventInstruction([modeMaster.is, "erasing"],          [], erasingMouseOverEvent),
        new EventInstruction([modeMaster.has, "moving"],          [], (event) => layerManager.movingMouseOverEvent(event)),
        new EventInstruction([modeMaster.has, "resizing", "line"],          [], LineLayer.resizingMouseOver),
        new EventInstruction([modeMaster.has, "resizing", "square"],          [], SquareLayer.resizingMouseOver),
      ],
      "dblclick": [
        new EventInstruction([modeMaster.has, "selected", "text"],          [modeMaster.change, "selected", "writing"], TextLayer.selectedDoubleClick),
      ]
    }


    ////////////////
    //// PIXEL /////
    ////////////////

    class Pixel {
      constructor(size, row, col) {
        this.row = row;
        this.col = col;
        this.size = size;
        this.defaultColor = "#000000";
        this.defaultBgColor = "transparent";
        this.defaultBorder = "none";
        this.cursorFlashInterval = null;
      }
      
      id() {
        return Pixel.makeId(this.row, this.col);
      }

      static makeId(row, col) {
        return `pixel-${row},${col}`
      }

      setValue(value) {
        this.element.innerHTML = value;
      }

      renderSelected() {
        this.setColor("blue");
      }

      renderCursor() {
        this.renderNormal();
        this.element.style.borderRight = "1px solid orange";
        setTimeout((pixel) => {
          pixel.element.style.borderRight = "none";
        }, 500, this);
        this.cursorFlashInterval = setInterval(
            (pixel) => {
              this.element.style.borderRight = "1px solid orange";
              setTimeout(() => {
                pixel.element.style.borderRight = "none";
              }, 500);
            }, 1000, this);
      }

      renderFocus() {
        this.setBgColor("orange");
      }

      renderNormal() {
        clearInterval(this.cursorFlashInterval);
        this.setColor(this.defaultColor);
        this.setBgColor(this.defaultBgColor);
        this.element.style.border = "none";
      }

      setColor(color) {
        this.element.style.color = color;
      }

      setBgColor(color) {
        this.element.style.backgroundColor = color;
      }


      clear() {
        this.setValue(" ");
        this.renderNormal();
      }

      isAbove(pixel) {
        return this.row < pixel.row;
      }

      isBelow(pixel) {
        return this.row > pixel.row;
      }

      isLeft(pixel) {
        return this.col < pixel.col;
      }

      isRight(pixel) {
        return this.col > pixel.col;
      }

      render(parent) {
        this.element = document.createElement("div");
        this.element.className = "pixel";
        this.element.id = this.id();
        this.element.style.position = "absolute";
        this.renderNormal();
        //this.element.style.border = "1px solid black";
        this.element.style.marginLeft = `${this.col * this.size}px`;
        this.element.style.marginTop = `${this.row * this.size}px`;
        this.element.style.height = `${this.size}px`;
        this.element.style.width = `${this.size}px`;
        parent.appendChild(this.element);
      }
    }

    ////////////////
    //// CANVAS ////
    ////////////////

    class Canvas {
      constructor(rowCount, colCount, pixelSize) {
        this.rowCount = rowCount;
        this.colCount = colCount;
        this.pixelSize = pixelSize;
        this.pixels = {};
      }

      getPixelById(id) {
        return this.pixels[id];
      }

      getPixelByRowCol(row, col) {
        return this.getPixelById(Pixel.makeId(row, col));
      }
      
      clearPixels(pixels) {
        pixels.forEach((pixel) => pixel.clear());
      }

      clear() {
        for(var pixel in this.pixels) this.pixels[pixel].clear();
      }

      render() {
        this.element = document.getElementById("canvas");
        this.element.style.width  = `${this.colCount * this.pixelSize}px`;
        this.element.style.height = `${this.rowCount * this.pixelSize}px`;
        this.element.style.fontSize = `${this.pixelSize}px`;
        this.element.style.fontFamily = `monospace`;
        for (var row = 0; row < this.rowCount; row++) {
          for (var col = 0; col < this.colCount; col++) {
            let pixel = new Pixel(this.pixelSize, row, col);
            pixel.render(this.element);
            this.pixels[pixel.id()] = pixel;
          }
        }
        assignMouseEventInstructions(this.element, canvasEventInstructions);
      }
    }

    function assignMouseEventInstructions(element, instructions) {
      for (const [eventType, story] of Object.entries(instructions)) {
        element.addEventListener(eventType, (event) => {
          for (var eventInstruction of story) {
            if (eventInstruction.run(event)) return;
          }
        })
      }
    }
    function assignKeyEventInstructions(element, instructions) {
      Object.keys(instructions).forEach((eventType) => {
        element.addEventListener(eventType, (event) => {
          for (keys in instructions[eventType]) {
            keys.split(",").forEach(key => {
              if (key == event.keyCode.toString() || key == "*") {
                for (var eventInstruction of instructions[eventType][keys]) {
                  if (eventInstruction.run(event)) return;
                }
              }
            });
          }
        });
      });
    }

    class Menu {
      
      constructor() {
        this.id = "menu";
        this.element = document.getElementById(this.id);
        this.defaultButtonColor = "green";
        this.defaultSelectedButtonColor = "blue";
      }

      modeButtonPress(event, modes) {
          this.selectButton(event);
          modeMaster.reset(...modes);
      }

      selectButton(event) {
        layerManager.unselectAll();
        this.unselectAll();
        event.target.style.backgroundColor = this.defaultSelectedButtonColor;
      }

      unselectAll() {
        document.querySelectorAll(`#${this.id} button`).forEach((button) => {
          button.style.backgroundColor = this.defaultButtonColor;
        });
      }

      renderModeButton(name, modes) {
        this.renderButton(name, (event) => this.modeButtonPress(event, modes));
      }

      renderButton(name, callback) {
        let button = document.createElement("button");
        button.innerHTML = name;
        button.addEventListener('mouseup', callback);
        this.element.appendChild(button);
      }


      render() {
        this.renderModeButton("Draw Square", ["draw", "square"]);
        this.renderModeButton("Text", ["draw", "text"]);
        this.renderModeButton("Draw Line", ["draw", "line"]);
        this.renderModeButton("Draw Free", ["draw", "free"]);
        this.renderModeButton("Erase Free", ["erase"]);
        this.renderModeButton("Select", ["select"]);
        this.renderButton("Restart", () => layerManager.refresh(() => layerManager.empty()));
        this.unselectAll();
      }
    }

    let layerManager = new LayerManager();
    let menu = new Menu();
    let canvas = new Canvas(masterRowCount, masterColCount, pixelSize);
    menu.render();
    canvas.render();

    assignKeyEventInstructions(document, documentEventKeyInstructions);


    </script>
  </body>
</html>
